<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Illusion&#39;s Notes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.jiyongguang.xin/"/>
  <updated>2018-10-11T09:02:00.673Z</updated>
  <id>http://www.jiyongguang.xin/</id>
  
  <author>
    <name>Illusion</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于线程池的面试题</title>
    <link href="http://www.jiyongguang.xin/java-threadPool.html"/>
    <id>http://www.jiyongguang.xin/java-threadPool.html</id>
    <published>2018-10-11T09:00:45.000Z</published>
    <updated>2018-10-11T09:02:00.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>问题：</p>
<ol>
<li>单机上一个线程正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）</li>
<li>为什么要使用线程池，线程池用什么用</li>
<li>说说几种常见的线程池及使用场景</li>
<li>线程池有哪几种工作队列</li>
<li>怎么理解无界队列和有界队列</li>
<li>线程池中的几种重要的参数及流程</li>
</ol>
<a id="more"></a>
<h1 id="1-为什么要使用线程池，线程池用什么用"><a href="#1-为什么要使用线程池，线程池用什么用" class="headerlink" title="1. 为什么要使用线程池，线程池用什么用"></a>1. 为什么要使用线程池，线程池用什么用</h1><ol>
<li>降低资源消耗：通过重用已经创建的线程来降低线程创建和销毁的消耗</li>
<li>提高响应速度：任务到达时不需要等待线程创建就可以立即执行</li>
<li>提高线程的可管理性：线程池可以统一管理、分配、调优和监控</li>
</ol>
<h1 id="2-说说几种常见的线程池及使用场景"><a href="#2-说说几种常见的线程池及使用场景" class="headerlink" title="2. 说说几种常见的线程池及使用场景"></a>2. 说说几种常见的线程池及使用场景</h1><ul>
<li>newFixedThreadPool（固定大小的线程池）</li>
<li>newSingleThreadExecutor（单线程线程池）</li>
<li>newCachedThreadPool（可缓存线程的线程池）</li>
<li>newScheduledThreadPool</li>
</ul>
<h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>线程池特点：</strong></p>
<ul>
<li>核心线程数和最大线程数大小一样</li>
<li><code>keepAliveTime</code>为0</li>
<li>阻塞队列是<code>LinkedBlockingQueue</code></li>
</ul>
<p>它是固定大小的线程池，其核心线程数和最大线程数大小一样。并且阻塞队列用的是<code>LinkedBlockingQueue</code>，也就是说线程最大数这个参数失效了基本，所以不会出现外包线程的存在，所以也可以认为<code>keepAliveTime</code>参数是一个摆设。除非<code>allowCoreThreadTimeOut</code>方法的调用。</p>
<p><strong>该线程池的工作机制是：</strong></p>
<ol>
<li>线程数少于核心线程数，也就是设置的线程数时，新建线程执行任务</li>
<li>线程数等于核心线程数后，将任务加入阻塞队列 <ol>
<li>由于队列容量非常大(<code>Integer.MAX_VALUE</code>)，可以一直加加加。(当线程池中的任务比较特殊时，比如关于数据库的长时间的IO操作，可能导致OOM)</li>
</ol>
</li>
<li>执行完任务的线程反复去队列中取任务执行</li>
</ol>
<p><strong>适用场景：</strong></p>
<p><code>FixedThreadPool</code> 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程即可。一般Ncpu+1</p>
<h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>线程池特点：</strong></p>
<ul>
<li>核心线程数和最大线程数大小一样且都是1</li>
<li><code>keepAliveTime</code>为0</li>
<li>阻塞队列是<code>LinkedBlockingQueue</code></li>
</ul>
<p><strong>该线程池的工作机制是：</strong></p>
<ol>
<li>线程池中没有线程时，新建一个线程执行任务</li>
<li>有一个线程以后，将任务加入阻塞队列，不停加加加</li>
<li>唯一的这一个线程不停地去队列里取任务执行</li>
</ol>
<p><strong>适用场景：</strong></p>
<p><code>SingleThreadExecutor</code>适用于串行执行任务的场景，每个任务必须按顺序执行，不需要并发执行。</p>
<h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>线程池特点：</strong></p>
<ul>
<li>核心线程数为0，且最大线程数为<code>Integer.MAX_VALUE</code></li>
<li>阻塞队列是<code>SynchronousQueue</code></li>
</ul>
<p>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQueue</code></p>
<p>锁当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p>
<p><strong>该线程池的工作机制是：</strong></p>
<ol>
<li>没有核心线程，直接向<code>SynchronousQueue</code>中提交任务</li>
<li>如果有空闲线程，就去取出任务执行；如果没有空闲线程，就新建一个</li>
<li>执行完任务的线程有60秒生存时间，如果在这个时间内可以接到新任务，就可以继续活下去，否则就拜拜</li>
</ol>
<p><strong>适用场景：</strong></p>
<p><code>CachedThreadPool</code> 用于并发执行大量短期的小任务。</p>
<h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</div><div class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</div><div class="line">          <span class="keyword">new</span> DelayedWorkQueue());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_KEEPALIVE_MILLIS = <span class="number">10L</span>;</div></pre></td></tr></table></figure>
<p><strong>线程池特点：</strong></p>
<ul>
<li>最大线程数为<code>Integer.MAX_VALUE</code></li>
<li>阻塞队列是<code>DelayedWorkQueue</code></li>
</ul>
<p>ScheduledThreadPoolExecutor 添加任务提供了另外两个方法：</p>
<ul>
<li>scheduleAtFixedRate() ：按某种速率周期执行</li>
<li>scheduleWithFixedDelay()：在某个延迟后执行</li>
</ul>
<p>两种方法的内部实现都是创建了一个<code>ScheduledFutureTask</code>对象封装了任务的延迟执行时间及执行周期，并调用<code>decorateTask()</code>方法转成<code>RunnableScheduledFuture</code>对象，然后添加到延迟队列中。</p>
<p>DelayQueue：中封装了一个优先级队列，这个队列会对队列中的<code>ScheduledFutureTask</code> 进行排序，两个任务的执行 time 不同时，time 小的先执行；否则比较添加到队列中的<code>ScheduledFutureTask</code>的顺序号 <code>sequenceNumber</code> ，先提交的先执行。</p>
<p><strong>该线程池的工作机制是：</strong></p>
<ol>
<li>调用上面两个方法添加一个任务</li>
<li>线程池中的线程从 DelayQueue 中取任务</li>
<li>然后执行任务</li>
</ol>
<p>具体执行步骤：</p>
<ol>
<li>线程从 DelayQueue 中获取 time 大于等于当前时间的 <code>ScheduledFutureTask</code><ol>
<li><code>DelayQueue.take()</code></li>
</ol>
</li>
<li>执行完后修改这个 task 的 time 为下次被执行的时间</li>
<li>然后再把这个 task 放回队列中 <ol>
<li><code>DelayQueue.add()</code></li>
</ol>
</li>
</ol>
<p><strong>适用场景：</strong></p>
<p><code>ScheduledThreadPoolExecutor</code>用于需要多个后台线程执行周期任务，同时需要限制线程数量的场景。</p>
<h1 id="3-线程池有哪几种工作队列"><a href="#3-线程池有哪几种工作队列" class="headerlink" title="3. 线程池有哪几种工作队列"></a>3. 线程池有哪几种工作队列</h1><ul>
<li>ArrayBlockingQueue （有界队列）：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li>
<li>LinkedBlockingQueue （无界队列）：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue（同步队列）: 一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>DelayQueue（延迟队列）：一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。</li>
<li>PriorityBlockingQueue（优先级队列）: 一个具有优先级得无限阻塞队列。</li>
</ul>
<h1 id="4-怎么理解无界队列和有界队列"><a href="#4-怎么理解无界队列和有界队列" class="headerlink" title="4. 怎么理解无界队列和有界队列"></a>4. 怎么理解无界队列和有界队列</h1><ul>
<li>有界队列即长度有限，满了以后ArrayBlockingQueue会插入阻塞。</li>
<li>无界队列就是里面能放无数的东西而不会因为队列长度限制被阻塞，但是可能会出现OOM异常。</li>
</ul>
<h1 id="5-线程池中的几种重要的参数及流程"><a href="#5-线程池中的几种重要的参数及流程" class="headerlink" title="5. 线程池中的几种重要的参数及流程"></a>5. 线程池中的几种重要的参数及流程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                          <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                          <span class="keyword">long</span> keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory,</div><div class="line">                          RejectedExecutionHandler handler) &#123;</div><div class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt; corePoolSize ||</div><div class="line">        keepAliveTime &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">    <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>corePoolSize</code>：核心池的大小，在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中</li>
<li><code>maximumPoolSize</code>：线程池最大线程数最大线程数</li>
<li><code>keepAliveTime</code>：表示线程没有任务执行时最多保持多久时间会终止</li>
<li><code>unit</code>：参数keepAliveTime的时间单位TimeUtil类的枚举类（DAYS、HOURS、MINUTES、SECONDS 等）</li>
<li><code>workQueue</code>：阻塞队列，用来存储等待执行的任务</li>
<li><code>threadFactory</code>：线程工厂，主要用来创建线程</li>
<li><code>handler</code>：拒绝处理任务的策略<ul>
<li><code>AbortPolicy</code>：丢弃任务并抛出 RejectedExecutionException 异常。（默认这种）</li>
<li><code>DiscardPolicy</code>：也是丢弃任务，但是不抛出异常</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>
<li><code>CallerRunsPolicy</code>：由调用线程处理该任务</li>
</ul>
</li>
</ul>
<p><img src="http://ohfk1r827.bkt.clouddn.com/Rejected-method-Thread-Pool.jpg" alt=""></p>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ol>
<li>当有任务进入时，线程池创建线程去执行任务，直到核心线程数满为止</li>
<li>核心线程数量满了之后，任务就会进入一个缓冲的任务队列中<ol>
<li>当任务队列为无界队列时，任务就会一直放入缓冲的任务队列中，不会和最大线程数量进行比较</li>
<li>当任务队列为有界队列时，任务先放入缓冲的任务队列中，当任务队列满了之后，才会将任务放入线程池，此时会拿当前线程数与线程池允许的最大线程数进行比较，如果超出了，则默认会抛出异常。如果没超出，然后线程池才会创建线程并执行任务，当任务执行完，又会将缓冲队列中的任务放入线程池中，然后重复此操作。</li>
</ol>
</li>
</ol>
<h1 id="6-单机上一个线程正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）"><a href="#6-单机上一个线程正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）" class="headerlink" title="6. 单机上一个线程正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）"></a>6. 单机上一个线程正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）</h1><p>经过网上查阅，发现基本是没有一个明确的回答的。不过思考过后一番，我感觉实现思路和MySQL的redo，undo功能很相似，我们可以对正在处理和阻塞队列的任务做事物管理或者对阻塞队列中的任务持久化处理，并且当断电或者系统崩溃，操作无法继续下去的时候，可以通过回溯日志的方式来撤销<code>正在处理的</code>已经执行成功的操作。然后重新执行整个阻塞队列。</p>
<p>即：</p>
<p>阻塞队列持久化，正在处理事物控制。断电之后正在处理的回滚，日志恢复该次操作。服务器重启后阻塞队列中的数据再加载</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.54tianzhisheng.cn/2017/07/29/ThreadPool/#%E7%BA%BF%E7%A8%8B%E6%B1%A0" target="_blank" rel="external">http://www.54tianzhisheng.cn/2017/07/29/ThreadPool/#%E7%BA%BF%E7%A8%8B%E6%B1%A0</a></li>
<li><a href="http://ifeve.com/java-threadpool/" target="_blank" rel="external">http://ifeve.com/java-threadpool/</a></li>
<li><a href="https://blog.csdn.net/qq_38283430/article/details/80193235" target="_blank" rel="external">https://blog.csdn.net/qq_38283430/article/details/80193235</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单机上一个线程正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）&lt;/li&gt;
&lt;li&gt;为什么要使用线程池，线程池用什么用&lt;/li&gt;
&lt;li&gt;说说几种常见的线程池及使用场景&lt;/li&gt;
&lt;li&gt;线程池有哪几种工作队列&lt;/li&gt;
&lt;li&gt;怎么理解无界队列和有界队列&lt;/li&gt;
&lt;li&gt;线程池中的几种重要的参数及流程&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="并发" scheme="http://www.jiyongguang.xin/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="http://www.jiyongguang.xin/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal 深入剖析</title>
    <link href="http://www.jiyongguang.xin/java-threadLocal.html"/>
    <id>http://www.jiyongguang.xin/java-threadLocal.html</id>
    <published>2018-10-11T08:56:52.000Z</published>
    <updated>2018-10-11T08:59:25.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图解ThreadLocal"><a href="#图解ThreadLocal" class="headerlink" title="图解ThreadLocal"></a>图解ThreadLocal</h1><p><img src="http://otsgsfu16.bkt.clouddn.com/18-7-5/18524084.jpg" alt=""></p>
<a id="more"></a>
<h1 id="ThreadLocalMap-Entry的弱引用"><a href="#ThreadLocalMap-Entry的弱引用" class="headerlink" title="ThreadLocalMap.Entry的弱引用"></a>ThreadLocalMap.Entry的弱引用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * The entries in this hash map extend WeakReference, using</div><div class="line">         * its main ref field as the key (which is always a</div><div class="line">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</div><div class="line">         * == null) mean that the key is no longer referenced, so the</div><div class="line">         * entry can be expunged from table.  Such entries are referred to</div><div class="line">         * as "stale entries" in the code that follows.</div><div class="line">         */</div><div class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</div><div class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></div><div class="line">            Object value;</div><div class="line"></div><div class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">                <span class="keyword">super</span>(k);</div><div class="line">                value = v;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>弱引用作为Entry的key在这里的作用：</p>
<p>当程序中再没有对该ThreadLocal的强引用时，各线程的ThreadLocalMap中Entry的key为该ThreadLocal，他们的key值都会变成null。该ThreadLocal对象会被GC回收。算是ThreadLocalMap考虑周全，怕我们忘记删吧，我能想到的优点 ……</p>
<h1 id="对ThreadLocal的理解"><a href="#对ThreadLocal的理解" class="headerlink" title="对ThreadLocal的理解"></a>对ThreadLocal的理解</h1><p>　　ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。
　　</p>
<blockquote>
<p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p>
</blockquote>
<p>　　这句话从字面上看起来很容易理解，但是真正理解并不是那么容易。</p>
<p>　　我们还是先来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connect = <span class="keyword">null</span>;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(connect == <span class="keyword">null</span>)&#123;</div><div class="line">            connect = DriverManager.getConnection();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> connect;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(connect!=<span class="keyword">null</span>)</div><div class="line">            connect.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设有这样一个数据库链接管理类，这段代码在单线程中使用是没有任何问题的，但是如果在多线程中使用呢？很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。</p>
<p>所以出于线程安全的考虑，必须将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理。</p>
<p>这样将会大大影响程序执行效率，因为一个线程在使用connect进行数据库操作的时候，其他线程只有等待。</p>
<p>那么大家来仔细分析一下这个问题，<strong>这地方到底需不需要将connect变量进行共享?</strong> 
　　</p>
<p>事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，<strong>即一个线程不需要关心其他线程是否对这个connect进行了修改的。</strong></p>
<p>　　到这里，可能会有朋友想到，既然不需要在线程之间共享这个变量，可以直接这样处理，在每个需要使用数据库连接的方法中具体使用时才创建数据库链接，然后在方法调用完毕再释放这个连接。比如下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</div><div class="line">     </div><div class="line">    <span class="keyword">private</span>  Connection connect = <span class="keyword">null</span>;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(connect == <span class="keyword">null</span>)&#123;</div><div class="line">            connect = DriverManager.getConnection();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> connect;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(connect!=<span class="keyword">null</span>)</div><div class="line">            connect.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dao</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</div><div class="line">        ConnectionManager connectionManager = <span class="keyword">new</span> ConnectionManager();</div><div class="line">        Connection connection = connectionManager.openConnection();</div><div class="line">         </div><div class="line">        <span class="comment">//使用connection进行操作</span></div><div class="line">         </div><div class="line">        connectionManager.closeConnection();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 　　这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不尽严重影响程序执行效率，还可能导致服务器压力巨大。</p>
<p>　　那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。</p>
<p>　　但是要注意，虽然ThreadLocal能够解决上面说的问题，但是<strong>由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</strong></p>
<h1 id="深入解析ThreadLocal类"><a href="#深入解析ThreadLocal类" class="headerlink" title="深入解析ThreadLocal类"></a>深入解析ThreadLocal类</h1><p>　　在上面谈到了对ThreadLocal的一些理解，那我们下面来看一下具体ThreadLocal是如何实现的。</p>
<p>　　先了解一下ThreadLocal类提供的几个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123; &#125;</div></pre></td></tr></table></figure></p>
<p> 　　get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法，下面会详细说明。</p>
<p>　　首先我们来看一下ThreadLocal类是如何为每个线程创建一个变量的副本的。</p>
<p>　　先看下get方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            T result = (T)e.value;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 　　第一句是取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到<code>&lt;key,value&gt;</code>键值对，<strong>注意这里获取键值对传进去的是  this，而不是当前线程t。</strong></p>
<p>　　如果获取成功，则返回value值。</p>
<p>　　如果map为空，则调用setInitialValue方法返回value。</p>
<p>　　我们上面的每一句来仔细分析：</p>
<p>　　首先看一下getMap方法中做了什么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　可能大家没有想到的是，在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。</p>
<p>　　那么我们继续取Thread类中取看一下成员变量threadLocals是什么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line">     * by the ThreadLocal class. */</div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure></p>
<hr>
<p>　　实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们继续取看ThreadLocalMap的实现：<br>　　<br>关于弱引用WeakReference的学习可参考：<a href="https://www.cnblogs.com/absfree/p/5555687.html" target="_blank" rel="external">理解Java中的弱引用（Weak Reference）</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The entries in this hash map extend WeakReference, using</div><div class="line">     * its main ref field as the key (which is always a</div><div class="line">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</div><div class="line">     * == null) mean that the key is no longer referenced, so the</div><div class="line">     * entry can be expunged from table.  Such entries are referred to</div><div class="line">     * as "stale entries" in the code that follows.</div><div class="line">     */</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</div><div class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></div><div class="line">        Object value;</div><div class="line"></div><div class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">            <span class="keyword">super</span>(k);</div><div class="line">            value = v;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ····</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到ThreadLocalMap的Entry继承了弱引用WeakReference，而WeakReference的泛型也指向了Entry中的键值ThreadLocal。也就是说<strong>ThreadLocalMap是使用ThreadLocal的弱引用作为key的</strong>，它这么设计的原因也是为了方便它的键值ThreadLocal在外部没有强引用引用的情况下进行内存的释放。</p>
<p>下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：</p>
<p><img src="https://pic1.zhimg.com/80/9671b789e1da4f760483456c03e4f4b6_hd.jpg" alt=""></p>
<p>然后网上就传言，ThreadLocal会引发内存泄露，他们的理由是这样的：</p>
<p>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，<strong>如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，</strong> 这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p>
<p>ThreadLocal Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p>
<p>永远无法回收，造成内存泄露。</p>
<p>我们来看看到底会不会出现这种情况。 其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</div><div class="line">    Entry e = table[i]; <span class="comment">// Entry 继承 WeakReference</span></div><div class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key) <span class="comment">// e.get()拿出的是WeakReferencere的referent即 ThreadLocal</span></div><div class="line">        <span class="keyword">return</span> e;<span class="comment">// 如果桶不为空 &amp; 且元素刚好是此ThreadLocal</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getEntryAfterMiss函数的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        <span class="keyword">if</span> (k == key)</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) <span class="comment">// 如果从桶中取出的Entry的 key==null</span></div><div class="line">            expungeStaleEntry(i);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            i = nextIndex(i, len); <span class="comment">// 类似HsahMap中取桶中的链表的下一元素</span></div><div class="line">        e = tab[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>expungeStaleEntry函数的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 删除陈旧条目</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</div><div class="line">Entry[] tab = table;</div><div class="line"><span class="keyword">int</span> len = tab.length;</div><div class="line"></div><div class="line"><span class="comment">// expunge entry at staleSlot</span></div><div class="line">tab[staleSlot].value = <span class="keyword">null</span>;</div><div class="line">tab[staleSlot] = <span class="keyword">null</span>;</div><div class="line">size--;</div><div class="line"></div><div class="line"><span class="comment">// 接着处理此table之后 的桶中key为null的Entry</span></div><div class="line"><span class="comment">// Rehash until we encounter null</span></div><div class="line">Entry e;</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">for</span> (i = nextIndex(staleSlot, len);</div><div class="line">     (e = tab[i]) != <span class="keyword">null</span>;</div><div class="line">     i = nextIndex(i, len)) &#123;</div><div class="line">    ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">        e.value = <span class="keyword">null</span>;</div><div class="line">        tab[i] = <span class="keyword">null</span>;</div><div class="line">        size--;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (h != i) &#123;</div><div class="line">            tab[i] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></div><div class="line">            <span class="comment">// null because multiple entries could have been stale.</span></div><div class="line">            <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</div><div class="line">                h = nextIndex(h, len);</div><div class="line">            tab[h] = e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整理一下ThreadLocalMap的getEntry函数的流程：</p>
<ol>
<li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；</li>
<li>如果散列到的Entry为null或者key不一致则向table数组的下一个位置查询。如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry。如果不等，如果key值为null，则擦除该位置的Entry，然后继续向table后续的位置查询该Entry，直到table到头。</li>
</ol>
<p><strong>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。</strong> 仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。</p>
<p><strong>需要注意的是：</strong></p>
<p>虽然ThreadLocalMap内部有对这样的 Key为null的Entry的处理机制，但是光这样还是不够的，<strong>上面的设计思路依赖一个前提条件：要调用ThreadLocalMap的genEntry函数或者set函数。</strong> 这当然是不可能任何情况都成立的，<strong>所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除当前线程不再需要的ThreadLocal，防止内存泄露。</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</div><div class="line">     <span class="keyword">if</span> (m != <span class="keyword">null</span>)</div><div class="line">         m.remove(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当前线程调用一下ThreadLocal的remove函数即可删除该线程的ThreadLocalMap中的该不用的ThreadLocal变量了。</p>
<p>所以JDK<strong>建议</strong>将ThreadLocal变量定义成<code>private static</code>的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，就不会出现key为null的Entry了。也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，当我们某个线程不需要该ThreadLocal变量的时候也可以手动的remove它，方便可控且防止内存泄露(针对Value)。</p>
<p><strong>参考</strong>：<a href="https://www.zhihu.com/question/23089780/answer/62097840" target="_blank" rel="external">ThreadLocal和synchronized的区别?</a></p>
<hr>
<p>然后再继续看setInitialValue方法的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    T value = initialValue();</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　很容易了解，就是如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　至此，可能大部分朋友已经明白了ThreadLocal是如何为每个线程创建变量的副本的：</p>
<p>　　首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p>
<p>　　初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p>
<p>　　然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
<p>　　下面通过一个例子来证明通过ThreadLocal能达到在每个线程中创建变量副本的效果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    ThreadLocal&lt;Long&gt; longLocal = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;();</div><div class="line">    ThreadLocal&lt;String&gt; stringLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</div><div class="line"> </div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</div><div class="line">        longLocal.set(Thread.currentThread().getId());</div><div class="line">        stringLocal.set(Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> longLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stringLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">         </div><div class="line">         </div><div class="line">        test.set();</div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">     </div><div class="line">         </div><div class="line">        Thread thread1 = <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                test.set();</div><div class="line">                System.out.println(test.getLong());</div><div class="line">                System.out.println(test.getString());</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">        thread1.start();</div><div class="line">        thread1.join();</div><div class="line">         </div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码的输出结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line">main</div><div class="line"><span class="number">8</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line">main</div></pre></td></tr></table></figure></p>
<p>　　从这段代码的输出结果可以看出，在main线程中和thread1线程中，longLocal保存的副本值和stringLocal保存的副本值都不一样。最后一次在main线程再次打印副本值是为了证明在main线程中和thread1线程中的副本值确实是不同的。</p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><ol>
<li>实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；</li>
<li>为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；</li>
<li>在进行get之前，必须先set，否则通过ThreadLoca的get函数取出的值为null(默认<code>initValue()</code>函数的结果)。<ul>
<li><strong>如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。</strong> 因为在上面的代码分析过程中，我们发现如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            T result = (T)e.value;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    T value = initialValue();</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看下面这个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    ThreadLocal&lt;Long&gt; longLocal = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;();</div><div class="line">    ThreadLocal&lt;String&gt; stringLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</div><div class="line">        longLocal.set(Thread.currentThread().getId());</div><div class="line">        stringLocal.set(Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> longLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stringLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">         </div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">    </div><div class="line">        Thread thread1 = <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                test.set();</div><div class="line">                System.out.println(test.getLong());</div><div class="line">                System.out.println(test.getString());</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">        thread1.start();</div><div class="line">        thread1.join();</div><div class="line">         </div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">    &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在main线程中，没有先set，直接get的话，运行时会报空指针异常。</p>
<p>　　但是如果改成下面这段代码，即重写了initialValue方法：<br>　　<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    ThreadLocal&lt;Long&gt; longLocal = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;()&#123;</div><div class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Thread.currentThread().getId();</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    ThreadLocal&lt;String&gt; stringLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;()&#123;;</div><div class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Thread.currentThread().getName();</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</div><div class="line">        longLocal.set(Thread.currentThread().getId());</div><div class="line">        stringLocal.set(Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> longLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stringLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line"> </div><div class="line">        test.set();</div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">     </div><div class="line">         </div><div class="line">        Thread thread1 = <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                test.set();</div><div class="line">                System.out.println(test.getLong());</div><div class="line">                System.out.println(test.getString());</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">        thread1.start();</div><div class="line">        thread1.join();</div><div class="line">         </div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　就可以直接不用先set而直接调用get了。
　</p>
<h1 id="ThreadLocal的应用场景"><a href="#ThreadLocal的应用场景" class="headerlink" title="ThreadLocal的应用场景"></a>ThreadLocal的应用场景</h1><p>　　最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。<br>　　<br>　　如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> connectionHolder.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　下面这段代码摘自：</p>
<p>　　<a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">正确理解ThreadLocal</a><br>　　<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</div><div class="line">    Session s = (Session) threadSession.get();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</div><div class="line">            s = getSessionFactory().openSession();</div><div class="line">            threadSession.set(s);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出每个线程操控属于自己的一个Session。</p>
<h1 id="关于ThreadLocal在exchange中的用法"><a href="#关于ThreadLocal在exchange中的用法" class="headerlink" title="关于ThreadLocal在exchange中的用法"></a>关于ThreadLocal在exchange中的用法</h1><p>当某个线程被程序分配到执行某个用户的请求时，由于对于每次来请求的用户的身份未知，所以为了该线程所处理的函数间用户身份信息的传递确认，会用ThreadLocal来存储用户信息。这里ThreadLocal的作用也就是相当于<strong>方便函数间参数传递的工具</strong> exchange项目的代码中做的处理就是每个请求过来先走PassportInterceptor来确认用户身份并且绑定到Hostholder中 这样无论程序分配的是哪个线程来处理用户的请求 函数间传递的都是该身份的用户不会出错。并且由于每个请求都走该拦截器，所以用户每次过来当前线程的ThreadLocal对应的对象都是当前用户会替换掉之前存储在其中的用户。</p>
<h1 id="ThreadLocal与Synchonized的对照"><a href="#ThreadLocal与Synchonized的对照" class="headerlink" title="ThreadLocal与Synchonized的对照"></a>ThreadLocal与Synchonized的对照</h1><p>ThreadLocal和Synchonized都用于解决多线程并发訪问。可是ThreadLocal与synchronized有本质的差别。synchronized是利用锁的机制，使变量或代码块在某一时该仅仅能被一个线程訪问。而ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时可以获得数据共享。</p>
<p>Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ThreadLocal这个类它是作为在多线程并发环境下，为每个线程划分属于自己的变量而存在的一个类。从如下的函数Api也可以很清楚的看出这一点。</p>
<p>ThreadLocal：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);<span class="comment">// 这里的this指针指的是该类中的ThreadLocal变量</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">	<span class="comment">// 根据ThreadLocal的引用来获取其对应的Entry</span></div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            T result = (T)e.value;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Thread：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line"> * by the ThreadLocal class. */</div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure></p>
<p>我们一般用它作用在多线程情况下的并发访问上，同一线程的职责内，不同方法间调用时，在保证各线程私有的参数的传递上时使用。如下例：</p>
<p>Controller：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> ServerResponse&lt;PageInfo&gt; <span class="title">getConversationsWithTourists</span><span class="params">(</span></span></div><div class="line">@RequestParam(value=<span class="string">"pageNum"</span>,defaultValue=<span class="string">"0"</span>)IntegerpageNum,                                                       @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"pageSize"</span>, defaultValue =<span class="string">"10"</span>)</span> Integer pageSize) &#123;</div><div class="line">           <span class="keyword">int</span> localUserId = hostHolder.getUser().getId();</div><div class="line">           <span class="keyword">return</span> iMessageService.getConversationWithTouristsList(localUserId, pageNum, pageSize);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>PassportInterceptor：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object</span></span></div><div class="line">           o) <span class="keyword">throws</span> Exception &#123;</div><div class="line">       String ticket = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">if</span> (httpServletRequest.getCookies() != <span class="keyword">null</span>) &#123;</div><div class="line">           Cookie[] cookies = httpServletRequest.getCookies();</div><div class="line">           <span class="keyword">for</span> (Cookie cookieItem : cookies) &#123;<span class="comment">// 找T票</span></div><div class="line">               <span class="keyword">if</span> (cookieItem.getName().equals(<span class="string">"ticket"</span>)) &#123;</div><div class="line">                   ticket = cookieItem.getValue();</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (ticket != <span class="keyword">null</span>) &#123;</div><div class="line">           LoginTicket loginTicket = iLoginTicketService.getLoginTicketByTicket(ticket);</div><div class="line">           <span class="keyword">if</span> (loginTicket == <span class="keyword">null</span> || loginTicket.getExpired().before(<span class="keyword">new</span> DateTime().toDate())</div><div class="line">                   || loginTicket.getStatus().intValue() == Const.TicketStatus.LOG_OUT) &#123;<span class="comment">// T票无效</span></div><div class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// 放行去生成T票</span></div><div class="line">           &#125;</div><div class="line">           <span class="comment">//  T票有效</span></div><div class="line">           User user = iUserService.getUserById(loginTicket.getUserId()).getData();</div><div class="line">           <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</div><div class="line">               hostHolder.setUser(user);<span class="comment">// 同一Thread重置对象</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>还需要注意的就是，对于成员变量(线程共享的变量)，如果存到ThreadLocal中是没有意义的，仍旧会触发多线程间并发修改的问题。因为这些变量是线程间共享变量。我们一般使用ThreadLocal来存储每个Thread实例对应的一个对象的访问，就比如上例中对于访问Controller中的User对象的存储。显然Interceptor中set到ThreadLocal中的User对象是局部变量，每个线程被Tomcat用来处理一个请求，所以每个用户是每个线程的私有变量，所以不存在并发修改的问题。并且可以根据ThreadLocal的机制保证各线程走到这里被分发到了属于自己的User对象，进而ThreadLocal会将该User与自己绑成K-V对，存储到当前分配到处理的Thread的ThreadLocalMap中。从此该User就和该Thread对象绑定。</p>
<p>我们一般就通过这样的方式来简化某个线程私有对象在一个线程处理职责内，被应用的函数多处调用时参数的传递问题，可以简化函数的签名，因为如果每个地方使用时该变量都需要传一下的话就太麻烦了。这样就比较简洁了。</p>
<h1 id="使用ThreadLocal需要注意的点"><a href="#使用ThreadLocal需要注意的点" class="headerlink" title="使用ThreadLocal需要注意的点"></a>使用ThreadLocal需要注意的点</h1><ul>
<li><p>它一般都是<code>private static</code>的</p>
</li>
<li><p>由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p>
</li>
<li><p>由于ThreadLocalMap中的Entry的key是ThreadLocal，Entry继承了WeakReference类且referent是ThreadLocal。所以很多时候可能Entry中的key，ThreadLocal会变成null值，而ThreadLocal内部虽然也对这种key为null的Entry做了处理。但也要调用ThreadLocalMap的genEntry函数或者set函数。 这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。</p>
</li>
</ul>
<h1 id="学习时必看的另两篇文章"><a href="#学习时必看的另两篇文章" class="headerlink" title="学习时必看的另两篇文章"></a>学习时必看的另两篇文章</h1><ul>
<li><a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">正确理解ThreadLocal</a></li>
<li><a href="https://www.cnblogs.com/yxysuanfa/p/7125761.html" target="_blank" rel="external">java ThreadLocal(应用场景及使用方式及原理)</a></li>
<li><a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="external">Java进阶（七）正确理解Thread Local的原理与适用场景</a></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>参考资料：</p>
<ul>
<li>《深入理解Java虚拟机》</li>
<li>《Java编程思想》</li>
<li><a href="http://ifeve.com/thread-management-10/" target="_blank" rel="external">http://ifeve.com/thread-management-10/</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-threads/index3.html" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-threads/index3.html</a></li>
<li><a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">http://www.iteye.com/topic/103804</a></li>
<li><a href="http://www.iteye.com/topic/777716" target="_blank" rel="external">http://www.iteye.com/topic/777716</a></li>
<li><a href="http://www.iteye.com/topic/757478" target="_blank" rel="external">http://www.iteye.com/topic/757478</a></li>
<li><a href="http://blog.csdn.net/ghsau/article/details/15732053" target="_blank" rel="external">http://blog.csdn.net/ghsau/article/details/15732053</a></li>
<li><a href="http://ispring.iteye.com/blog/162982" target="_blank" rel="external">http://ispring.iteye.com/blog/162982</a></li>
<li><a href="http://blog.csdn.net/imzoer/article/details/8262101" target="_blank" rel="external">http://blog.csdn.net/imzoer/article/details/8262101</a></li>
<li><a href="http://www.blogjava.net/wumi9527/archive/2010/09/10/331654.html" target="_blank" rel="external">http://www.blogjava.net/wumi9527/archive/2010/09/10/331654.html</a></li>
<li><a href="http://bbs.csdn.net/topics/380049261" target="_blank" rel="external">http://bbs.csdn.net/topics/380049261</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图解ThreadLocal&quot;&gt;&lt;a href=&quot;#图解ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;图解ThreadLocal&quot;&gt;&lt;/a&gt;图解ThreadLocal&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://otsgsfu16.bkt.clouddn.com/18-7-5/18524084.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://www.jiyongguang.xin/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="http://www.jiyongguang.xin/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于锁的面试题</title>
    <link href="http://www.jiyongguang.xin/java-lock.html"/>
    <id>http://www.jiyongguang.xin/java-lock.html</id>
    <published>2018-10-11T08:53:32.000Z</published>
    <updated>2018-10-11T08:55:41.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><p>synchronized关键字，实现原理（和Lock对比着说，说到各自的优缺点，synchronized从最初性能差到jdk高版本后的锁膨胀机制，大大提高性能，再说底层实现，Lock的乐观锁机制，通过AQS队列同步器，调用了unsafe的CAS操作，CAS函数的参数及意义；同时可以说说synchronized底层原理，jvm层的moniter监视器，对于方法级和代码块级，互斥原理的不同，+1-1可重入的原理等）    </p>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h2><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个线程可以执行该方法或代码块，同时它还可以保证对共享变量操作的内存可见性。</p>
<a id="more"></a>
<h2 id="实现同步的方式"><a href="#实现同步的方式" class="headerlink" title="实现同步的方式"></a>实现同步的方式</h2><p>synchronized实现同步的方式一般有3种，普通同步方法、静态同步方法、同步代码块，分别锁的是当前实例对象，类对象，synchronized括号中修饰的类或对象。</p>
<p>由于Java保证任何一个对象都有其对应的monitor，或者说管程对象存在。对于synchronized修饰的方法或代码块JVM本质上都是通过获取，释放monitor对象来对方法，同步块进行同步的。</p>
<p><strong>同步代码块：</strong> 具体实现规则又有所不同，同步代码块是在代码块前插入一条monitor.enter指令，代码块的退出位置再插入一条monitor.exit指令。以及插入的一条，异常结束时供异常处理器调用的monitor.exit指令。</p>
<p><strong>同步方法：</strong> 方法级的同步是隐式的，并不需要像同步代码块一样通过字节码指令来控制。它在方法调用和返回操作的时候，JVM可以从方法常量池中的方法表结构中的<code>ACC_SYNCHRONIZED</code>访问标志来区分一个方法是否同步方法。当方法调用时，调用指令将会检查方法的 <code>ACC_SYNCHRONIZED</code> 访问标志是否被设置，如果设置了，执行线程将先持有monitor，执行结束或异常终止则会释放monitor。</p>
<h2 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h2><p>在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的<code>Mutex Lock</code>来实现的，而操作系统实现线程之间的切换时需要从<strong>用户态转换到核心态</strong>，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，所以这也就是synchronized效率低下的原因。而在jdk1.6的时候Java也对该弊端进行了改进，为了减少获取锁和释放锁锁带来的性能上的损耗引入了偏向锁和轻量锁。</p>
<p>Java锁一共四种状态，无锁，偏向，轻量，重量。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的核心思想：不存在多线程竞争，并且应由一个线程多次获得锁。</p>
<p><strong>获取锁</strong><br>当线程访问同步块时，会使用 CAS 将线程 ID 更新到锁对象头文件的 Mark Word 标志字段中，如果更新成功则获得偏向锁，并且之后该线程每次进入这个对象锁相关的同步块时都不需要再次获取锁了。</p>
<p><strong>释放锁</strong></p>
<p>由于线程释放锁只有竞争才会释放，所以对于偏向锁线程是不会主动释放锁的，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。暂停当前线程，判断对象是否处于被锁定的状态，撤销偏向锁，恢复到无锁态或轻量锁态。</p>
<h3 id="轻量锁"><a href="#轻量锁" class="headerlink" title="轻量锁"></a>轻量锁</h3><p>轻量锁的核心思想：对于绝大部分的锁，在整个生命周期内都是不会存在竞争的。没有<strong>多线程竞争</strong>的前提下，减少传统的重量级锁的使用，及操作系统互斥量产生的性能消耗。</p>
<p><strong>获取锁</strong></p>
<p>根据当前对象头的Mark Word标志词中的锁标记为来判断当前对象的锁状态是否处于无锁状态，若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态</p>
<p><strong>释放锁</strong></p>
<p>轻量级锁的释放也是通过CAS操作来进行的，取出在获取轻量级锁保存在Displaced Mark Word中的数据，用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功。如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</p>
<h3 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h3><p>防止线程切换的损耗，某个线程在被强占cpu时间片后进入阻塞状态并后续唤醒是十分不值得的，所以让该线程自旋等待一段时间。jdk1.6后引入了适应性自旋锁，通过每次自旋并实时的监控上传自旋的状态来决定自旋的次数。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>即JVM会通过变量逃逸机制来判断，当前操作的变量是否是栈封闭的环境中运行，如果是，那么它便会大胆的对一些通过加锁机制来保证并发安全的变量进行去锁操作。比如栈封闭情况下的StringBuffer和Vector等。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。 但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。 </p>
<p>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</div><div class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</div><div class="line">        vector.add(i + <span class="string">""</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    System.out.println(vector);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>Java对象头和Monitor是synchronized实现同步的机制。Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。</p>
<p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-9-5/3792646.jpg" alt=""></p>
<p>锁标志状态图</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-9-5/59133820.jpg" alt=""></p>
<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>每一个被锁住的对象都会和一个monitor关联。在JVM层面monitor是由C++中的ObjectMonitor对象来实现的。</p>
<p>Monitor对象的结构图：</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-9-5/77145989.jpg" alt=""></p>
<ul>
<li>Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL； </li>
<li>EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。 </li>
<li>RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。 </li>
<li>Nest:用来实现重入锁的计数。 </li>
<li>HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。 </li>
<li>Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。 </li>
</ul>
<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><ul>
<li>Lock提供了比使用synchronized方法和语句更广泛的锁定操作。支持中断、超时不获取、是非阻塞的</li>
<li>提高了语义化，哪里加锁，哪里解锁都得写出来</li>
<li>Lock显式锁可以给我们带来很好的灵活性，不需要像synchronized一样锁的获取和释放要在同一个函数体或代码块内。不需要像synchronized一样反向释放锁，但同时我们必须手动释放锁</li>
<li>支持多个相关的 Condition 对象</li>
<li>允许多个读线程同时访问共享资源</li>
</ul>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><ul>
<li>为实现阻塞锁和相关同步器和其他同步组件提供的一个基础框架，它依赖于先进先出队列等待队列</li>
<li>并依靠单个原子int值来表示状态。</li>
</ul>
<p>当state=0时，则说明没有任何线程占有共享资源的锁，当state=1时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待，AQS内部通过内部类Node构成FIFO的同步队列来完成线程获取锁的排队工作，同时利用内部类ConditionObject构建等待队列。所以说AQS是有两种多个等待队列的。</p>
<p>AQS作为基础组件，对于锁的实现存在两种不同的模式，即共享模式(如Semaphore)和独占模式(如ReetrantLock)</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-9-5/12503911.jpg" alt=""></p>
<p>而相应的tryRelease方法公平锁和非公平锁则是通用的Sync类的tryRelease函数，它重写了AQS的tryRelease函数。tryRelease函数主要是对当前锁的同步队列的State的值进行更改。使其的状态值State-1。同时release函数在tryRelease函数返回值为true的时候，当队列中还有元素的时候，选择去唤醒头元素的后继元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//标识线程已处于结束状态</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</div><div class="line">  <span class="comment">//等待被唤醒状态</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</div><div class="line">  <span class="comment">//条件状态，</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</div><div class="line">  <span class="comment">//在共享模式中使用表示获得的同步状态会被传播</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</div></pre></td></tr></table></figure></p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/panweiwei1994/article/details/78769703" target="_blank" rel="external">Java并发编程札记-(四)JUC锁-03AQS</a></li>
<li><a href="https://blog.csdn.net/javazejian/article/details/75043422" target="_blank" rel="external">深入剖析基于并发AQS的(独占锁)重入锁(ReetrantLock)及其Condition实现原理</a></li>
</ul>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock底层是依赖CAS方法和volatile变量来实现同步的，并且还依赖于一些LockSupport类的方法。</p>
<p>重入锁的静态内部类Sync实现自抽象类AQS，依赖于AQS的同步队列及int类型的值来保证同步。Sync内部类又分为公平的和不公平的，公平是指，等待时间最长的线程优先获得锁。保证公平会影响性能，线程会严格按照先进先出的方式来获取锁。一般也不需要，所以默认不保证，而不公平则是保证每次调用lock函数获取锁的时候，都会尝试先通过CAS的方式获取一次锁(修改一次该独占锁的State数值，及设置该独占锁的Owner线程)，获取不到才去同步队列中等待。synchronized锁也是不保证公平的。</p>
<p>公平锁和非公平锁都重写了AQS的lock和tryAcquire函数。区别是，lock函数非公平锁比公平锁多通过CAS尝试获取一次锁，获取不到才会调用AQS类的acquire函数来处理。而公平锁不同的测试会在调用tryAccquire函数中通过调用hasQueuedPredecessors函数来检测当前队列中有节点，且头节点的后继节点非该线程节点的话那么获取失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public final boolean release(int arg) &#123;</div><div class="line">       if (tryRelease(arg)) &#123;</div><div class="line">           Node h = head;</div><div class="line">           if (h != null &amp;&amp; h.waitStatus != 0)</div><div class="line">               unparkSuccessor(h);// 释放当前节点,并唤醒他的后继节点</div><div class="line">           return true;</div><div class="line">       &#125;</div><div class="line">       return false;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>AQS类的acquire函数的处理逻辑是，先通过tryAcquire通过CAS的方式获取锁，如果获取到直接返回，否则调用addWaiter函数将该线程封装成同步队列中的等待节点，并插入到同步队列中。然后调用acquireQueued自旋的方式获得锁，获取不到的话，就中断当前线程。</p>
<p>LockSuport的函数基本上全依赖Unsafe类来实现。</p>
<p>获取锁的执行流程：</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-9-7/43846377.jpg" alt=""></p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">        <span class="comment">// See below for intrinsics setup to support this</span></div><div class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>var1</code>:操作对象</li>
<li><code>var2</code>:对象的属性地址偏移量</li>
<li><code>var4</code>:期望值</li>
<li><code>var5</code>:修改值</li>
</ul>
<h1 id="synchronized和Lock用哪个"><a href="#synchronized和Lock用哪个" class="headerlink" title="synchronized和Lock用哪个"></a>synchronized和Lock用哪个</h1><p>首先两者最大的区别就是一个是隐式锁，一个是显示锁。</p>
<p>jdk1.6之后对synchronized进行了大量的优化操作，导致在Java1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地。所以两者在使用的时候，Synchronized锁用起来比较简单。Lock锁还得顾忌到它的特性。</p>
<p>所以我们绝大部分时候还是会使用Synchronized锁，用到了Lock锁提及的特性，带来的灵活性才会考虑使用Lock显式锁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面试问题&quot;&gt;&lt;a href=&quot;#面试问题&quot; class=&quot;headerlink&quot; title=&quot;面试问题&quot;&gt;&lt;/a&gt;面试问题&lt;/h1&gt;&lt;p&gt;synchronized关键字，实现原理（和Lock对比着说，说到各自的优缺点，synchronized从最初性能差到jdk高版本后的锁膨胀机制，大大提高性能，再说底层实现，Lock的乐观锁机制，通过AQS队列同步器，调用了unsafe的CAS操作，CAS函数的参数及意义；同时可以说说synchronized底层原理，jvm层的moniter监视器，对于方法级和代码块级，互斥原理的不同，+1-1可重入的原理等）    &lt;/p&gt;
&lt;h1 id=&quot;synchronized&quot;&gt;&lt;a href=&quot;#synchronized&quot; class=&quot;headerlink&quot; title=&quot;synchronized&quot;&gt;&lt;/a&gt;synchronized&lt;/h1&gt;&lt;h2 id=&quot;synchronized的实现原理&quot;&gt;&lt;a href=&quot;#synchronized的实现原理&quot; class=&quot;headerlink&quot; title=&quot;synchronized的实现原理&quot;&gt;&lt;/a&gt;synchronized的实现原理&lt;/h2&gt;&lt;p&gt;synchronized可以保证方法或者代码块在运行时，同一时刻只有一个线程可以执行该方法或代码块，同时它还可以保证对共享变量操作的内存可见性。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://www.jiyongguang.xin/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="http://www.jiyongguang.xin/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java IO源码分析 - InputStream，OutputStream系列</title>
    <link href="http://www.jiyongguang.xin/java-io-sourcecode-InputStreamOutputStream.html"/>
    <id>http://www.jiyongguang.xin/java-io-sourcecode-InputStreamOutputStream.html</id>
    <published>2018-10-11T08:49:24.000Z</published>
    <updated>2018-10-11T08:52:03.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>整个系列的文章<strong>全部参考或直接照搬</strong>下面两位作者的文章，这里只是根据自己需要对原作者的文章梳理的总结，仅给自己日后复习时提供思路，如有读者看到学习时建议移步原作。再次重申并非我所写</p>
<ul>
<li>潘威威：<a href="https://blog.csdn.net/panweiwei1994/article/details/78046000" target="_blank" rel="external">Java8 I/O源码-目录</a></li>
<li>skywang12345：<a href="https://www.cnblogs.com/skywang12345/category/455711.html" target="_blank" rel="external">Java I/O系列</a> </li>
</ul>
<h1 id="IntputStream，OutputStream-简介"><a href="#IntputStream，OutputStream-简介" class="headerlink" title="IntputStream，OutputStream 简介"></a>IntputStream，OutputStream 简介</h1><ul>
<li>所有字节输入流的类的父类 IntputStream。</li>
<li>所有字节输出流的类的父类 OutputStream。</li>
</ul>
<a id="more"></a>
<h1 id="助于理解"><a href="#助于理解" class="headerlink" title="助于理解"></a>助于理解</h1><p>无论是输入流还是输出流，都是相对于内存的，即内存数据的输入还是输出，所以InputStream就是往内存输入数据的输入流。对于内存的动作就是read读取。相对的OutputStream就是从内存中往外输出数据，对于内存的动作的就是write操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有字节输入流的父类 InputStream 有这样一个抽象方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure></p>
<p>所以字节输入流必须提供返回下一个输入字节的read()方法。</p>
<h1 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h1><ul>
<li>ByteArrayInputStream 支持 mark/reset。</li>
<li>ByteArrayInputStream的close方法无效，无法关闭此输入流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readAheadLimit)</span> </span>&#123;</div><div class="line">    <span class="comment">// 设置流中的当前标记位置</span></div><div class="line">    mark = pos;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 将缓冲区的位置重置为标记位置</span></div><div class="line">    pos = mark;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现了父类InputStream的read方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 返回一个 0 到 255 范围内的 int 字节值。</div><div class="line"> * 负数用补码进行计算</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="number">0xff</span>) : -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，如果buf数组中有负数的话，负数在取出时<code>&amp;与</code>运算用负数的补码(除符号位全部取反并+1)进行计算。</p>
<h1 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h1><p>头<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayOutputStream</span> <span class="keyword">extends</span> <span class="title">OutputStream</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The buffer where data is stored.</div><div class="line"> * 存储数据的缓冲区</div><div class="line"> */</div><div class="line"><span class="keyword">protected</span> <span class="keyword">byte</span> buf[];</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The number of valid bytes in the buffer.</div><div class="line"> * 缓冲区中的有效字节数</div><div class="line"> */</div><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 缓冲区容量初始化为32，如有必要可扩容。通过ensureCapacity</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayOutputStream</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="number">32</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayOutputStream</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative initial size: "</span></div><div class="line">                                           + size);</div><div class="line">    &#125;</div><div class="line">    buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="ensureCapacity，grow，hugeCapacity"><a href="#ensureCapacity，grow，hugeCapacity" class="headerlink" title="ensureCapacity，grow，hugeCapacity"></a>ensureCapacity，grow，hugeCapacity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 确保缓冲区可以存放多少元素，必要时扩容</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - buf.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 增加缓冲区容量，使其至少可以存放minCapacity个元素</span></div><div class="line"><span class="comment">// minCapacity : 期望最小容量</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = buf.length;</div><div class="line">    <span class="comment">// 扩容2倍</span></div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="comment">// 如果扩容两倍还是小，那么容量赋值成该期望容量</span></div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        <span class="comment">// 如果还是不够，那么最大提升到 Integer.MAX_VALUE 舍弃到了头信息</span></div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    buf = Arrays.copyOf(buf, newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算允许分配给byte数组的最大容量</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">        Integer.MAX_VALUE :</div><div class="line">        MAX_ARRAY_SIZE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 一些虚拟机会存一些头信息到数组中，如数组的地址类型等，提升性能</span></div><div class="line"><span class="comment">// JVM默认规定数组最大容量就是Integer.MAX_VALUE，再打会内存溢出</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div></pre></td></tr></table></figure>
<h2 id="write，writeTo"><a href="#write，writeTo" class="headerlink" title="write，writeTo"></a>write，writeTo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将指定的字节写入输出流</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    ensureCapacity(count + <span class="number">1</span>);</div><div class="line">    buf[count] = (<span class="keyword">byte</span>) b;</div><div class="line">    count += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">implement了父类OutputStream抽象类的write方法</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line"><span class="comment">// 将指定byte数组中从偏移量off开始的len个字节写入输出流</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</div><div class="line">        ((off + len) - b.length &gt; <span class="number">0</span>)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</div><div class="line">    &#125;</div><div class="line">    ensureCapacity(count + len);</div><div class="line">    System.arraycopy(b, off, buf, count, len);</div><div class="line">    count += len;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将此byte数组输出流的全部内容写入到指定的输出流参数out中</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    out.write(buf, <span class="number">0</span>, count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将输出流的count字段重置为零，从而丢弃输出流中目前已累积的所有输出</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line">    count = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用指定的charsetName，通过解码字节将缓冲区内容转换为字符串并返回</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">(String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="number">0</span>, count, charsetName);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>ByteArrayOutputStream中的数据被写入到一个byte数组里。byte数组会随着被写入其中的数据的增长而增长。</li>
<li>表示字节输出流的类必须提供至少一种可写入一个输出字节的方法。ByteArrayOutputStream提供了两种。加上继承自父类OuputStream类的write方法是3种</li>
<li>ByteArrayOutputStream可以将缓冲区中的数据转化为byte数组或字符串并返回。</li>
<li>ByteArrayOutputStream可以通过writeTo( OutputStream out)实现输出流之间数据的复制</li>
<li>ByteArrayOutputStream 的close方法无效，无法关闭此输出流。</li>
</ul>
<h1 id="PipedInputStream，PipedOutputStream"><a href="#PipedInputStream，PipedOutputStream" class="headerlink" title="PipedInputStream，PipedOutputStream"></a>PipedInputStream，PipedOutputStream</h1><p>PipedInputStream与PipedOutputStream分别为管道输入流和管道输出流。<strong>管道输入流通过连接到管道输出流实现了类似管道的功能，用于线程之间的通信。</strong></p>
<p>通常，由某个线程向管道输出流中写入数据。根据管道的特性，这些数据会自动发送到与管道输出流对应的管道输入流中。这时其他线程就可以从管道输入流中读取数据，这样就实现了线程之间的通信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span></span></div></pre></td></tr></table></figure>
<h2 id="initPipe，connect，"><a href="#initPipe，connect，" class="headerlink" title="initPipe，connect，"></a>initPipe，connect，</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 初始化PipedInputStream的缓冲区大小</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> pipeSize 管道缓冲区容量</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPipe</span><span class="params">(<span class="keyword">int</span> pipeSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (pipeSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Pipe Size &lt;= 0"</span>);</div><div class="line">    &#125;</div><div class="line">    buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[pipeSize];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 将PipedInputStream连接到指定的PipedOutputStream。</div><div class="line"> *</div><div class="line"> * 如果 PipedInputStream 已经被连接到了其他 PipedOutputStream，</div><div class="line"> * 或者PipedOutputStream 已经被连接到其他PipedInputStream </div><div class="line"> * 抛出IOException。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(PipedOutputStream src)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    src.connect(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="receive，awaitSpace，checkStateForReceive"><a href="#receive，awaitSpace，checkStateForReceive" class="headerlink" title="receive，awaitSpace，checkStateForReceive"></a>receive，awaitSpace，checkStateForReceive</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 接收一个数据字节，将其插入到缓冲区。如果没有可用的输入，方法会阻塞</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// 接受前的状态检查</span></div><div class="line">    checkStateForReceive();</div><div class="line">    <span class="comment">// 设置负责向管道缓冲区输入数据的线程是当前线程</span></div><div class="line">    writeSide = Thread.currentThread();</div><div class="line">    <span class="comment">// 如果缓冲区被塞满的时候</span></div><div class="line">    <span class="keyword">if</span> (in == out)</div><div class="line">        <span class="comment">// 缓冲区被写入线程塞满的时候,唤醒读取线程，并阻塞当前写入线程</span></div><div class="line">        awaitSpace();</div><div class="line">    <span class="comment">// 初次接受前初始化</span></div><div class="line">    <span class="keyword">if</span> (in &lt; <span class="number">0</span>) &#123;</div><div class="line">        in = <span class="number">0</span>;</div><div class="line">        out = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    buffer[in++] = (<span class="keyword">byte</span>) (b &amp; <span class="number">0xFF</span>);</div><div class="line">    <span class="comment">// 从头复入</span></div><div class="line">    <span class="keyword">if</span> (in &gt;= buffer.length) &#123;</div><div class="line">        in = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 检查PipedInputStream是否可以接收数据</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkStateForReceive</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!connected) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closedByWriter || closedByReader) &#123;<span class="comment">// 输入输出流都不能被关闭</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readSide != <span class="keyword">null</span> &amp;&amp; !readSide.isAlive()) &#123;<span class="comment">// switSpace 需要用到读线程,读线程不能为空且不alive</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Read end dead"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等待可用缓冲区</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitSpace</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">while</span> (in == out) &#123;</div><div class="line">        checkStateForReceive();</div><div class="line"></div><div class="line">        <span class="comment">/* full: kick any waiting readers */</span></div><div class="line">        notifyAll();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            wait(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InterruptedIOException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 接受指定字节数组的数据</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// 检查接受状态</span></div><div class="line">    checkStateForReceive();</div><div class="line">    <span class="comment">// 身份</span></div><div class="line">    writeSide = Thread.currentThread();</div><div class="line">    <span class="comment">// 写入总量</span></div><div class="line">    <span class="keyword">int</span> bytesToTransfer = len;</div><div class="line">    <span class="keyword">while</span> (bytesToTransfer &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 判断缓冲区满没满</span></div><div class="line">        <span class="keyword">if</span> (in == out)</div><div class="line">            awaitSpace();</div><div class="line">        <span class="comment">// 下次插入量</span></div><div class="line">        <span class="keyword">int</span> nextTransferAmount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (out &lt; in) &#123;</div><div class="line">            nextTransferAmount = buffer.length - in;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (in &lt; out) &#123;</div><div class="line">            <span class="comment">// 初次写入</span></div><div class="line">            <span class="keyword">if</span> (in == -<span class="number">1</span>) &#123;</div><div class="line">                in = out = <span class="number">0</span>;</div><div class="line">                nextTransferAmount = buffer.length - in;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 再次写入</span></div><div class="line">                nextTransferAmount = out - in;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果 可插入的量 &gt; 要插入的量，那么一次插入结束，此次插入的量就是写入线程要插入数据的总量，</span></div><div class="line">        <span class="comment">// 否则off记录偏移量，in记录存入位，bytesToTransfer记录剩余插入量，while循环批次执行。</span></div><div class="line">        <span class="keyword">if</span> (nextTransferAmount &gt; bytesToTransfer)</div><div class="line">            nextTransferAmount = bytesToTransfer;</div><div class="line">        <span class="keyword">assert</span> (nextTransferAmount &gt; <span class="number">0</span>);</div><div class="line">        <span class="comment">// 写入</span></div><div class="line">        System.arraycopy(b, off, buffer, in, nextTransferAmount);</div><div class="line">        bytesToTransfer -= nextTransferAmount;</div><div class="line">        off += nextTransferAmount;</div><div class="line">        in += nextTransferAmount;</div><div class="line">        <span class="keyword">if</span> (in &gt;= buffer.length) &#123;</div><div class="line">            in = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="receivedLast"><a href="#receivedLast" class="headerlink" title="receivedLast"></a>receivedLast</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 管道输出流关闭时（PipedOutputStream.close()中会调用此方法），通知其已经关闭。</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receivedLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 状态设置</span></div><div class="line">    closedByWriter = <span class="keyword">true</span>;</div><div class="line">    notifyAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// 状态检测</span></div><div class="line">    <span class="keyword">if</span> (!connected) &#123;<span class="comment">// 输入输出流是否连接上</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closedByReader) &#123;<span class="comment">// 管道输入流被关闭</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (writeSide != <span class="keyword">null</span> &amp;&amp; !writeSide.isAlive() <span class="comment">// 写线程存在但不alive，管道输出流没关 且现在管道中没数据</span></div><div class="line">            &amp;&amp; !closedByWriter &amp;&amp; (in &lt; <span class="number">0</span>)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Write end dead"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 状态设置，当前线程为读取线程</span></div><div class="line">    readSide = Thread.currentThread();</div><div class="line">    <span class="comment">// 尝试次数</span></div><div class="line">    <span class="keyword">int</span> trials = <span class="number">2</span>;</div><div class="line">    <span class="comment">// 管道中没数据</span></div><div class="line">    <span class="keyword">while</span> (in &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 如果管道输出流关闭，且此时in&lt;0 管道缓冲区没机会再写入内容了，read 返回 return -1</span></div><div class="line">        <span class="keyword">if</span> (closedByWriter) &#123;</div><div class="line">            <span class="comment">/* closed by writer, return EOF */</span></div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果写入数据的线程不为null且不活跃且trials&lt;=0，说明管道损坏，抛出异常</span></div><div class="line">        <span class="keyword">if</span> ((writeSide != <span class="keyword">null</span>) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; <span class="number">0</span>)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe broken"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* might be a writer waiting */</span> <span class="comment">// 唤醒写入</span></div><div class="line">        notifyAll();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            wait(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InterruptedIOException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ret = buffer[out++] &amp; <span class="number">0xFF</span>;</div><div class="line">    <span class="comment">// 读完一轮，复位</span></div><div class="line">    <span class="keyword">if</span> (out &gt;= buffer.length) &#123;</div><div class="line">        out = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 管道缓冲区为空，读完</span></div><div class="line">    <span class="keyword">if</span> (in == out) &#123;</div><div class="line">        <span class="comment">/* now empty */</span></div><div class="line">        in = -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* possibly wait on the first character */</span></div><div class="line">    <span class="comment">// 尝试读一个字节，看缓冲区情况</span></div><div class="line">    <span class="keyword">int</span> c = read();</div><div class="line">    <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    b[off] = (<span class="keyword">byte</span>) c;</div><div class="line">    <span class="comment">// readLength</span></div><div class="line">    <span class="keyword">int</span> rlen = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> ((in &gt;= <span class="number">0</span>) &amp;&amp; (len &gt; <span class="number">1</span>)) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> available;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (in &gt; out) &#123;</div><div class="line">            <span class="comment">// 可读数</span></div><div class="line">            available = Math.min((buffer.length - out), (in - out));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            available = buffer.length - out;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// A byte is read beforehand outside the loop</span></div><div class="line">        <span class="comment">// 可读数 &gt; 要读数</span></div><div class="line">        <span class="keyword">if</span> (available &gt; (len - <span class="number">1</span>)) &#123;</div><div class="line">            available = len - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        System.arraycopy(buffer, out, b, off + rlen, available);</div><div class="line">        <span class="comment">// 一次读取影响到的变量统一变更</span></div><div class="line">        out += available;</div><div class="line">        rlen += available;</div><div class="line">        len -= available;</div><div class="line"></div><div class="line">        <span class="comment">// 继续从头读</span></div><div class="line">        <span class="keyword">if</span> (out &gt;= buffer.length) &#123;</div><div class="line">            out = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 缓冲区读完</span></div><div class="line">        <span class="keyword">if</span> (in == out) &#123;</div><div class="line">            <span class="comment">/* now empty */</span></div><div class="line">            in = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> rlen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="available，close"><a href="#available，close" class="headerlink" title="available，close"></a>available，close</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (in &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (in == out)<span class="comment">// 读完被置为-1 所以这里肯定是满了</span></div><div class="line">        <span class="keyword">return</span> buffer.length;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (in &gt; out)</div><div class="line">        <span class="keyword">return</span> in - out;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> in + buffer.length - out;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 关闭此管道输入流，并释放与该流相关的所有系统资源。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// 状态设置</span></div><div class="line">    closedByReader = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        in = -<span class="number">1</span>;<span class="comment">// </span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="PipedOutputStream"><a href="#PipedOutputStream" class="headerlink" title="PipedOutputStream"></a>PipedOutputStream</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedOutputStream</span> <span class="keyword">extends</span> <span class="title">OutputStream</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> PipedInputStream sink; <span class="comment">// 与PipedOutputStream相连接的管道输入流</span></div><div class="line">    </div><div class="line">    <span class="comment">// 创建连接到指定输入流的管道输出流</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PipedOutputStream</span><span class="params">(PipedInputStream snk)</span>  <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        connect(snk);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建没有连接到输入流的管道输出流。</span></div><div class="line">    <span class="comment">// 在使用前，它必须连接到管道输入流。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PipedOutputStream</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="connect，write"><a href="#connect，write" class="headerlink" title="connect，write"></a>connect，write</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(PipedInputStream snk)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (snk == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sink != <span class="keyword">null</span> || snk.connected) &#123;<span class="comment">// 此管道输出流已经与某管道输入流连接 或 该管道输入流已经被连接</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Already connected"</span>);</div><div class="line">    &#125;</div><div class="line">    sink = snk;</div><div class="line">    snk.in = -<span class="number">1</span>;</div><div class="line">    snk.out = <span class="number">0</span>;</div><div class="line">    snk.connected = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将指定数据字节写入管道输出流</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span>  <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sink == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</div><div class="line">    &#125;</div><div class="line">    sink.receive(b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将指定字节数组的数组写入到管道缓冲区中</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// 数据校验</span></div><div class="line">    <span class="keyword">if</span> (sink == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</div><div class="line">               ((off + len) &gt; b.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 调用管道输入流的receive函数处理</span></div><div class="line">    sink.receive(b, off, len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="close，receivedLast，flush"><a href="#close，receivedLast，flush" class="headerlink" title="close，receivedLast，flush"></a>close，receivedLast，flush</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sink != <span class="keyword">null</span>) &#123;</div><div class="line">        sink.receivedLast();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// PipedInputStream类的receivedLast函数</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receivedLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 状态设置，负责缓冲区数据写入的流被关闭了。</span></div><div class="line">    closedByWriter = <span class="keyword">true</span>;</div><div class="line">    notifyAll();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 刷新此输出流并强制写出所有缓冲的输出字节。</div><div class="line"> * 这将通知所有读取数据的线程，告知它们管道中的字符处于读取等待中。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sink != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (sink) &#123;</div><div class="line">            sink.notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>首先在看PipedInputStream和PipedOutputStream的时候，我刚开始没搞懂为什么PipedInputStream技能read又能recieve。后来看了PipedOutputStream的源码的时候才知道，原来PipedInputStream类中的recieve函数是给PipedOutputStream类中的write函数调用的，后来才串明白，这是一个“管道”的输入输出流，用一个容量默认为1024的byte数组来做管道的缓冲容量，最终的输入输出实现都落实到了PipedInputStream类中，这样状态都由一个类来控制才能做到，某个线程通过管道输出流向管道中写入数据，另一端管道输入流能立马从管道中取出对应存储到的数据。</p>
<ul>
<li>PipedInputStream与PipedOutputStream分别为管道输入流和管道输出流。管道输入流通过连接到管道输出流实现了类似管道的功能，用于线程之间的通信。</li>
<li>通常，由某个线程向管道输出流中写入数据。根据管道的特性，这些数据会自动发送到与管道输出流对应的管道输入流中。这时其他线程就可以从管道输入流中读取数据，这样就实现了线程之间的通信。</li>
<li>不建议对这两个流对象尝试使用单个线程，因为这样可能死锁线程。</li>
<li>PipedOutputStream是数据的发送者；PipedInputStream是数据的接收者。</li>
<li>PipedInputStream缓冲区大小默认为1024，写入数据时写入到这个缓冲区的，读取数据也是从这个缓冲区中读取的。</li>
<li>PipedInputStream通过read方法读取数据。PipedOutputStream通过write方法写入数据，write方法其实是调用PipedInputStream中的receive方法来实现将数据写入缓冲区的的，因为缓冲区是在PipedInputStream中的。</li>
<li>PipedOutputStream和PipedInputStream之间通过<code>connect()</code>方法连接。</li>
<li>使用后要关闭输入输出流</li>
</ul>
<h1 id="FilterInputStream，FilterOutputStream"><a href="#FilterInputStream，FilterOutputStream" class="headerlink" title="FilterInputStream，FilterOutputStream"></a>FilterInputStream，FilterOutputStream</h1><p>FilterInputStream、FilterOutputStream是过滤器字节输入输出流。它们的主要用途在于封装其他的输入输出流，为它们提供一些额外的功能。 - 装饰者模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.io;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.in = in;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> in.read();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> in.read(b, off, len);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> in.skip(n);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> in.available();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        in.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;</div><div class="line">        in.mark(readlimit);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        in.reset();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> in.markSupported();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以从源码看出，FilterInuptStream类本身并没有对构造时传入的InputStream抽象类的实例进行装饰，只是简单的重写了父类InputStream类的所有方法。</p>
<p>可以看出FilterInputStream在这里做的是装饰抽象类。而InputStream做的是抽象构建。</p>
<p>根据装饰模式的设计思想我们可以得知，虽然FilterInutStream类并不为具体构建提供装饰功能。但其子类在装饰模式中充当的是具体装饰类，可以进一步重写这些方法中的一些方法，来提供装饰功能。它的常用子类有<code>BufferedInputStream</code>和<code>DataInputStream</code>。比如，BufferedInputStream的作用就是为它装饰的输入流提供缓冲功能。</p>
<p>至此：</p>
<ul>
<li>InputStream：抽象构建</li>
<li><em>*</em>InputStream：具体构建</li>
<li>FilterInputStream：抽象装饰类</li>
<li>BufferedInputStream：具体装饰类</li>
</ul>
<h2 id="filterOutputStream"><a href="#filterOutputStream" class="headerlink" title="filterOutputStream"></a>filterOutputStream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterOutputStream</span> <span class="keyword">extends</span> <span class="title">OutputStream</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">protected</span> OutputStream out;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilterOutputStream</span><span class="params">(OutputStream out)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.out = out;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        out.write(b);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        write(b, <span class="number">0</span>, b.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((off | len | (b.length - (len + off)) | (off + len)) &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++) &#123;</div><div class="line">            write(b[off + i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        out.flush();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"try"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">try</span> (OutputStream ostream = out) &#123;</div><div class="line">            flush();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是看了FilterInputStream源码后不要想当然的认为FilterOutputStream也和它一样全篇方法调用装饰的OutputStream的子类的原方法。其也重写的父类的OutputStream全部方法，并有一些赋予了自己的处理逻辑。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li>FilterInputStream、FilterOutputStream是过滤器字节输入输出流。它们的主要用途在于封装其他的输入输出流，为它们提供一些额外的功能。</li>
<li>FilterInputStream、FilterOutputStream并没有提供什么装饰功能。FilterInputStream、FilterOutputStream的子类可进一步重写这些方法中的一些方法，来提供装饰功能。</li>
<li>FilterInputStream装饰功能的实现的关键在于类中有一个InputStream字段，依赖这个字段它才可以对InputStream的子类提供装饰功能。FilterOutputStream也是如此。</li>
</ul>
<h1 id="BufferedInputStream，BufferedOutputStream"><a href="#BufferedInputStream，BufferedOutputStream" class="headerlink" title="BufferedInputStream，BufferedOutputStream"></a>BufferedInputStream，BufferedOutputStream</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="number">8192</span>;<span class="comment">// 1024 &lt;&lt; 3; 缓冲区默认的默认大小</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_BUFFER_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;<span class="comment">// 分派给arrays的最大容量</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">byte</span> buf[];<span class="comment">// 存放数据的内部缓冲数组。，如果有必要，它可能被不同大小的数组替代</span></div><div class="line">    <span class="comment">// 当前缓冲区的有效字节数。</span></div><div class="line">    <span class="comment">// 注意，这里是指缓冲区的有效字节数，而不是输入流中的有效字节数。</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</div><div class="line">    <span class="comment">// 当前缓冲区的位置索引</span></div><div class="line">    <span class="comment">// 注意，这里是指缓冲区的位置索引，而不是输入流中的位置索引。</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> pos;</div><div class="line">    <span class="comment">// 当前缓冲区的标记位置</span></div><div class="line">    <span class="comment">// markpos和reset()配合使用才有意义。操作步骤：</span></div><div class="line">    <span class="comment">// (01) 通过mark() 函数，保存pos的值到markpos中。</span></div><div class="line">    <span class="comment">// (02) 通过reset() 函数，会将pos的值重置为markpos。接着通过read()读取数据时，就会从mark()保存的位置开始读取。</span></div><div class="line">    <span class="comment">// 可以理解为，mark位置之后的数据是保留数据，即有效数据。mark确立了有效数据和无效数据。</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> markpos = -<span class="number">1</span>;</div><div class="line">    <span class="comment">// 相当于从输入流中一次读取数据的大小。当buffer.length小于这个值的时候就需要频繁的扩容，当大于这个值的时候就可以直接从输入流中读取数据。</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> marklimit;</div><div class="line">     <span class="comment">// 缓存数组的原子更新器。</span></div><div class="line">     <span class="comment">// 该成员变量与buf数组的volatile关键字共同组成了buf数组的原子更新功能实现，</span></div><div class="line">     <span class="comment">// 即，在多线程中操作BufferedInputStream对象时，buf和bufUpdater都具有原子性(不同的线程访问到的数据都是相同的)</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span></div><div class="line">        AtomicReferenceFieldUpdater&lt;BufferedInputStream, <span class="keyword">byte</span>[]&gt; bufUpdater =</div><div class="line">        AtomicReferenceFieldUpdater.newUpdater</div><div class="line">        (BufferedInputStream.class,  <span class="keyword">byte</span>[].class, <span class="string">"buf"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BufferedInputStream的作用是为其它输入流提供缓冲功能。创建BufferedInputStream时，我们会通过它的构造函数指定某个输入流为参数。BufferedInputStream会将该输入流数据分批读取，每次读取一部分到缓冲中；操作完缓冲中的这部分数据之后，再从输入流中读取下一部分的数据。(即对应read时发现缓冲区数据不够时调用fill函数，fill函数内部调用read函数读取输入流中的数据再填充buf缓冲区。)</p>
<p>为什么需要缓冲呢？原因很简单，效率问题！缓冲中的数据实际上是保存在内存中，而原始数据可能是保存在硬盘或NandFlash等存储介质中；而我们知道，从内存中读取数据的速度比从硬盘读取数据的速度至少快10倍以上。<br>那干嘛不干脆一次性将全部数据都读取到缓冲中呢？第一，读取全部的数据所需要的时间可能会很长。第二，内存价格很贵，容量不像硬盘那么大。</p>
<p>该类最关键的函数及<code>fill()</code>方法，其他方法都很好理解。该方法负责读取输入流的数据来填充buf缓冲区。具体解释可参考<code>http://www.cnblogs.com/skywang12345/p/io_12.html</code>。</p>
<h2 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h2><p>看过BufferedInputStream源码之后BufferedOutputStream就看起来很简单了，和BufferedInputStream一样，BufferedOutputStream通过字节数组来缓冲数据(1024*8)。BufferedOutputStream当缓冲区满或者用户调用flush()函数时，它就会将缓冲区的数据写入到输出流中。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>BufferedInputStream是缓冲输入流，作用是为另一个输入流添加一些功能，比如缓冲输入功能以及支持mark和reset方法的能力。</li>
<li>BufferedOutputStream是缓冲输出流，通过设置这种输出流，应用程序就可以将单个或字节数组缓冲的写入底层输出流中，而不必针对每次字节写入调用底层系统。</li>
</ul>
<h1 id="DataInputStream，DataOutputStream"><a href="#DataInputStream，DataOutputStream" class="headerlink" title="DataInputStream，DataOutputStream"></a>DataInputStream，DataOutputStream</h1><h2 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h2><ul>
<li>DataInputStream为数据输入流，它允许应用程序以与机器无关方式从底层输入流中读取基本Java数据类型。 </li>
<li>DataOutputStream为数据输出流，它允许应用程序以适当方式将基本 Java数据类型写入输出流中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">return</span> readUTF(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String <span class="title">readUTF</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">int</span> utflen = in.readUnsignedShort();</div><div class="line">    <span class="keyword">byte</span>[] bytearr = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">char</span>[] chararr = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (in <span class="keyword">instanceof</span> DataInputStream) &#123;</div><div class="line">        DataInputStream dis = (DataInputStream)in;</div><div class="line">        <span class="keyword">if</span> (dis.bytearr.length &lt; utflen)&#123;</div><div class="line">            dis.bytearr = <span class="keyword">new</span> <span class="keyword">byte</span>[utflen*<span class="number">2</span>];</div><div class="line">            dis.chararr = <span class="keyword">new</span> <span class="keyword">char</span>[utflen*<span class="number">2</span>];</div><div class="line">        &#125;</div><div class="line">        chararr = dis.chararr;</div><div class="line">        bytearr = dis.bytearr;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        bytearr = <span class="keyword">new</span> <span class="keyword">byte</span>[utflen];</div><div class="line">        chararr = <span class="keyword">new</span> <span class="keyword">char</span>[utflen];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> c, char2, char3;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> chararr_count=<span class="number">0</span>;</div><div class="line"></div><div class="line">    in.readFully(bytearr, <span class="number">0</span>, utflen);</div><div class="line"></div><div class="line">    <span class="comment">// 由于UTF-8的单字节和ASCII相同，所以这里就将它们进行预处理，直接保存到“字符数组chararr”中。</span></div><div class="line">    <span class="comment">// 对于其它的UTF-8数据，则在后面进行处理。</span></div><div class="line">    <span class="keyword">while</span> (count &lt; utflen) &#123;</div><div class="line">        c = (<span class="keyword">int</span>) bytearr[count] &amp; <span class="number">0xff</span>;</div><div class="line">        <span class="keyword">if</span> (c &gt; <span class="number">127</span>) <span class="keyword">break</span>;</div><div class="line">        count++;</div><div class="line">        chararr[chararr_count++]=(<span class="keyword">char</span>)c;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (count &lt; utflen) &#123;</div><div class="line">        c = (<span class="keyword">int</span>) bytearr[count] &amp; <span class="number">0xff</span>;</div><div class="line">        <span class="keyword">switch</span> (c &gt;&gt; <span class="number">4</span>) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">case</span> <span class="number">7</span>:</div><div class="line">                <span class="comment">/* 0xxxxxxx*/</span></div><div class="line">                count++;</div><div class="line">                chararr[chararr_count++]=(<span class="keyword">char</span>)c;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">12</span>: <span class="keyword">case</span> <span class="number">13</span>:</div><div class="line">                <span class="comment">/* 110x xxxx   10xx xxxx*/</span></div><div class="line">                count += <span class="number">2</span>;</div><div class="line">                <span class="keyword">if</span> (count &gt; utflen)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</div><div class="line">                        <span class="string">"malformed input: partial character at end"</span>);</div><div class="line">                char2 = (<span class="keyword">int</span>) bytearr[count-<span class="number">1</span>];</div><div class="line">                <span class="keyword">if</span> ((char2 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</div><div class="line">                        <span class="string">"malformed input around byte "</span> + count);</div><div class="line">                chararr[chararr_count++]=(<span class="keyword">char</span>)(((c &amp; <span class="number">0x1F</span>) &lt;&lt; <span class="number">6</span>) |</div><div class="line">                                                (char2 &amp; <span class="number">0x3F</span>));</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">14</span>:</div><div class="line">                <span class="comment">/* 1110 xxxx  10xx xxxx  10xx xxxx */</span></div><div class="line">                count += <span class="number">3</span>;</div><div class="line">                <span class="keyword">if</span> (count &gt; utflen)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</div><div class="line">                        <span class="string">"malformed input: partial character at end"</span>);</div><div class="line">                char2 = (<span class="keyword">int</span>) bytearr[count-<span class="number">2</span>];</div><div class="line">                char3 = (<span class="keyword">int</span>) bytearr[count-<span class="number">1</span>];</div><div class="line">                <span class="keyword">if</span> (((char2 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) || ((char3 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>))</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</div><div class="line">                        <span class="string">"malformed input around byte "</span> + (count-<span class="number">1</span>));</div><div class="line">                chararr[chararr_count++]=(<span class="keyword">char</span>)(((c     &amp; <span class="number">0x0F</span>) &lt;&lt; <span class="number">12</span>) |</div><div class="line">                                                ((char2 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">6</span>)  |</div><div class="line">                                                ((char3 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">0</span>));</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="comment">/* 10xx xxxx,  1111 xxxx */</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</div><div class="line">                    <span class="string">"malformed input around byte "</span> + count);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// The number of chars produced may be less than utflen</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chararr, <span class="number">0</span>, chararr_count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>readUTF的执行流程相当于把UTF-8编码的输入流中的字节数据先读到了bytearr数组中，然后根据UTF-8编码的特殊性，判断数据是几个字节，根据情况又往chararr数组中转。保证了每个字符转化的正确率，最后所有的字符都正确的转化到了chararr数组中，然后返回string值。</p>
<h3 id="readUnsignedShort，readBoolean，readUnsignedByte"><a href="#readUnsignedShort，readBoolean，readUnsignedByte" class="headerlink" title="readUnsignedShort，readBoolean，readUnsignedByte"></a>readUnsignedShort，readBoolean，readUnsignedByte</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// UTF-8输入流的前2个字节是数据的长度</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">readUnsignedShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">int</span> ch1 = in.read();</div><div class="line">    <span class="keyword">int</span> ch2 = in.read();</div><div class="line">    <span class="keyword">if</span> ((ch1 | ch2) &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</div><div class="line">    <span class="keyword">return</span> (ch1 &lt;&lt; <span class="number">8</span>) + (ch2 &lt;&lt; <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 此方法适用于读取用接口DataOutput的 writeBoolean方法写入的字节</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">//从输入流中读取一个字节</span></div><div class="line">    <span class="keyword">int</span> ch = in.read();</div><div class="line">    <span class="comment">//如果达到输入流末尾，抛出异常</span></div><div class="line">    <span class="keyword">if</span> (ch &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</div><div class="line">    <span class="comment">//如果读取的字节不是零，则返回true；如果是零，则返回false</span></div><div class="line">    <span class="keyword">return</span> (ch != <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 读取一个无符号为byte输入字节，将它数值位左侧补零转变为int类型(覆盖符号位)，并返回结果，所以结果的范围是0到255</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">readUnsignedByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">int</span> ch = in.read();</div><div class="line">    <span class="keyword">if</span> (ch &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</div><div class="line">    <span class="keyword">return</span> ch;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们落实到该类的特点，<strong>它允许应用程序以与机器无关方式从底层输入流中读取基本Java数据类型。</strong></p>
<p>其实就是通过构造时传入的InputStream对象来根据要读取的数据类型来读取对应的字节数，比如readByte就调用一次in.read。然后把读取出来的数据强转成(byte)。readChar的话就调用两次，然后因为两个字节连续起来表示一个字符，那么就将先读出来的字节适当的移位并将两个字节+起来。这样就相当于一次性读出来两个字节，然后对该数据强转即可得到最真实的数据。</p>
<p>需要注意的是，因为我们从输入流中读出的内容返回的是int类型的，默认除了数据位，把我们原数据的符号位覆盖掉了。然后我们强转就可以就可以恢复(暂时先那么理解有符号位和无符号位的计算方式，方便记忆，虽然肯定不是这样，以后再研究。)</p>
<h2 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h2><h3 id="incCount，flush，size"><a href="#incCount，flush，size" class="headerlink" title="incCount，flush，size"></a>incCount，flush，size</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 到目前为止写入到输出流中的字节数 最大值为Integer.MAX_VALUE</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> written;</div><div class="line"></div><div class="line"><span class="comment">// 增加wirtten的值。最大值为Integer.MAX_VALUE</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incCount</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = written + value;</div><div class="line">    <span class="comment">//int允许的最大值为Integer.MAX_VALUE，即2147483647，2147483647+1即为负数</span></div><div class="line">    <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) &#123;</div><div class="line">        temp = Integer.MAX_VALUE;</div><div class="line">    &#125;</div><div class="line">    written = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  清空此数据输出流。这迫使所有缓冲的输出字节被写出到流中。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    out.flush();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 返回written的当前值，即到目前为止写入此数据输出流的字节数。最大值为Integer.MAX_VALUE。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> written;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="writeShort，writeChar，writeFloat"><a href="#writeShort，writeChar，writeFloat" class="headerlink" title="writeShort，writeChar，writeFloat"></a>writeShort，writeChar，writeFloat</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeChar</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    out.write((v &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</div><div class="line">    out.write((v &gt;&gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>);</div><div class="line">    incCount(<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeChars</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = s.length();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++) &#123;</div><div class="line">        <span class="keyword">int</span> v = s.charAt(i);</div><div class="line">        out.write((v &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</div><div class="line">        out.write((v &gt;&gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>);</div><div class="line">    &#125;</div><div class="line">    incCount(len * <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用Float类中的floatToIntBits方法将float参数转换为一个int值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    writeInt(Float.floatToIntBits(v));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到DataOutputStream和DataInputStream的处理方式是一样的，要输入到输出流的数据有可能是1个字节或多个字节的，所以对应不同的数据定义了不同的函数，然后针对这些数值一个字节一个字节的进行输入就好。</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ul>
<li>DataInputStream提供了一系列从二进制流中读取字节，并根据所有Java基本类型数据进行重构的readXXXX方法。同时还提供根据UTF-8编码格式的数据写入输入流的方式，即readUTF方法。</li>
<li>DataOutputStream提供了一系列将数据从任意Java基本类型转换为一系列字节，并将这些字节写入二进制流的writeXXXX方法。同时还提供了一个将String转换成UTF-8修改版格式并写入所得到的系列字节的工具，即writeUTF方法。</li>
</ul>
<h1 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h1><p>由于学习的时候，我在学习字节流的时候跳过了PrintStream，先看的PrintWriter所以看过PrintWriter后再来看PrintStream就感觉很简单了，所以简单记录下。</p>
<ul>
<li>PrintStream 是打印输出流，它继承于FilterOutputStream。</li>
<li>PrintStream 是<strong>用来装饰其它输出流</strong>。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。为底层输出流提供了缓存池(BufferedWriter)。</li>
<li>与其他输出流不同，PrintStream 永远不会抛出 IOException；它产生的IOException会被自身的函数所捕获并设置错误标记， 用户可以通过 checkError() 返回错误标记，从而查看PrintStream内部是否产生了IOException。</li>
<li>另外，PrintStream 提供了自动flush 和 字符集设置功能。所谓自动flush，就是往PrintStream写入的数据会立刻调用flush()函数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStream</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span></span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">Closeable</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 自动flush</span></div><div class="line">    <span class="comment">// 所谓“自动flush”，就是每次执行print(), println(), write()函数，都会调用flush()函数；</span></div><div class="line">    <span class="comment">// 而“不自动flush”，则需要我们手动调用flush()接口。</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> autoFlush;</div><div class="line">    <span class="comment">// PrintStream是否右产生异常。当PrintStream有异常产生时，会被本身捕获，并设置trouble为true</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> trouble = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 用于格式化的对象</span></div><div class="line">    <span class="keyword">private</span> Formatter formatter;</div><div class="line"></div><div class="line">    <span class="comment">// BufferedWriter对象，用于实现“PrintStream支持字符集”。</span></div><div class="line">    <span class="comment">// 因为PrintStream是OutputStream的子类，所以它本身不支持字符串；</span></div><div class="line">    <span class="comment">// 但是BufferedWriter支持字符集，因此可以通过OutputStreamWriter创建PrintStream对应的BufferedWriter对象，从而支持字符集。</span></div><div class="line">    <span class="keyword">private</span> BufferedWriter textOut;</div><div class="line">    <span class="keyword">private</span> OutputStreamWriter charOut;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj, String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(message);</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>==需要注意的是== ：很明显，该类和PrintWriter还有个最大的区别。继承自FilterOutputStream，也就是它做的是装饰模式中的具体装饰类。至于Appendable，Closeable接口和PrintWriter则没区别，PrintWriter其父类Writer抽象也早实现了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStream</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span></span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">Closeable</span></div><div class="line">&#123;</div></pre></td></tr></table></figure></p>
<h2 id="PrintStream和DataOutputStream异同点"><a href="#PrintStream和DataOutputStream异同点" class="headerlink" title="PrintStream和DataOutputStream异同点"></a>PrintStream和DataOutputStream异同点</h2><p>相同点：都是继承与FileOutputStream，用于包装其它输出流。</p>
<p>不同点：</p>
<ol>
<li>PrintStream和DataOutputStream 都可以将数据格式化输出；但它们在“输出字符串”时的<strong>编码不同</strong>。<ul>
<li>PrintStream是输出时采用的是用户指定的编码(创建PrintStream时指定的)，若没有指定，则采用系统默认的字符编码。而DataOutputStream则采用的是UTF-8。 </li>
</ul>
</li>
<li>它们的写入数据时的异常处理机制不同。<ul>
<li>DataOutputStream在通过write()向“输出流”中写入数据时，若产生IOException，会抛出。</li>
<li>而PrintStream在通过write()向“输出流”中写入数据时，若产生IOException，则会在write()中进行捕获处理；并设置trouble标记(用于表示产生了异常)为true。用户可以通过checkError()返回trouble值，从而检查输出流中是否产生了异常。</li>
</ul>
</li>
<li>构造函数不同<ul>
<li>DataOutputStream的构造函数只有一个：DataOutputStream(OutputStream out)。即它只支持以输出流out作为“DataOutputStream的输出流”。</li>
<li>而PrintStream的构造函数有许多：和DataOutputStream一样，支持以输出流out作为“PrintStream输出流”的构造函数；还支持以“File对象”或者“String类型的文件名对象”的构造函数。</li>
<li>而且，在PrintStream的构造函数中，能“指定字符集”和“是否支持自动flush()操作”。</li>
</ul>
</li>
<li>目的不同<ul>
<li>DataOutputStream的作用是<strong>装饰其它的输出流，它和DataInputStream配合使用：允许应用程序以与机器无关的方式从底层输入流中读写java数据类型</strong>。</li>
<li>而PrintStream的作用虽然也是装饰其他输出流，但是它的目的不是以与机器无关的方式从底层读写java数据类型；而是<strong>为其它输出流提供打印各种数据值表示形式，使其它输出流能方便的通过print(),println()或printf()等输出各种格式的数据。</strong></li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;整个系列的文章&lt;strong&gt;全部参考或直接照搬&lt;/strong&gt;下面两位作者的文章，这里只是根据自己需要对原作者的文章梳理的总结，仅给自己日后复习时提供思路，如有读者看到学习时建议移步原作。再次重申并非我所写&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;潘威威：&lt;a href=&quot;https://blog.csdn.net/panweiwei1994/article/details/78046000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java8 I/O源码-目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;skywang12345：&lt;a href=&quot;https://www.cnblogs.com/skywang12345/category/455711.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java I/O系列&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;IntputStream，OutputStream-简介&quot;&gt;&lt;a href=&quot;#IntputStream，OutputStream-简介&quot; class=&quot;headerlink&quot; title=&quot;IntputStream，OutputStream 简介&quot;&gt;&lt;/a&gt;IntputStream，OutputStream 简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;所有字节输入流的类的父类 IntputStream。&lt;/li&gt;
&lt;li&gt;所有字节输出流的类的父类 OutputStream。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://www.jiyongguang.xin/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java IO源码分析 - Reader，Writer系列（二）</title>
    <link href="http://www.jiyongguang.xin/java-io-sourcecode-ReaderWriter2.html"/>
    <id>http://www.jiyongguang.xin/java-io-sourcecode-ReaderWriter2.html</id>
    <published>2018-10-11T08:46:06.000Z</published>
    <updated>2018-10-11T08:48:58.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>整个系列的文章<strong>全部参考或直接照搬</strong>下面两位作者的文章，这里只是根据自己需要对原作者的文章梳理的总结，仅给自己日后复习时提供思路，如有读者看到学习时建议移步原作。再次重申并非我所写</p>
<ul>
<li>潘威威：<a href="https://blog.csdn.net/panweiwei1994/article/details/78046000" target="_blank" rel="external">Java8 I/O源码-目录</a></li>
<li>skywang12345：<a href="https://www.cnblogs.com/skywang12345/category/455711.html" target="_blank" rel="external">Java I/O系列</a> </li>
</ul>
<h1 id="PipedReader，PipedWriter"><a href="#PipedReader，PipedWriter" class="headerlink" title="PipedReader，PipedWriter"></a>PipedReader，PipedWriter</h1><p>PipedReader与PipedInputStream极其相似，PipedWriter与PipedOutputStream也极其相似。</p>
<p>PipedReader与PipedWriter分别为字符管道输入流和字符管道输出流。管道输入流通过连接到管道输出流实现了类似管道的功能，用于线程之间的通信。</p>
<a id="more"></a>
<p>通常，由某个线程向管道输出流中写入数据。根据管道的特性，这些数据会<strong>自动发送</strong>到与管道输出流对应的管道输入流中。这时其他线程就可以从管道输入流中读取数据，这样就实现了线程之间的通信。</p>
<p>PipedReader为字符管道输入流，用于读取对应的字符管道输出流写入其内置字符缓存数组buffer中的字符、借此来实现线程之间的通信。</p>
<p>PipedWriter为字符管道输出流、用于将当前线程的指定字符写入到与此线程对应的管道字符输入流中。</p>
<h2 id="PipedReader"><a href="#PipedReader" class="headerlink" title="PipedReader"></a>PipedReader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedReader</span> <span class="keyword">extends</span> <span class="title">Reader</span> </span>&#123;</div><div class="line">    <span class="comment">//管道输出流是否关闭</span></div><div class="line">    <span class="keyword">boolean</span> closedByWriter = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//管道输入流是否关闭</span></div><div class="line">    <span class="keyword">boolean</span> closedByReader = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//管道输入流是否被连接</span></div><div class="line">    <span class="keyword">boolean</span> connected = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">//从管道中读取数据的线程</span></div><div class="line">    Thread readSide;</div><div class="line">    <span class="comment">//向管道中写入数据的线程</span></div><div class="line">    Thread writeSide;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 管道循环输入缓冲区的默认大小。</div><div class="line">    */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PIPE_SIZE = <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 放置数据的循环缓冲区。</div><div class="line">     */</div><div class="line">    <span class="keyword">char</span> buffer[];</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 缓冲区的位置，当从连接的管道输出流中接收到下一个数据字符时，会将其存储到该位置。</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> in = -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 缓冲区的位置，此管道输入流将从该位置读取下一个数据字节。</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> out = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建PipedReader，并指定其对应的PipedWriter。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PipedReader</span><span class="params">(PipedWriter src)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">this</span>(src, DEFAULT_PIPE_SIZE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建一个PipedReader，使其连接到管道输出流src，并指定管道大小为pipeSize。</div><div class="line">     * <span class="doctag">@since</span>      1.6</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PipedReader</span><span class="params">(PipedWriter src, <span class="keyword">int</span> pipeSize)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        initPipe(pipeSize);</div><div class="line">        connect(src);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建尚未连接的PipedReader。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PipedReader</span><span class="params">()</span> </span>&#123;</div><div class="line">        initPipe(DEFAULT_PIPE_SIZE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建一个尚未连接的PipedReader，并指定管道大小为pipeSize。</div><div class="line">     * <span class="doctag">@since</span>      1.6</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PipedReader</span><span class="params">(<span class="keyword">int</span> pipeSize)</span> </span>&#123;</div><div class="line">        initPipe(pipeSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于Piped系列的字符字节输入输出流，刚开始对其中的in和out两个变量还不太明白。第二遍刷类似的内容，果然一目了然</p>
<h3 id="receive，"><a href="#receive，" class="headerlink" title="receive，"></a>receive，</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 接收一个字符，将其插入到缓冲区。如果没有可用的输入，方法会阻塞。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">//检查PipedReader的状态是否正常。</span></div><div class="line">    <span class="keyword">if</span> (!connected) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closedByWriter || closedByReader) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readSide != <span class="keyword">null</span> &amp;&amp; !readSide.isAlive()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Read end dead"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">///获取将数据写入管道的线程，状态设置</span></div><div class="line">    writeSide = Thread.currentThread();</div><div class="line">    <span class="comment">// 如果被写入管道的数据刚好被读完 或者</span></div><div class="line">    <span class="comment">// 管道已经被塞满 两种情况</span></div><div class="line">    <span class="keyword">while</span> (in == out) &#123;</div><div class="line">        <span class="keyword">if</span> ((readSide != <span class="keyword">null</span>) &amp;&amp; !readSide.isAlive()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe broken"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* full: kick any waiting readers */</span></div><div class="line">        <span class="comment">// 不分作用线程的情况直接唤醒一个跑，能跑通的跑就行</span></div><div class="line">        notifyAll();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            wait(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InterruptedIOException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//？？？</span></div><div class="line">    <span class="keyword">if</span> (in &lt; <span class="number">0</span>) &#123;</div><div class="line">        in = <span class="number">0</span>;</div><div class="line">        out = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//将数据字节写入到缓冲区中</span></div><div class="line">    buffer[in++] = (<span class="keyword">char</span>) c;</div><div class="line">    <span class="comment">//如果in已经超出了缓冲区的范围，将in置为0，从头开始写</span></div><div class="line">    <span class="keyword">if</span> (in &gt;= buffer.length) &#123;</div><div class="line">        in = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于函数中notifyAll()函数调用的解释：</p>
<p>因为该输入输出流就是供多线程数据交换使用，可能此时锁外挂着一堆读写线程。全部唤醒，因为无论这两种情况的哪一种不分线程是谁哪个能跑下去让它跑就行，跑不了的全部wait 1秒。</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>对于这种处理方式的==疑问==：</p>
<p>虽然程序肯定会自己调通，但是不懂的是应该这样效率很差，为什么不用ReentrantLock解决。分成两种锁控制，根据不同的条件来控制作用线程的执行？难道是因为无法判断此时缓冲池是满还是空？(自己想了想好像是无法判断) 那新问题就是为什么不新加一个volatile变量控制当前线程的前一次作用缓冲池的线程是writeSide还是readSide？</p>
<h3 id="receivedLast，read，close"><a href="#receivedLast，read，close" class="headerlink" title="receivedLast，read，close"></a>receivedLast，read，close</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 管道输出流关闭时（PipedWriter.close()中会调用此方法），通知其已经关闭。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receivedLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    closedByWriter = <span class="keyword">true</span>;</div><div class="line">    notifyAll();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 将最多len个数据字节从此管道输入流读入char数组。</div><div class="line"> * </div><div class="line"> * 如果已到达数据流的末尾，或者len超出管道缓冲区大小，则读取的字符数将少于len。</div><div class="line"> * </div><div class="line"> * 如果len为0，则不读取任何字节并返回0；</div><div class="line"> * 否则，在至少1个输入字符可用、检测到流末尾、抛出异常前，该方法将一直阻塞。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span>  <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// 状态判断</span></div><div class="line">    <span class="keyword">if</span> (!connected) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe not connected"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closedByReader) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (writeSide != <span class="keyword">null</span> &amp;&amp; !writeSide.isAlive()</div><div class="line">               &amp;&amp; !closedByWriter &amp;&amp; (in &lt; <span class="number">0</span>)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Write end dead"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 参数判断</span></div><div class="line">    <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; cbuf.length) || (len &lt; <span class="number">0</span>) ||</div><div class="line">        ((off + len) &gt; cbuf.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 特殊情况判断</span></div><div class="line">    <span class="comment">/* possibly wait on the first character */</span></div><div class="line">    <span class="keyword">int</span> c = read();</div><div class="line">    <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    cbuf[off] =  (<span class="keyword">char</span>)c;</div><div class="line">    <span class="keyword">int</span> rlen = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> ((in &gt;= <span class="number">0</span>) &amp;&amp; (--len &gt; <span class="number">0</span>)) &#123;</div><div class="line">        cbuf[off + rlen] = buffer[out++];</div><div class="line">        rlen++;</div><div class="line">        <span class="keyword">if</span> (out &gt;= buffer.length) &#123;</div><div class="line">            out = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (in == out) &#123;</div><div class="line">            <span class="comment">/* now empty */</span></div><div class="line">            in = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> rlen;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 关闭此传送流并释放与该流相关的所有系统资源。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    in = -<span class="number">1</span>;</div><div class="line">    closedByReader = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从close的设计可以看出，由于早期设计架构的思考，该类的开发人员明显的清楚，该类对于输入流操作的函数进入与非执行结束退出的关键判断条件是in和closedByReader变量。所以这里只要对其状态进行设置即可。</p>
<h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>写代码一定要像这些大师一样，特别有条理，1、先对该PipedReader类进行状态的判断，2、然后进行输入参数的判断，3、然后进行特殊情况的判断处理，4、进行程序优化。可见目前自己青铜</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>PipedReader和PipedInputStream的几乎一模一样。区别在于PipedReader操作的是字符，PipedInputStream操作的是字节；</li>
<li>PipedReader有ready方法来判断是否可以从PipedReader中读数据，而PipedInputStream则根据available()方法进行判断。</li>
</ul>
<h2 id="PipedWriter"><a href="#PipedWriter" class="headerlink" title="PipedWriter"></a>PipedWriter</h2><h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 刷新此输出流并强制写出所有缓冲的输出字节。</div><div class="line"> * 这将通知所有读取数据的线程，告知它们管道中的字符处于等待中。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sink != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (sink.closedByReader || closed) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Pipe closed"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">synchronized</span> (sink) &#123;</div><div class="line">            sink.notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道sink在PipedWriter类中指的是和其连接的PipedReader对象，也即两者操作的是同一个对象。所以如果PipedReader类的当前对象在进行receive函数或者read函数被wait的时候会挂到该对象的线程等待集合中。此时缓冲池装填可能是满了，也可能空了。</p>
<p>所以当flush被调用时，明确的是该缓冲池中的数据要被读走了。然后唤醒该对象等待队列上的线程即可，无所谓唤醒的是读线程还是写线程，读线程一定可以正常运行下去，因为其进入wait情况的先决条件是<code>in&lt;0</code>很明显这时不可能，相反写线程肯定会继续卡住，因为其进入wait条件的先决条件是<code>in==out</code>很明显这很有可能。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>PipedWriter和PipedOutputStream的几乎一模一样。区别在于PipedReader操作的是字符，PipedInputStream操作的是字节。</li>
</ul>
<h1 id="InputStreamReader，OutputStreamWriter"><a href="#InputStreamReader，OutputStreamWriter" class="headerlink" title="InputStreamReader，OutputStreamWriter"></a>InputStreamReader，OutputStreamWriter</h1><p>InputStreamReader和OutputStreamWriter 是字节流通向字符流的桥梁：它使用指定的 charset 读写字节并将其解码为字符。</p>
<ul>
<li>InputStreamReader 的作用是将“字节输入流”转换成“字符输入流”。它继承于Reader。</li>
<li>OutputStreamWriter 的作用是将“字节输出流”转换成“字符输出流”。它继承于Writer。</li>
</ul>
<h2 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h2><p>由于InputStreamReader类的函数全是依赖其内部声明的StreamDecoder对象来作用的。所以这里我们大概了解一下该类的各个函数的返回结果即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将“字节输入流”转换成“字符输入流”</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReader</span> <span class="keyword">extends</span> <span class="title">Reader</span> </span>&#123;</div><div class="line">    <span class="comment">// InputStreamReader的功能是依赖StreamDecoder完成的</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StreamDecoder sd;</div><div class="line"></div><div class="line">    <span class="comment">// 根据in创建InputStreamReader，使用默认的编码</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(in);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, (String)<span class="keyword">null</span>); <span class="comment">// ## check lock object</span></div><div class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">            <span class="comment">// The default encoding should always be available</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 获取解码器</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEncoding</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sd.getEncoding();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 读取并返回一个字符</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> sd.read();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将InputStreamReader中的数据写入cbuf中，从cbuf的offset位置开始写入，写入长度是length</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> sd.read(cbuf, offset, length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 能否从InputStreamReader中读取数据</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> sd.ready();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 关闭InputStreamReader</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        sd.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>感觉像是给InutStream穿了个外衣。将字节流通过流解码器StreamDecoder，解码成了字符流。</p>
<h2 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h2><p>OutputStreamWriter 作用和原理都与InputStreamReader一模一样。<br>作用就是将“字节输出流”转换成“字符输出流”。它的原理是，我们创建“字符输出流”对象时，会指定“字节输出流”以及“字符编码”。</p>
<h2 id="演示程序"><a href="#演示程序" class="headerlink" title="演示程序"></a>演示程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * InputStreamReader 和 OutputStreamWriter 测试程序</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> skywang</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamConverter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FileName = <span class="string">"file.txt"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CharsetName = <span class="string">"utf-8"</span>;</div><div class="line">    <span class="comment">//private static final String CharsetName = "gb2312";</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        testWrite();</div><div class="line">        testRead();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * OutputStreamWriter 演示函数</div><div class="line">     *</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWrite</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 创建文件“file.txt”对应File对象</span></div><div class="line">            File file = <span class="keyword">new</span> File(FileName);</div><div class="line">            <span class="comment">// 创建FileOutputStream对应OutputStreamWriter：将字节流转换为字符流，即写入out1的数据会自动由字节转换为字符。</span></div><div class="line">            OutputStreamWriter out1 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file), CharsetName);</div><div class="line">            <span class="comment">// 写入10个汉字</span></div><div class="line">            out1.write(<span class="string">"字节流转为字符流示例"</span>);</div><div class="line">            <span class="comment">// 向“文件中”写入"0123456789"+换行符</span></div><div class="line">            out1.write(<span class="string">"0123456789\n"</span>);</div><div class="line"></div><div class="line">            out1.close();</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * InputStreamReader 演示程序</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRead</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 方法1：新建FileInputStream对象</span></div><div class="line">            <span class="comment">// 新建文件“file.txt”对应File对象</span></div><div class="line">            File file = <span class="keyword">new</span> File(FileName);</div><div class="line">            InputStreamReader in1 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file), CharsetName);</div><div class="line"></div><div class="line">            <span class="comment">// 测试read()，从中读取一个字符</span></div><div class="line">            <span class="keyword">char</span> c1 = (<span class="keyword">char</span>)in1.read();</div><div class="line">            System.out.println(<span class="string">"c1="</span>+c1);</div><div class="line"></div><div class="line">            <span class="comment">// 测试skip(long byteCount)，跳过4个字符</span></div><div class="line">            in1.skip(<span class="number">6</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 测试read(char[] cbuf, int off, int len)</span></div><div class="line">            <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</div><div class="line">            in1.read(buf, <span class="number">0</span>, buf.length);</div><div class="line">            System.out.println(<span class="string">"buf="</span>+(<span class="keyword">new</span> String(buf)));</div><div class="line"></div><div class="line">            in1.close();</div><div class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c1=字</div><div class="line">buf=流示例<span class="number">0123456</span></div></pre></td></tr></table></figure></p>
<h3 id="问题1，char为什么能表示中文呢"><a href="#问题1，char为什么能表示中文呢" class="headerlink" title="问题1，char为什么能表示中文呢"></a>问题1，char为什么能表示中文呢</h3><p>看了下面这篇文章很好理解<a href="https://my.oschina.net/u/914655/blog/318664" target="_blank" rel="external">这篇博文</a>。</p>
<p>答：因为java是用unicode字符编码表来对应字符的，”字”这个中文字符的unicode就是2个字节(且所有收录的中文都是2个字节的，本人粗略算了一下2万多个收录了)。且如果其给定的int值范围超过0-65535的范围，如果强制转换<code>（char c = (char)i;</code>）其会自动mod 65536(此处只针对大于)。java会根据该规则自动转换到0-65535区间中的一个。而“字”这个字的unicode编码其实是23383。</p>
<h3 id="问题2，UTF-8方式存储的数据，StreamDecoder类怎么精准算出原数据占几个字节，并还原原始数据"><a href="#问题2，UTF-8方式存储的数据，StreamDecoder类怎么精准算出原数据占几个字节，并还原原始数据" class="headerlink" title="问题2，UTF-8方式存储的数据，StreamDecoder类怎么精准算出原数据占几个字节，并还原原始数据"></a>问题2，UTF-8方式存储的数据，StreamDecoder类怎么精准算出原数据占几个字节，并还原原始数据</h3><p>看了下面这篇阮一峰老师的文章很好理解<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>
<p>答：也就是因为UTF-8方式读取字符的时候可以精准的找到整个字符所占的所有字节呀！这也就是为什么它的中文占3甚至4个字节的原因，因为UTF-8编码方式的每个字节都有标识位，需要耗费一些空间。还是挺好理解的</p>
<h3 id="重点3"><a href="#重点3" class="headerlink" title="重点3"></a>重点3</h3><p>一定要搞懂一件事：</p>
<p>Unicode 是「字符集」<br>UTF-8 是「编码规则」</p>
<p>其中：</p>
<ul>
<li>字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）</li>
<li>编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）</li>
</ul>
<p>参考：<a href="https://www.zhihu.com/question/23374078/answer/24385963" target="_blank" rel="external"><br>邱昊宇的回答</a></p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li>InputStreamReader，字节流通向字符流的桥梁：它使用指定的charset读取字节并将其解码为字符。</li>
<li>每次调用InputStreamReader中的read方法都会导致从底层输入流读取一个或多个字节，然后调用编码转换器将字节转化为字符。为避免频繁调用转换器(StreamDecoder类内部底层调用)，实现从字节到字符的高效转换，可以提前从底层流读取更多的字节。为了达到最高效率，可要考虑在BufferedReader内包装InputStreamReader。</li>
<li>InputStreamReader的功能是依赖于StreamDecoder完成的。</li>
<li>OutputStreamWriter，字符流通向字节流的桥梁：它使用指定的charset将要写入流中的字符编码成字节。</li>
<li>每次调用write()方法都会导致在给定字符（或字符集）上调用编码转换器(StreamEncoder类内部底层调用)。为避免频繁调用转换器，在写入底层输出流之前，可以将得到的这些字节积累在缓冲区。例如，可考虑将OutputStreamWriter包装到BufferedWriter中。</li>
<li>OutputStreamWriter的功能是依赖于StreamEncoder完成的。</li>
</ul>
<h1 id="FileReader，FileWriter"><a href="#FileReader，FileWriter" class="headerlink" title="FileReader，FileWriter"></a>FileReader，FileWriter</h1><ul>
<li>FileReader 是用于读取字符流的类，它继承于InputStreamReader。要读取原始字节流，请考虑使用 FileInputStream。</li>
<li>FileWriter 是用于写入字符流的类，它继承于OutputStreamWriter。要写入原始字节流，请考虑使用 FileOutputStream。</li>
</ul>
<p>需要注意的是该类并非直接继承自Reader，Writer类，而是继承其子类并在其子类基础上进行扩展。</p>
<p>大致看了一下源码，我们可以看出FileReader是基于InputStreamReader实现的。相对的FileWriter是基于OutputStreamWriter实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriter</span> <span class="keyword">extends</span> <span class="title">OutputStreamWriter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileWriter</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> FileOutputStream(fileName));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> <span class="keyword">extends</span> <span class="title">InputStreamReader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> FileInputStream(fileName));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>都是如此。只是几个构造函数参数不同</p>
<h2 id="演示程序-1"><a href="#演示程序-1" class="headerlink" title="演示程序"></a>演示程序</h2><p>FileWriter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建文件“file.txt”对应File对象</span></div><div class="line">File file = <span class="keyword">new</span> File(FileName);</div><div class="line"><span class="comment">// 创建FileOutputStream对应FileWriter：将字节流转换为字符流，即写入out1的数据会自动由字节转换为字符。</span></div><div class="line">FileWriter out1 = <span class="keyword">new</span> FileWriter(file);</div><div class="line"><span class="comment">// 写入10个汉字</span></div><div class="line">out1.write(<span class="string">"字节流转为字符流示例"</span>);</div><div class="line"><span class="comment">// 向“文件中”写入"0123456789"+换行符</span></div><div class="line">out1.write(<span class="string">"0123456789\n"</span>);</div></pre></td></tr></table></figure></p>
<p>FileReader<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 新建文件“file.txt”对应File对象</span></div><div class="line">File file = <span class="keyword">new</span> File(FileName);</div><div class="line">FileReader in1 = <span class="keyword">new</span> FileReader(file);</div><div class="line"></div><div class="line"><span class="comment">// 测试read()，从中读取一个字符</span></div><div class="line"><span class="keyword">char</span> c1 = (<span class="keyword">char</span>)in1.read();</div><div class="line">System.out.println(<span class="string">"c1="</span>+c1);</div><div class="line"></div><div class="line"><span class="comment">// 测试skip(long byteCount)，跳过4个字符</span></div><div class="line">in1.skip(<span class="number">6</span>);</div></pre></td></tr></table></figure></p>
<h1 id="BufferedReader，BufferedWriter"><a href="#BufferedReader，BufferedWriter" class="headerlink" title="BufferedReader，BufferedWriter"></a>BufferedReader，BufferedWriter</h1><p>==注意：== 其实看过其他类的源码后，真正理解了字节，字符输入输出流的作用机制后，就很清楚了，其实BufferedReader比起其他输入流没任何优势，只是他的缓冲池大，所以它缓冲的数据是其他输入流的n倍。也就为其他输入流提供了缓冲作用</p>
<h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><p>BufferedReader，字符缓冲输入流，作用是为其他输入流提供缓冲功能。BufferedReader从其他字符输入流中读取数据内容，缓冲各个字符，从而实现字符、数组和行的高效读取。当通过其read函数读取不到BufferedRead流中的数据时会调用fill()函数读取源输入流的数据来填充BufferedReader缓冲池的数据。</p>
<p>通常，Reader所作的每个读取请求都会导致对底层字符或字节流进行相应的读取请求。因此，建议用BufferedReader包装所有其read()操作可能开销很高的Reader（如FileReader和InputStreamReader）。例如，<br>BufferedReader in = new BufferedReader(new FileReader(“foo.in”));将缓冲指定文件的输入。如果没有缓冲，则每次调用read()或readLine()都会导致从文件中读取字节，并将其转换为字符后返回，而这是极其低效的。而BufferedReader就可以一次性帮我们读更多，从而减少了读的次数，也就减少了字符转化的次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BufferedInputStream</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="问题：提供缓冲为什么能实现字符、数组和行的高效读取？"><a href="#问题：提供缓冲为什么能实现字符、数组和行的高效读取？" class="headerlink" title="问题：提供缓冲为什么能实现字符、数组和行的高效读取？"></a>问题：提供缓冲为什么能实现字符、数组和行的高效读取？</h3><ol>
<li>是提高了读取的效率</li>
<li>是减少了打开存储介质的连接次数。缓冲中的数据实际上是保存在内存中，而原始数据可能是保存在硬盘中。从内存中读取数据的速度比从硬盘读取数据的速度至少快10倍以上。</li>
</ol>
<h3 id="问题：为什么不一次性将Reader中全部数据都读取到缓冲中呢？"><a href="#问题：为什么不一次性将Reader中全部数据都读取到缓冲中呢？" class="headerlink" title="问题：为什么不一次性将Reader中全部数据都读取到缓冲中呢？"></a>问题：为什么不一次性将Reader中全部数据都读取到缓冲中呢？</h3><ol>
<li>读取全部的数据所需要的时间可能会很长。</li>
<li>内存价格很贵，容量远没有硬盘那么大。我们能做的就是在效率和成本之间找到平衡点。大多数情况下，默认值就足够大了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReader</span> <span class="keyword">extends</span> <span class="title">Reader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 底层字符输入流,BufferedReader实际操作的字符输入流</span></div><div class="line">    <span class="keyword">private</span> Reader in;</div><div class="line">    <span class="comment">// 字符缓冲区</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">char</span> cb[];</div><div class="line">    <span class="comment">// nChars是cb字符缓冲区中字符的总的个数</span></div><div class="line">    <span class="comment">// nextChar是下一个要读取的字符在cb缓冲区中的位置</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nChars, nextChar;</div><div class="line">    <span class="comment">// 表示标记无效。设置了标记，但是被标记位置由于某种原因导致标记无效</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVALIDATED = -<span class="number">2</span>;</div><div class="line">    <span class="comment">//表示没有标记</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNMARKED = -<span class="number">1</span>;</div><div class="line">    <span class="comment">//标记位置初始化为UNMARKED</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> markedChar = UNMARKED;</div><div class="line">    <span class="comment">//在仍保留该标记的情况下，对可读取字符数量的限制。</span></div><div class="line">    <span class="comment">//在读取达到或超过此限制的字符后，尝试重置流可能会失败。</span></div><div class="line">    <span class="comment">//限制值大于输入缓冲区的大小将导致分配一个新缓冲区，其大小不小于该限制值。因此应该小心使用较大的值。</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> readAheadLimit = <span class="number">0</span>; <span class="comment">/* Valid only when markedChar &gt; 0 */</span></div><div class="line">    <span class="comment">//表示是否跳过换行符。（skipLF ，skip line feed）</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> skipLF = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//表示当做了标记时，是否忽略换行符。</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> markedSkipLF = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//字符缓冲区默认大小</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> defaultCharBufferSize = <span class="number">8192</span>;</div><div class="line">    <span class="comment">//每行默认的字符个数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> defaultExpectedLineLength = <span class="number">80</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建指定底层字符输入流in和指定字符缓冲区大小sz的BufferedReader</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in, <span class="keyword">int</span> sz)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(in);</div><div class="line">        <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</div><div class="line">        <span class="keyword">this</span>.in = in;</div><div class="line">        cb = <span class="keyword">new</span> <span class="keyword">char</span>[sz];</div><div class="line">        nextChar = nChars = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建指定底层字符输入流in和默认字符缓冲区大小defaultCharBufferSize的BufferedReader</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(in, defaultCharBufferSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="fill，read"><a href="#fill，read" class="headerlink" title="fill，read"></a>fill，read</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 填充缓冲区。</div><div class="line">     * 如果标记有效，要考虑标记。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">//cb中填充数据的起始位置，记录了此次填充时是从缓冲池的什么位置开始填充数据的</span></div><div class="line">        <span class="keyword">int</span> dst;</div><div class="line">        <span class="comment">//如果没有标记，从缓冲区索引为0的位置开始填充</span></div><div class="line">        <span class="comment">//这个if的处理逻辑是填充缓冲池前的原数据加载行为，</span></div><div class="line">        <span class="comment">//即找到缓冲池中原本标记的有效数据，读取readAheadLimit个后，舍弃其他数据。</span></div><div class="line">        <span class="keyword">if</span> (markedChar &lt;= UNMARKED) &#123;</div><div class="line">            dst = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果有标记</span></div><div class="line">            <span class="comment">//delta为标记位置与下个读取字符之间的距离</span></div><div class="line">            <span class="keyword">int</span> delta = nextChar - markedChar;</div><div class="line">            <span class="comment">//如果delta超出readAheadLimit，标记即为无效。</span></div><div class="line">            <span class="keyword">if</span> (delta &gt;= readAheadLimit) &#123; </div><div class="line">                markedChar = INVALIDATED;</div><div class="line">                readAheadLimit = <span class="number">0</span>;</div><div class="line">                dst = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//如果delta没有超出readAheadLimit，即标记有效</span></div><div class="line">                <span class="comment">//且readAheadLimit小于等于缓冲区长度</span></div><div class="line">                <span class="comment">//将markedChar与nextChar之间的字符写入到缓冲区中</span></div><div class="line">                <span class="keyword">if</span> (readAheadLimit &lt;= cb.length) &#123;</div><div class="line">                    <span class="comment">/* Shuffle in the current buffer */</span></div><div class="line">                    System.arraycopy(cb, markedChar, cb, <span class="number">0</span>, delta);</div><div class="line">                    markedChar = <span class="number">0</span>;</div><div class="line">                    dst = delta;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//如果delta没有超出readAheadLimit，即标记有效</span></div><div class="line">                    <span class="comment">//且readAheadLimit大于缓冲区长度</span></div><div class="line">                    <span class="comment">//将重新设置缓冲区大小，markedChar与nextChar之间的字符写入到缓冲区中</span></div><div class="line">                    <span class="keyword">char</span> ncb[] = <span class="keyword">new</span> <span class="keyword">char</span>[readAheadLimit];</div><div class="line">                    <span class="comment">//这里触发的条件是缓冲区已经标记，且标记后读取的规定的字符数要超过计算的个数(nextChar - markedChar)，</span></div><div class="line">                    <span class="comment">//且要读取的个数超过了缓冲区总长度。</span></div><div class="line">                    System.arraycopy(cb, markedChar, ncb, <span class="number">0</span>, delta);</div><div class="line">                    cb = ncb;</div><div class="line">                    markedChar = <span class="number">0</span>;</div><div class="line">                    dst = delta;</div><div class="line">                &#125;</div><div class="line">                nextChar = nChars = delta;</div><div class="line">           &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="comment">//从底层输入流中读取数据，并存储到缓冲区cb中</span></div><div class="line">    <span class="comment">//如果没有读取到数据，就继续读(可能有数据为空的情况)，直到读到数据或者到达流末尾为止(只要不返回-1，就说明没结束)</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        n = in.read(cb, dst, cb.length - dst);</div><div class="line">    &#125; <span class="keyword">while</span> (n == <span class="number">0</span>);</div><div class="line">    <span class="comment">//如果读到了数据</span></div><div class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</div><div class="line">        nChars = dst + n;</div><div class="line">        nextChar = dst;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 读取单个字符。</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span> 作为一个整数（其范围从0到65535( 0x00-0xffff)）返回，如果已到达流末尾，则返回 -1</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        <span class="comment">//确认BufferedReader是否处于开启状态</span></div><div class="line">        ensureOpen();</div><div class="line">        <span class="comment">//？？？什么意义？</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="comment">//如果缓冲区数据已被读完，填充缓冲区。如果填充缓冲区后缓冲区依然是空的，说明已到达流末尾，返回-1。</span></div><div class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars) &#123;</div><div class="line">                fill();</div><div class="line">                <span class="keyword">if</span> (nextChar &gt;= nChars)</div><div class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果skipLF为true，说明要跳过换行符</span></div><div class="line">            <span class="keyword">if</span> (skipLF) &#123;</div><div class="line">                <span class="comment">//说明只作用一次</span></div><div class="line">                skipLF = <span class="keyword">false</span>;</div><div class="line">                <span class="comment">//如果缓冲区内下个字符为换行符，跳过它。</span></div><div class="line">                <span class="keyword">if</span> (cb[nextChar] == <span class="string">'\n'</span>) &#123;</div><div class="line">                    nextChar++;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//返回缓冲区中下个字符，然后nextChar+1</span></div><div class="line">            <span class="keyword">return</span> cb[nextChar++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 从缓冲区中读取数据，写入到cbuf中。off为开始存储字符处的偏移量。len为要读取的最大字符数。</div><div class="line"> * 如有必要，从底层输入流中读取数据。</div><div class="line"> * </div><div class="line"> * 该方法在read(char cbuf[], int off, int len)中被调用</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span>   b     目标字符数组</div><div class="line"> * <span class="doctag">@param</span>   off   开始存储字符处的偏移量</div><div class="line"> * <span class="doctag">@param</span>   len   要读取的最大字符数</div><div class="line"> * <span class="doctag">@return</span>  实际读入cbuf的总字节数，如果由于已到达流末尾而不再有数据，则返回-1。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">read1</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">//如果缓冲区已被读完</span></div><div class="line">    <span class="keyword">if</span> (nextChar &gt;= nChars) &#123;</div><div class="line">        <span class="comment">//如果要读取的长度大于等于缓冲区大小，且没有标记，且不跳过换行符</span></div><div class="line">        <span class="keyword">if</span> (len &gt;= cb.length &amp;&amp; markedChar &lt;= UNMARKED &amp;&amp; !skipLF) &#123;</div><div class="line">            <span class="comment">//直接从底层输入流中读取数据到cbuf中，</span></div><div class="line">            <span class="comment">//？？？这里有个搞不懂的地方，那这样的话那么缓冲区的暂存数据还未被读走不是选择性[跳]着读了吗？</span></div><div class="line">            <span class="keyword">return</span> in.read(cbuf, off, len);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//填充缓冲区</span></div><div class="line">        fill();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果以上步骤执行完后，缓冲区还是没有可读数据，说明已经到达流末尾，返回-1</span></div><div class="line">    <span class="keyword">if</span> (nextChar &gt;= nChars) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="comment">//如果跳过换行符</span></div><div class="line">    <span class="keyword">if</span> (skipLF) &#123;</div><div class="line">        <span class="comment">//说明换行符只不被读一次</span></div><div class="line">        skipLF = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//如果下个字符是换行符</span></div><div class="line">        <span class="keyword">if</span> (cb[nextChar] == <span class="string">'\n'</span>) &#123;</div><div class="line">            <span class="comment">//跳过它</span></div><div class="line">            nextChar++;</div><div class="line">            <span class="comment">//如果缓冲区已被读完，填充缓冲区</span></div><div class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars)</div><div class="line">                fill();</div><div class="line">            <span class="comment">//如果填充缓冲区后，缓冲区依然是空的。说明已经到达流末尾，返回-1</span></div><div class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars)</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果缓冲池中还有数据的话也就不填了，该次读取仅读有的这些</span></div><div class="line">    <span class="comment">// 所以说，如果一个数组过来读没读满的话，不能说明原数据没数据了。</span></div><div class="line">    <span class="keyword">int</span> n = Math.min(len, nChars - nextChar);</div><div class="line">    <span class="comment">//读取</span></div><div class="line">    System.arraycopy(cb, nextChar, cbuf, off, n);</div><div class="line">    <span class="comment">//缓冲区当前位置+n</span></div><div class="line">    nextChar += n;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>==注意== ： 这里带上read1函数的一个主要原因是源码中的设计有个地方不太明白。注释中已经说明</p>
<p>其他地方无论readLine读行还是skip跳字符等，都和之前研究过的BufferedInputStream一样，不一样的只是多了关于换行符的判断。</p>
<h2 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h2><p>BufferedWriter，字符缓冲输出流，作用是为其他输出流提供缓冲功能。BufferedWriter将文本写入其他字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。</p>
<p>通常Writer将其输出立即发送到底层字符或字节流。除非要求提示输出，否则建议用BufferedWriter包装所有其write()操作可能开销很高的 Writer（如FileWriters和OutputStreamWriters）。例如，PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(“foo.out”))); 将缓冲PrintWriter对文件的输出。如果没有缓冲，则每次调用print()方法会导致将字符转换为字节，然后立即写入到文件，而这是极其低效的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BufferedOutputStream</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">        out.write(buf, <span class="number">0</span>, count);<span class="comment">// 一次性向OutPutStream输出更多数据</span></div><div class="line">        count = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="BufferedWriter是如何为其他输出流提供缓冲功能的"><a href="#BufferedWriter是如何为其他输出流提供缓冲功能的" class="headerlink" title="BufferedWriter是如何为其他输出流提供缓冲功能的"></a>BufferedWriter是如何为其他输出流提供缓冲功能的</h3><p>创建BufferedWriter时，我们会通过它的构造函数指定某个底层字符输出流Writer为参数。当程序中每次将单个字符、数组和字符串写入到BufferedWriter中时、都会检查BufferedWriter中的缓存区是否存满，如果没有存满则将字符写入到缓存区中；如果存满，则调用底层的writer(char[] b, int off, int len)将缓存区中的所有字符一次性写入到底层Writer中。</p>
<h3 id="提供缓冲为什么能实现单个字符、数组和字符串的高效写入"><a href="#提供缓冲为什么能实现单个字符、数组和字符串的高效写入" class="headerlink" title="提供缓冲为什么能实现单个字符、数组和字符串的高效写入"></a>提供缓冲为什么能实现单个字符、数组和字符串的高效写入</h3><p>如果没有缓冲，使用底层字符输出流向目的文件中写入单个字符、数组和字符串时，每写入一次就要打开一次到目的文件的连接。这样频繁的访问效率非常底下。比如，将一个非常大的数据写入到目的文件中，如果每写入一个字符就要打开一次到目的文件的连接，可以想象效率是如何低下。</p>
<p>有了缓冲，当使用底层字符输出流向目的文件中写入单个字符、数组和字符串时，将单个字符、数组和字符串先写入到BufferedWriter的内置缓存空间中，然后当达到一定数量时一次性写入Writer流中。此时，Writer就可以打开一次通道，将这个数据块写入到文件中。这样虽然不能达到一次访问就将所有数据写入磁盘中的效果，但也大大提高了效率和减少了对磁盘的访问量。</p>
<h3 id="write，newLine"><a href="#write，newLine" class="headerlink" title="write，newLine"></a>write，newLine</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 写入字符数组的某一部分。</div><div class="line"> * 将字符数组的cbuf中从下标off开始的len个字符写入缓冲区cb中</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        ensureOpen();</div><div class="line">        <span class="comment">//检查参数是否合法</span></div><div class="line">        <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; cbuf.length) || (len &lt; <span class="number">0</span>) ||</div><div class="line">            ((off + len) &gt; cbuf.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//如果cbuf的数据的长度大于等于缓冲区长度</span></div><div class="line">        <span class="keyword">if</span> (len &gt;= nChars) &#123;</div><div class="line">            <span class="comment">//刷新缓冲区，将要写入的数据直接写入到底层输出流中</span></div><div class="line">            flushBuffer();</div><div class="line">            <span class="comment">//Writer抽象类的不同子类实现不同，因为该函数在Writer抽象类中声明的是抽象方法，也就是准备给子类各自去不同实现的</span></div><div class="line">            <span class="comment">//CharArrayWriter的实现方式是如果缓冲池大小小于len则扩容成(缓冲池大小1倍，len大小)两者较大的量。</span></div><div class="line">            <span class="comment">//PipedWriter的实现方式是迭代len次的调用write(int a)，逐个写入</span></div><div class="line">            out.write(cbuf, off, len);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//如果cbuf的数据的长度小于缓冲区长度，将数据写入缓冲区中。</span></div><div class="line">        <span class="keyword">int</span> b = off, t = off + len;</div><div class="line">        <span class="keyword">while</span> (b &lt; t) &#123;</div><div class="line">            <span class="keyword">int</span> d = min(nChars - nextChar, t - b);</div><div class="line">            System.arraycopy(cbuf, b, cb, nextChar, d);</div><div class="line">            b += d;</div><div class="line">            nextChar += d;</div><div class="line">            <span class="comment">//如果写入过程中缓冲区满了，刷新缓冲区，继续将数据写入缓冲区。</span></div><div class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars)</div><div class="line">                flushBuffer();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 写入一个行分隔符。</div><div class="line">     * 行分隔符字符串由系统属性line.separator定义，并且不一定是单个新行('\n')符。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">// 这里写入一个行分隔符，所以当你再写数据的时候，如果操作的是文件</span></div><div class="line">        <span class="comment">// 新数据就会出现在文件另一行。</span></div><div class="line">        write(lineSeparator);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里写上write函数的原因是方法中<code>out.write(cbuf, off, len);</code>这句曾困扰我一会儿，突然想不通当<code>len &gt;= nChars</code>时具体他会怎么操作了。</p>
<p>后来想明白了，还操作个啥，BufferedWriter才不会管，让实际操作的<em>*</em>Writer输入流自己去处理去，因为本身该方法在抽象父类Writer中就是抽象函数，也就是任意Writer的非抽象子类都必须重写。所以它根本必须要管，也没权利管。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>BufferedReader，字符缓冲输入流，作用是为其他输入流提供缓冲功能。BufferedReader从其他字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。</li>
<li>BufferedReader支持标记功能。</li>
<li>BufferedWriter，字符缓冲输出流，作用是为其他输出流提供缓冲功能。BufferedWriter将文本写入其他字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。</li>
</ul>
<h1 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h1><p>PrintWriter 是字符类型的打印输出流，它继承于Writer。</p>
<p>PrintStream 用于向文本输出流打印对象的格式化表示形式。它实现在 PrintStream 中的所有 print 方法。它不包含用于写入原始字节的方法，对于这些字节，程序应该使用未编码的字节流进行写入。</p>
<p>==需要注意的是==，该类和其对应的字节输出流的自动刷新功能不同，它只有在调用printf，及println函数的时候才会自动刷新。这一点下面的源码注释中我有写。</p>
<p>PrintWriter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * PrintWriter的底层字符输出流</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> Writer out;</div><div class="line">    <span class="comment">//是否自动刷新。</span></div><div class="line">    <span class="comment">//如果为true，每次执行printf()[format函数的原因], </span></div><div class="line">    <span class="comment">// println()[newLine函数的原因]函数，都会调用flush()函数。</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> autoFlush;</div><div class="line">    <span class="comment">//是否有异常</span></div><div class="line">    <span class="comment">//当PrintWriter有异常产生时，会被本身捕获，并设置trouble为true</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> trouble = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//用于格式化字符串的对象</span></div><div class="line">    <span class="keyword">private</span> Formatter formatter;</div><div class="line">    <span class="comment">//字节打印流</span></div><div class="line">    <span class="comment">//用于checkError方法</span></div><div class="line">    <span class="keyword">private</span> PrintStream psOut = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 行分隔符</div><div class="line">     * 在PrintWriter被创建时line.separator属性的值。</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lineSeparator;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回csn(字符集名字)对应的Chaset</div><div class="line">     * csn为null或是不支持的字符集，抛出异常</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Charset <span class="title">toCharset</span><span class="params">(String csn)</span></span></div><div class="line">        <span class="keyword">throws</span> UnsupportedEncodingException</div><div class="line">    &#123;</div><div class="line">        Objects.requireNonNull(csn, <span class="string">"charsetName"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> Charset.forName(csn);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalCharsetNameException|UnsupportedCharsetException unused) &#123;</div><div class="line">            <span class="comment">// UnsupportedEncodingException should be thrown</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedEncodingException(csn);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建新的PrintWriter。</div><div class="line">     * 指定底层输出流，默认不会自动flush，采用默认字符集</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span> <span class="params">(Writer out)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(out, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建新的PrintWriter。</div><div class="line">     * 指定底层输出流，指定是否自动flush，采用默认字符集</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(Writer out,</span></span></div><div class="line">                       <span class="keyword">boolean</span> autoFlush) &#123;</div><div class="line">        <span class="keyword">super</span>(out);</div><div class="line">        <span class="keyword">this</span>.out = out;</div><div class="line">        <span class="keyword">this</span>.autoFlush = autoFlush;</div><div class="line">        <span class="comment">//line.separator属性的值</span></div><div class="line">        lineSeparator = java.security.AccessController.doPrivileged(</div><div class="line">            <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"line.separator"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建新的PrintWriter。</div><div class="line">     * 指定底层输出流，不自动flush，采用默认字符集</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(OutputStream out)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(out, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建新的PrintWriter。</div><div class="line">     * 指定底层输出流，指定是否自动flush，采用默认字符集</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(OutputStream out, <span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out)), autoFlush);</div><div class="line"></div><div class="line">        <span class="comment">// save print stream for error propagation</span></div><div class="line">        <span class="keyword">if</span> (out <span class="keyword">instanceof</span> java.io.PrintStream) &#123;</div><div class="line">            psOut = (PrintStream) out;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建新的PrintWriter。</div><div class="line">     * 指定文件名，默认不自动flush，采用默认字符集</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(fileName))),</div><div class="line">             <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 私有构造方法。创建新的PrintWriter。</div><div class="line">     * 指定文件名，默认不自动flush，采用指定字符集</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PrintWriter</span><span class="params">(Charset charset, File file)</span></span></div><div class="line">        <span class="keyword">throws</span> FileNotFoundException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file), charset)),</div><div class="line">             <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建新的PrintWriter。</div><div class="line">     * 指定文件名，默认不自动flush，采用指定字符集</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(String fileName, String csn)</span></span></div><div class="line">        <span class="keyword">throws</span> FileNotFoundException, UnsupportedEncodingException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>(toCharset(csn), <span class="keyword">new</span> File(fileName));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建新的PrintWriter。</div><div class="line">     * 指定文件名，默认不自动flush，采用默认字符集</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file))),</div><div class="line">             <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建新的PrintWriter。</div><div class="line">     * 指定文件名，默认不自动flush，采用指定字符集</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(File file, String csn)</span></span></div><div class="line">        <span class="keyword">throws</span> FileNotFoundException, UnsupportedEncodingException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>(toCharset(csn), file);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>光构造函数就有9个，其实底层用的就只有一个。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(Writer out,<span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(out);</div><div class="line">    <span class="keyword">this</span>.out = out;</div><div class="line">    <span class="keyword">this</span>.autoFlush = autoFlush;</div><div class="line">    lineSeparator = java.security.AccessController.doPrivileged(</div><div class="line">        <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"line.separator"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="checkError，setError，clearError"><a href="#checkError，setError，clearError" class="headerlink" title="checkError，setError，clearError"></a>checkError，setError，clearError</h2><p>该类除构造函数会抛出异常外，其余所有的函数调用均不会抛出异常。在调用时如果抛出异常会被catch掉，然后设置trouble变量为true，并不会显示抛出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 如果流没有关闭，则刷新流且检查其错误状态。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkError</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//如果流没有关闭，则刷新流</span></div><div class="line">    <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</div><div class="line">        flush();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//检查错误状态</span></div><div class="line">    <span class="keyword">if</span> (out <span class="keyword">instanceof</span> java.io.PrintWriter) &#123;</div><div class="line">        PrintWriter pw = (PrintWriter) out;</div><div class="line">        <span class="keyword">return</span> pw.checkError();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (psOut != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> psOut.checkError();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果抛出了异常，返回true</span></div><div class="line">    <span class="keyword">return</span> trouble;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 指示已发生错误。</div><div class="line"> * 在调用clearError()之前，此方法将导致checkError()的后续调用返回 true。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setError</span><span class="params">()</span> </span>&#123;</div><div class="line">    trouble = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 清除此流的错误状态。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">clearError</span><span class="params">()</span> </span>&#123;</div><div class="line">    trouble = <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 写入字符数组。</div><div class="line"> * 此方法不能从Writer类继承，因为它必须取消I/O异常。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> buf[])</span> </span>&#123;</div><div class="line">    write(buf, <span class="number">0</span>, buf.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多时候我们不得不重新自己定义一些函数。因为我们有些原因不能重写父类的函数</p>
<p>其实大多数函数都是直接底层调用，除了会有字符输入输出流特有的安全检查机制ensureOpen对于底层实际操作的输入输出流的<code>null</code>判断外。大部分都是直接调用，然后区别只是catch到异常的时候不再往外抛，而是设置trouble变量为<code>true</code>。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 写入字符串的某一部分。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String s, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            ensureOpen();</div><div class="line">            out.write(s, off, len);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</div><div class="line">        Thread.currentThread().interrupt();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (IOException x) &#123;</div><div class="line">        trouble = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 其实底层调用的就是Formatter类的format方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">printf</span><span class="params">(String format, Object ... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> format(format, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ul>
<li>从构造方法中可以看到，BufferedWriter包装了底层输出流，为其提供了缓冲功能。</li>
<li>此类中的方法不会抛出I/O异常，尽管其某些构造方法可能抛出异常。客户端可能会查询调用checkError()是否出现错误。</li>
<li>print方法可以打印boolean、char 、char[]、double 、float、int、 long、Object、String这些类型。都是按照平台的默认字符串编码将String.valueOf() 方法生成的字符串转换为字节，并完全以write(int)方法的方式向输出流中写入这些字节。</li>
<li>println(type param)方法可以打印boolean、char 、char[]、double 、float、int、 long、Object、String这些类型。都是先调用print方法打印，再调用println()方法换行。</li>
<li>printf方法和format方法的效果是相同的。因为printf方法是依赖于调用format方法实现的。</li>
<li>append方法其实是依赖于out.write方法实现的。</li>
</ul>
<h1 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h1><ul>
<li>RandomAccessFile 是随机访问文件 <strong>(包括读/写)的类</strong>。它支持对文件随机访问的读取和写入，即我们可以从指定的位置读取/写入文件数据。</li>
<li>需要注意的是，RandomAccessFile 虽然属于java.io包，但它不是InputStream或者OutputStream的子类；它也不同于FileInputStream和FileOutputStream。 FileInputStream 只能对文件进行读操作，而FileOutputStream 只能对文件进行写操作；但是，RandomAccessFile 同时支持文件的读和写，并且它支持随机访问。</li>
</ul>
<h2 id="RandomAccessFile-模式说明"><a href="#RandomAccessFile-模式说明" class="headerlink" title="RandomAccessFile 模式说明"></a>RandomAccessFile 模式说明</h2><p>RandomAccessFile共有4种模式：”r”, “rw”, “rws”和”rwd”。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"r"</span>    以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。  </div><div class="line"><span class="string">"rw"</span>   打开以便读取和写入。</div><div class="line"><span class="string">"rws"</span>  打开以便读取和写入。相对于 <span class="string">"rw"</span>，<span class="string">"rws"</span> 还要求对“文件的内容”或“元数据”的每个更新都同步写入到基础存储设备。 这里的s是<span class="keyword">synchronized</span>的意思</div><div class="line"><span class="string">"rwd"</span>  打开以便读取和写入，相对于 <span class="string">"rw"</span>，<span class="string">"rwd"</span> 还要求对“文件的内容”的每个更新都同步写入到基础存储设备。  和rws的区别是不包含原数据</div></pre></td></tr></table></figure></p>
<p>==说明：==</p>
<ol>
<li><strong>什么是“元数据”，即metadata？</strong></li>
</ol>
<p>metadata是“关于数据的数据”。在文件系统中，数据被包含在文件和文件夹中；metadata信息包括：“数据是一个文件，一个目录还是一个链接”，“数据的创建时间(简称ctime)”，“最后一次修改时间(简称mtime)”，“数据拥有者”，“数据拥有群组”，“访问权限”等等。<strong>也就是数据的修饰信息，状态信息。而非具体的数据内容</strong></p>
<ol>
<li><strong>“rw”, “rws”, “rwd” 的区别？</strong></li>
</ol>
<ul>
<li>当操作的文件是存储在本地的基础存储设备上时(如硬盘, NandFlash等)，”rws” 或 “rwd”, “rw” 才有区别。</li>
<li>当模式是 “rws” 并且 操作的是基础存储设备上的文件；那么，每次“更改文件内容[如write()写入数据]” 或 “修改文件元数据(如文件的mtime)”时，都会将这些改变同步到基础存储设备上</li>
<li>当模式是 “rwd” 并且 操作的是基础存储设备上的文件；那么，每次“更改文件内容[如write()写入数据]”时，都会将这些改变同步到基础存储设备上。</li>
<li>当模式是 “rw” 并且 操作的是基础存储设备上的文件；那么，关闭文件时，会将“文件内容的修改”同步到基础存储设备上。至于，“更改文件内容”时，是否会立即同步，取决于系统底层实现。</li>
</ul>
<h2 id="作者的演示程序"><a href="#作者的演示程序" class="headerlink" title="作者的演示程序"></a>作者的演示程序</h2><p>还是很好理解的。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line"> * RandomAccessFile 测试程序</div><div class="line"> *</div><div class="line"> * 运行结果(输出如下)：</div><div class="line"> * c1=a</div><div class="line"> * c2=b</div><div class="line"> * buf=9876543210</div><div class="line"> * </div><div class="line"> * 此外,</div><div class="line"> * (01) 在源文件所在目录生成了file.txt。</div><div class="line"> * (02) 注意RandomAccessFile写入boolean, byte, char, int,所占的字符个数。</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> skywang</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFileTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FileName = <span class="string">"file.txt"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 若文件“file.txt”存在，则删除该文件。</span></div><div class="line">        File file = <span class="keyword">new</span> File(FileName);</div><div class="line">        <span class="keyword">if</span> (file.exists())</div><div class="line">            file.delete();</div><div class="line"></div><div class="line">        testCreateWrite();</div><div class="line">        testAppendWrite();</div><div class="line">        testRead();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 若“file.txt”不存在的话，则新建文件，并向文件中写入内容</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCreateWrite</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 创建文件“file.txt”对应File对象</span></div><div class="line">            File file = <span class="keyword">new</span> File(FileName);</div><div class="line">            <span class="comment">// 创建文件“file.txt”对应的RandomAccessFile对象</span></div><div class="line">            RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 向“文件中”写入26个字母+回车</span></div><div class="line">            raf.writeChars(<span class="string">"abcdefghijklmnopqrstuvwxyz\n"</span>);</div><div class="line">            <span class="comment">// 向“文件中”写入"9876543210"+回车</span></div><div class="line">            raf.writeChars(<span class="string">"9876543210\n"</span>);</div><div class="line"></div><div class="line">            raf.close();</div><div class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 向文件末尾追加内容</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAppendWrite</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 创建文件“file.txt”对应File对象</span></div><div class="line">            File file = <span class="keyword">new</span> File(FileName);</div><div class="line">            <span class="comment">// 创建文件“file.txt”对应的RandomAccessFile对象</span></div><div class="line">            RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 获取文件长度</span></div><div class="line">            <span class="keyword">long</span> fileLen = raf.length();</div><div class="line">            <span class="comment">// 将位置定位到“文件末尾”</span></div><div class="line">            raf.seek(fileLen);</div><div class="line"></div><div class="line">            <span class="comment">// 以下向raf文件中写数据  </span></div><div class="line">            raf.writeBoolean(<span class="keyword">true</span>); <span class="comment">// 占1个字节  </span></div><div class="line">            raf.writeByte(<span class="number">0x41</span>);    <span class="comment">// 占1个字节  </span></div><div class="line">            raf.writeChar(<span class="string">'a'</span>);     <span class="comment">// 占2个字节  </span></div><div class="line">            raf.writeShort(<span class="number">0x3c3c</span>); <span class="comment">// 占2个字节  </span></div><div class="line">            raf.writeInt(<span class="number">0x75</span>);     <span class="comment">// 占4个字节  </span></div><div class="line">            raf.writeLong(<span class="number">0x1234567890123456L</span>); <span class="comment">// 占8个字节  </span></div><div class="line">            raf.writeFloat(<span class="number">4.7f</span>);  <span class="comment">// 占4个字节  </span></div><div class="line">            raf.writeDouble(<span class="number">8.256</span>);<span class="comment">// 占8个字节  </span></div><div class="line">            raf.writeUTF(<span class="string">"UTF严"</span>); <span class="comment">// UTF-8格式写入</span></div><div class="line">            raf.writeChar(<span class="string">'\n'</span>);   <span class="comment">// 占2个字符。“换行符”</span></div><div class="line"></div><div class="line">            raf.close();</div><div class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 通过RandomAccessFile读取文件</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRead</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 创建文件“file.txt”对应File对象</span></div><div class="line">            File file = <span class="keyword">new</span> File(FileName);</div><div class="line">            <span class="comment">// 创建文件“file.txt”对应的RandomAccessFile对象，以只读方式打开</span></div><div class="line">            RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 读取一个字符</span></div><div class="line">            <span class="keyword">char</span> c1 = raf.readChar();</div><div class="line">            System.out.println(<span class="string">"c1="</span>+c1);</div><div class="line">            <span class="comment">// 读取一个字符</span></div><div class="line">            <span class="keyword">char</span> c2 = raf.readChar();</div><div class="line">            System.out.println(<span class="string">"c2="</span>+c2);</div><div class="line"></div><div class="line">            <span class="comment">// 跳过54个字节。</span></div><div class="line">            raf.seek(<span class="number">54</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 测试read(byte[] buffer, int byteOffset, int byteCount)</span></div><div class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</div><div class="line">            raf.read(buf, <span class="number">0</span>, buf.length);</div><div class="line">            System.out.println(<span class="string">"buf="</span>+(<span class="keyword">new</span> String(buf)));</div><div class="line"></div><div class="line">            raf.close();</div><div class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;整个系列的文章&lt;strong&gt;全部参考或直接照搬&lt;/strong&gt;下面两位作者的文章，这里只是根据自己需要对原作者的文章梳理的总结，仅给自己日后复习时提供思路，如有读者看到学习时建议移步原作。再次重申并非我所写&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;潘威威：&lt;a href=&quot;https://blog.csdn.net/panweiwei1994/article/details/78046000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java8 I/O源码-目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;skywang12345：&lt;a href=&quot;https://www.cnblogs.com/skywang12345/category/455711.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java I/O系列&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;PipedReader，PipedWriter&quot;&gt;&lt;a href=&quot;#PipedReader，PipedWriter&quot; class=&quot;headerlink&quot; title=&quot;PipedReader，PipedWriter&quot;&gt;&lt;/a&gt;PipedReader，PipedWriter&lt;/h1&gt;&lt;p&gt;PipedReader与PipedInputStream极其相似，PipedWriter与PipedOutputStream也极其相似。&lt;/p&gt;
&lt;p&gt;PipedReader与PipedWriter分别为字符管道输入流和字符管道输出流。管道输入流通过连接到管道输出流实现了类似管道的功能，用于线程之间的通信。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://www.jiyongguang.xin/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java IO源码分析 - Reader，Writer系列（一）</title>
    <link href="http://www.jiyongguang.xin/java-io-sourcecode-ReaderWriter1.html"/>
    <id>http://www.jiyongguang.xin/java-io-sourcecode-ReaderWriter1.html</id>
    <published>2018-10-11T08:40:30.000Z</published>
    <updated>2018-10-11T08:44:38.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>整个系列的文章<strong>全部参考或直接照搬</strong>下面两位作者的文章，这里只是根据自己需要对原作者的文章梳理的总结，仅给自己日后复习时提供思路，如有读者看到学习时建议移步原作。再次重申并非我所写</p>
<ul>
<li>潘威威：<a href="https://blog.csdn.net/panweiwei1994/article/details/78046000" target="_blank" rel="external">Java8 I/O源码-目录</a></li>
<li>skywang12345：<a href="https://www.cnblogs.com/skywang12345/category/455711.html" target="_blank" rel="external">Java I/O系列</a> </li>
</ul>
<h1 id="助于理解"><a href="#助于理解" class="headerlink" title="助于理解"></a>助于理解</h1><p>需要铭记的就是，字符输入输出流，最终我们都只是在操作各字符输入输出流中的char数组。所以它才叫字符输入输出流。各种不同类型的字符输入输出流在构造时需要传入的对象也是Reader和Writer而不可能是InputStream和OutputStream。</p>
<p>字符输入流操控字符，字节输入流操控字节。一定要搞清楚这一点。</p>
<a id="more"></a>
<h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><p>File 是“文件”和“目录路径名”的抽象表示形式。</p>
<p>File 直接继承于Object，实现了Serializable接口和Comparable接口。实现Serializable接口，意味着File对象支持序列化操作。而实现Comparable接口，意味着File对象之间可以比较大小；File能直接被存储在有序集合(如TreeSet、TreeMap中)。</p>
<p>File类源码分析，在分析File类源码的时候很多地方引用到了抽象类FileSystem的函数，而File类默认FileSystem的默认实例是WinNTFileSystem类。即Windows平台的文件系统对象，应该是我们下载时Java官方根据我们请求的主机来反回了不同jdk。</p>
<p>由于扯到了WinNTFileSystem这个类，所以对于File类的函数，只要知道结果和File层异常抛出情况即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">File</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">     <span class="comment">// 代表所在平台的文件系统对象</span></div><div class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FileSystem fs = DefaultFileSystem.getFileSystem();</div><div class="line">     <span class="comment">// 文件路径名</span></div><div class="line">     <span class="keyword">private</span> <span class="keyword">final</span> String path;</div><div class="line">     <span class="comment">// 内联枚举类,地址是否合法</span></div><div class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> PathStatus &#123; INVALID, CHECKED &#125;;</div><div class="line">     <span class="comment">// 指示文件路径是否无效的标志</span></div><div class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> PathStatus status = <span class="keyword">null</span>;</div><div class="line">     <span class="comment">// 路径前缀的长度</span></div><div class="line">     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">int</span> prefixLength;</div><div class="line">     <span class="comment">// 分隔符，分隔同一个路径字符串中的目录的</span></div><div class="line">     <span class="comment">// UNIX systems is '/' | Microsoft is '\\'</span></div><div class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> separatorChar = fs.getSeparator();</div><div class="line">     <span class="comment">// 分隔符</span></div><div class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String separator = <span class="string">""</span> + separatorChar;</div><div class="line">     <span class="comment">// 路径分割符,分隔连续多个路径字符串的分隔符。</span></div><div class="line">     <span class="comment">// UNIX systems this character is ':' | on Microsoft Windows systems it is ';'</span></div><div class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> pathSeparatorChar = fs.getPathSeparator();</div><div class="line">     <span class="comment">// 路径分割符</span></div><div class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String pathSeparator = <span class="string">""</span> + pathSeparatorChar;</div><div class="line">     </div><div class="line">     <span class="comment">//根据 parent 父路径和 child 子路径名字符串创建一个新 File 实例</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parent, String child)</span> </span>&#123;<span class="comment">// this.path，this.prefixLength</span></div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">//通过将给定路径字符串转换为抽象路径名来创建一个新 File 实例。</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span> </span>&#123;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">// 根据 parent 父路径名字符串和 child 子路径名字符串创建一个新 File 实例。</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent, String child)</span> </span>&#123;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">// 通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例。</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(URI uri)</span> </span>&#123;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看完File类的成员变量后，我们大致了解了File类有哪些信息供直接表示，以及File类的所有构造函数并没有真正的构造File对象，<strong>都</strong>是先初始化了path，prefixLength两个成员变量。</p>
<h2 id="File类函数列表即释义"><a href="#File类函数列表即释义" class="headerlink" title="File类函数列表即释义"></a>File类函数列表即释义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 成员函数</span></div><div class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">canExecute</span><span class="params">()</span>    <span class="comment">// 测试应用程序是否可以执行此抽象路径名表示的文件。</span></span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">canRead</span><span class="params">()</span>       <span class="comment">// 测试应用程序是否可以读取此抽象路径名表示的文件。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">canWrite</span><span class="params">()</span>      <span class="comment">// 测试应用程序是否可以修改此抽象路径名表示的文件。</span></div><div class="line"><span class="keyword">int</span>    <span class="title">compareTo</span><span class="params">(File pathname)</span>    <span class="comment">// 按字母顺序比较两个抽象路径名。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">createNewFile</span><span class="params">()</span>         <span class="comment">// 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。</span></div><div class="line"><span class="keyword">static</span> File    <span class="title">createTempFile</span><span class="params">(String prefix, String suffix)</span>    <span class="comment">// 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。</span></div><div class="line"><span class="keyword">static</span> File    <span class="title">createTempFile</span><span class="params">(String prefix, String suffix, File directory)</span>    <span class="comment">// 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">delete</span><span class="params">()</span>             <span class="comment">// 删除此抽象路径名表示的文件或目录。</span></div><div class="line"><span class="keyword">void</span>    <span class="title">deleteOnExit</span><span class="params">()</span>       <span class="comment">// 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">equals</span><span class="params">(Object obj)</span>   <span class="comment">// 测试此抽象路径名与给定对象是否相等。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">exists</span><span class="params">()</span>             <span class="comment">// 测试此抽象路径名表示的文件或目录是否存在。</span></div><div class="line">File    <span class="title">getAbsoluteFile</span><span class="params">()</span>    <span class="comment">// 返回此抽象路径名的绝对路径名形式。</span></div><div class="line">String    <span class="title">getAbsolutePath</span><span class="params">()</span>    <span class="comment">// 返回此抽象路径名的绝对路径名字符串。</span></div><div class="line">File    <span class="title">getCanonicalFile</span><span class="params">()</span>   <span class="comment">// 返回此抽象路径名的规范形式。</span></div><div class="line">String    <span class="title">getCanonicalPath</span><span class="params">()</span>   <span class="comment">// 返回此抽象路径名的规范路径名字符串。</span></div><div class="line"><span class="keyword">long</span>    <span class="title">getFreeSpace</span><span class="params">()</span>       <span class="comment">// 返回此抽象路径名指定的分区中未分配的字节数。</span></div><div class="line">String    <span class="title">getName</span><span class="params">()</span>            <span class="comment">// 返回由此抽象路径名表示的文件或目录的名称。</span></div><div class="line">String    <span class="title">getParent</span><span class="params">()</span>          <span class="comment">// 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。</span></div><div class="line">File    <span class="title">getParentFile</span><span class="params">()</span>      <span class="comment">// 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。</span></div><div class="line">String    <span class="title">getPath</span><span class="params">()</span>            <span class="comment">// 将此抽象路径名转换为一个路径名字符串。</span></div><div class="line"><span class="keyword">long</span>    <span class="title">getTotalSpace</span><span class="params">()</span>      <span class="comment">// 返回此抽象路径名指定的分区大小。</span></div><div class="line"><span class="keyword">long</span>    <span class="title">getUsableSpace</span><span class="params">()</span>     <span class="comment">// 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。</span></div><div class="line"><span class="keyword">int</span>    <span class="title">hashCode</span><span class="params">()</span>               <span class="comment">// 计算此抽象路径名的哈希码。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">isAbsolute</span><span class="params">()</span>         <span class="comment">// 测试此抽象路径名是否为绝对路径名。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">isDirectory</span><span class="params">()</span>        <span class="comment">// 测试此抽象路径名表示的文件是否是一个目录。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">isFile</span><span class="params">()</span>             <span class="comment">// 测试此抽象路径名表示的文件是否是一个标准文件。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">isHidden</span><span class="params">()</span>           <span class="comment">// 测试此抽象路径名指定的文件是否是一个隐藏文件。</span></div><div class="line"><span class="keyword">long</span>    <span class="title">lastModified</span><span class="params">()</span>       <span class="comment">// 返回此抽象路径名表示的文件最后一次被修改的时间。</span></div><div class="line"><span class="keyword">long</span>    <span class="title">length</span><span class="params">()</span>             <span class="comment">// 返回由此抽象路径名表示的文件的长度。</span></div><div class="line">String[]    <span class="title">list</span><span class="params">()</span>           <span class="comment">// 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。</span></div><div class="line">String[]    <span class="title">list</span><span class="params">(FilenameFilter filter)</span>    <span class="comment">// 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。</span></div><div class="line">File[]    <span class="title">listFiles</span><span class="params">()</span>                        <span class="comment">// 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。</span></div><div class="line">File[]    <span class="title">listFiles</span><span class="params">(FileFilter filter)</span>       <span class="comment">// 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</span></div><div class="line">File[]    <span class="title">listFiles</span><span class="params">(FilenameFilter filter)</span>   <span class="comment">// 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</span></div><div class="line"><span class="keyword">static</span> File[]    <span class="title">listRoots</span><span class="params">()</span>    <span class="comment">// 列出可用的文件系统根。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">mkdir</span><span class="params">()</span>     <span class="comment">// 创建此抽象路径名指定的目录。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">mkdirs</span><span class="params">()</span>    <span class="comment">// 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">renameTo</span><span class="params">(File dest)</span>    <span class="comment">// 重新命名此抽象路径名表示的文件。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">setExecutable</span><span class="params">(<span class="keyword">boolean</span> executable)</span>    <span class="comment">// 设置此抽象路径名所有者执行权限的一个便捷方法。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">setExecutable</span><span class="params">(<span class="keyword">boolean</span> executable, <span class="keyword">boolean</span> ownerOnly)</span>    <span class="comment">// 设置此抽象路径名的所有者或所有用户的执行权限。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">setLastModified</span><span class="params">(<span class="keyword">long</span> time)</span>       <span class="comment">// 设置此抽象路径名指定的文件或目录的最后一次修改时间。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">setReadable</span><span class="params">(<span class="keyword">boolean</span> readable)</span>    <span class="comment">// 设置此抽象路径名所有者读权限的一个便捷方法。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">setReadable</span><span class="params">(<span class="keyword">boolean</span> readable, <span class="keyword">boolean</span> ownerOnly)</span>    <span class="comment">// 设置此抽象路径名的所有者或所有用户的读权限。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">setReadOnly</span><span class="params">()</span>                    <span class="comment">// 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">setWritable</span><span class="params">(<span class="keyword">boolean</span> writable)</span>    <span class="comment">// 设置此抽象路径名所有者写权限的一个便捷方法。</span></div><div class="line"><span class="keyword">boolean</span>    <span class="title">setWritable</span><span class="params">(<span class="keyword">boolean</span> writable, <span class="keyword">boolean</span> ownerOnly)</span>    <span class="comment">// 设置此抽象路径名的所有者或所有用户的写权限。</span></div><div class="line">String    <span class="title">toString</span><span class="params">()</span>    <span class="comment">// 返回此抽象路径名的路径名字符串。</span></div><div class="line">URI    <span class="title">toURI</span><span class="params">()</span>    <span class="comment">// 构造一个表示此抽象路径名的 file: URI。</span></div><div class="line">URL    <span class="title">toURL</span><span class="params">()</span>    <span class="comment">// 已过时。 此方法不会自动转义 URL 中的非法字符。建议新的代码使用以下方式将抽象路径名转换为 URL：首先通过 toURI 方法将其转换为 URI，然后通过 URI.toURL 方法将 URI 装换为 URL。</span></div></pre></td></tr></table></figure>
<h2 id="File类API典型应用"><a href="#File类API典型应用" class="headerlink" title="File类API典型应用"></a>File类API典型应用</h2><h3 id="当前目录的子目录下，再新建一个目录"><a href="#当前目录的子目录下，再新建一个目录" class="headerlink" title="当前目录的子目录下，再新建一个目录"></a>当前目录的子目录下，再新建一个目录</h3><p>例如，我们想要在当前目录的子目录“dir”下，再新建一个子目录。有一下几种方法:</p>
<p>方法1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File sub1 = <span class="keyword">new</span> File(<span class="string">"dir"</span>, <span class="string">"sub1"</span>);</div><div class="line">sub1.mkdir();</div></pre></td></tr></table></figure></p>
<p>说明：上面的方法作用是，在当前目录下 “dir/sub1”。它能正常运行的前提是“sub1”的父目录“dir”已经存在！</p>
<p>方法2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File sub2 = <span class="keyword">new</span> File(dir, <span class="string">"sub2"</span>);</div><div class="line">sub2.mkdir();</div></pre></td></tr></table></figure></p>
<p>说明：上面的方法作用是，在当前目录下 “dir/sub2”。它能正常运行的前提是“sub2”的父目录“dir”已经存在！</p>
<p>方法3<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File sub3 = <span class="keyword">new</span> File(<span class="string">"dir/sub3"</span>);</div><div class="line">sub3.mkdirs();</div></pre></td></tr></table></figure></p>
<p>说明：上面的方法作用是，在当前目录下 “dir/sub3”。它不需要dir已经存在，也能正常运行；若“sub3”的父母路不存在，mkdirs()方法会自动创建父目录。</p>
<h3 id="新建文件的几种常用方法"><a href="#新建文件的几种常用方法" class="headerlink" title="新建文件的几种常用方法"></a>新建文件的几种常用方法</h3><p>例如，我们想要在当前目录的子目录“dir”下，新建一个文件。有一下几种方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    File dir = <span class="keyword">new</span> File(<span class="string">"dir"</span>);    <span class="comment">// 获取目录“dir”对应的File对象</span></div><div class="line">    File file1 = <span class="keyword">new</span> File(dir, <span class="string">"file1.txt"</span>);</div><div class="line">    file1.createNewFile();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明：上面代码作用是，在“dir”目录(相对路径)下新建文件“file1.txt”。</p>
<p>方法2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">"dir"</span>, <span class="string">"file2.txt"</span>);</div><div class="line">    file2.createNewFile();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明：上面代码作用是，在“dir”目录(相对路径)下新建文件“file2.txt”。</p>
<p>方法3<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    File file3 = <span class="keyword">new</span> File(<span class="string">"D:/dir/file4.txt"</span>);</div><div class="line">    file3.createNewFile();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码作用是，下新建文件“D:/dir/file4.txt”(绝对路径)。</p>
<h1 id="FileDescriptor"><a href="#FileDescriptor" class="headerlink" title="FileDescriptor"></a>FileDescriptor</h1><ul>
<li>FileDescriptor 是“文件描述符”。</li>
<li>FileDescriptor 可以被用来表示开放文件、开放套接字等。</li>
<li>以FileDescriptor表示文件来说：<strong>当FileDescriptor表示某文件时，我们可以通俗的将FileDescriptor看成是该文件。但是，我们不能直接通过FileDescriptor对该文件进行操作；若需要通过FileDescriptor对该文件进行操作，则需要新创建FileDescriptor对应的FileOutputStream，再对文件进行操作。</strong></li>
</ul>
<h2 id="in-out-err介绍"><a href="#in-out-err介绍" class="headerlink" title="in, out, err介绍"></a>in, out, err介绍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="number">01</span>) in  -- 标准输入(键盘)的描述符</div><div class="line">(<span class="number">02</span>) out -- 标准输出(屏幕)的描述符</div><div class="line">(<span class="number">03</span>) err -- 标准错误输出(屏幕)的描述符</div></pre></td></tr></table></figure>
<p>它们3个的原理和用法都类似。</p>
<p>out是标准输出(屏幕)的描述符。但是它有什么作用呢？<br>我们可以通俗理解，out就代表了标准输出(屏幕)。若我们要输出信息到屏幕上，即可通过out来进行操作；但是，out又没有提供输出信息到屏幕的接口(因为out本质是FileDescriptor对象，而FileDescriptor没有输出接口)。怎么办呢？<br>很简单，我们创建out对应的“输出流对象”，然后通过“输出流”的write()等输出接口就可以将信息输出到屏幕上。如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(FileDescriptor.out);</div><div class="line">    out.write(<span class="string">'A'</span>);</div><div class="line">    out.close();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行上面的程序，会在屏幕上输出字母’A’。</p>
<p>为了方便我们操作，java早已为我们封装好了“能方便的在屏幕上输出信息的接口”：通过<code>System.out</code>，我们能方便的输出信息到屏幕上。<br>因此，我们可以等价的将上面的程序转换为如下代码：<br><code>System.out.print(&#39;A&#39;)</code>;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FileDescriptor out = standardStream(<span class="number">1</span>);</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FileDescriptor <span class="title">standardStream</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</div><div class="line">    FileDescriptor desc = <span class="keyword">new</span> FileDescriptor();</div><div class="line">    desc.handle = set(fd);</div><div class="line">    <span class="keyword">return</span> desc;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造一个无效的FileDescriptor对象</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="comment">/**/ FileDescriptor() &#123;</span></div><div class="line">    fd = -1;</div><div class="line">    handle = -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于standardStream函数中调用的set函数是JNI，所以我们只能推测默认构造函数生成的FileDescriptor对象是无效的FileDescriptor对象。由此可知要想生成一个有效的FileDescriptor对象只能选择其内部声明好的3个静态域对象。至此我们大致也能猜出set函数应该是对fd变量赋值，并将返回值赋予handle，执行成功那么该返回的对象desc就不再是一个无效的FileDescriptor对象了。</p>
<p>fd对象是非常重要的一个变量，“fd=1”就代表了“标准输出”，“fd=0”就代表了“标准输入”，“fd=2”就代表了“标准错误输出”。</p>
<p>FileOutputStream out = new FileOutputStream(FileDescriptor.out); 就是利用构造函数FileOutputStream(FileDescriptor fdObj)来创建“Filed.out对应的FileOutputStream对象”。</p>
<p>通过上面的学习，我们知道，我们可以自定义标准的文件描述符[即，in(标准输入),out(标准输出),err(标准错误输出)]的流，从而完成输入/输出功能；但是，java已经为我们封装好了相应的接口，即我们可以更方便的System.in, System.out, System.err去使用它们。</p>
<h1 id="FileInputStream，FileOutputStream"><a href="#FileInputStream，FileOutputStream" class="headerlink" title="FileInputStream，FileOutputStream"></a>FileInputStream，FileOutputStream</h1><p><code>FileInputStream</code>是文件输入流，用于从文件系统中的某个文件中获得输入字节。FileInputStream用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用<code>FileReader</code>。</p>
<p><code>FileOutputStream</code>是文件输出流，用于将数据写入<code>File</code>或<code>FileDescriptor</code>的输出流。FileOutputStream用于写入诸如图像数据之类的原始字节的流。要写入字符流，请考虑使用<code>FileWriter</code>。</p>
<h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//打开的文件的文件描述符，负责handle文件</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</div><div class="line">    <span class="comment">//引用文件的路径，null if the stream is created with a file descriptor</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</div><div class="line">    <span class="comment">//文件通道</span></div><div class="line">    <span class="keyword">private</span> FileChannel channel = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//关闭锁</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object closeLock = <span class="keyword">new</span> Object();</div><div class="line">    <span class="comment">//标识流是否关闭</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 根据传入的文件名来创建File对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">        <span class="keyword">this</span>(name != <span class="keyword">null</span> ? <span class="keyword">new</span> File(name) : <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">        <span class="comment">//获取文件名</span></div><div class="line">        String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</div><div class="line">        <span class="comment">//获取安全管理器</span></div><div class="line">        SecurityManager security = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果调用线程没有访问指定文件的权限,抛出SecurityException</span></div><div class="line">            security.checkRead(name);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (file.isInvalid()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//fd表示此文件连接</span></div><div class="line">        fd = <span class="keyword">new</span> FileDescriptor();</div><div class="line">        fd.attach(<span class="keyword">this</span>);</div><div class="line">        path = name;</div><div class="line">        <span class="comment">//打开文件以便读取</span></div><div class="line">        open(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="close，getChannel，getFD，finalize"><a href="#close，getChannel，getFD，finalize" class="headerlink" title="close，getChannel，getFD，finalize"></a>close，getChannel，getFD，finalize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 关闭此文件输入流并释放与此流有关的所有系统资源。</span></div><div class="line"><span class="comment">// 如果此流有一个与之关联的通道，则关闭该通道</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (closeLock) &#123;</div><div class="line">        <span class="keyword">if</span> (closed) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        closed = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果此流有一个与之关联的通道，则关闭该通道。</span></div><div class="line">    <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</div><div class="line">       channel.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fd.closeAll(<span class="keyword">new</span> Closeable() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">           close0();</div><div class="line">       &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回与此文件输入流有关的唯一FileChannel对象。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> FileChannel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</div><div class="line">            channel = FileChannelImpl.open(fd, path, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> channel;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回表示到文件系统中实际文件的连接的FileDescriptor对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileDescriptor <span class="title">getFD</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> fd;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 确保在不再引用文件输入流时调用其close方法。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((fd != <span class="keyword">null</span>) &amp;&amp;  (fd != FileDescriptor.in)) &#123;</div><div class="line">        close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStream</span> <span class="keyword">extends</span> <span class="title">OutputStream</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 文件描述符</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 标识添加还是替换文件的内容</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> append;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 关联的通道</div><div class="line">     * 懒加载</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> FileChannel channel;</div><div class="line">    <span class="comment">//引用文件的路径</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</div><div class="line">    <span class="comment">//锁</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object closeLock = <span class="keyword">new</span> Object();</div><div class="line">    <span class="comment">//标识流是否关闭</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建一个向具有指定name的文件中写入数据的输出文件流。</span></div><div class="line">    <span class="comment">// 如果第二个参数为append为true，则将字节写入文件末尾处，而不是写入文件开始处。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name, <span class="keyword">boolean</span> append)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">        <span class="keyword">this</span>(name != <span class="keyword">null</span> ? <span class="keyword">new</span> File(name) : <span class="keyword">null</span>, append);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建一个向指定文件描述符处写入数据的输出文件流，该文件描述符表示一个到文件系统中的某个实际文件的现有连接。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(FileDescriptor fdObj)</span> </span>&#123;</div><div class="line">        SecurityManager security = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (fdObj == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</div><div class="line">            security.checkWrite(fdObj);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.fd = fdObj;</div><div class="line">        <span class="keyword">this</span>.append = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">this</span>.path = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        fd.attach(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将指定字节写入此文件输出流。</span></div><div class="line"><span class="comment">// append 控制是写到文件尾还是头</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">boolean</span> append)</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure>
<p>可以看出FileOutputStream和FileInputStream的相同功能函数处理逻辑一致。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>FileInputStream是文件输入流，用于从文件系统中的某个文件中获得输入字节。FileInputStream用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用FileReader。</li>
<li>FileOutputStream是文件输出流，用于将数据写入File或FileDescriptor的输出流。FileOutputStream用于写入诸如图像数据之类的原始字节的流。要写入字符流，请考虑使用FileWriter。</li>
<li>Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。</li>
<li>FileInputStream不支持mark方法与set方法。</li>
</ul>
<h1 id="ObjectInputStream，ObjectOutputStream"><a href="#ObjectInputStream，ObjectOutputStream" class="headerlink" title="ObjectInputStream，ObjectOutputStream"></a>ObjectInputStream，ObjectOutputStream</h1><p>ObjectInputStream 和 ObjectOutputStream 的作用是，<strong>对基本数据和对象进行==序列化操作==支持。</strong></p>
<p>创建“文件输出流”对应的ObjectOutputStream对象，该ObjectOutputStream对象能提供对“基本数据或对象”的持久存储；当我们需要读取这些存储的“基本数据或对象”时，可以创建“文件输入流”对应的ObjectInputStream，进而读取出这些“基本数据或对象”。</p>
<p><strong>==注意==</strong>： 只有支持 java.io.Serializable 或 java.io.Externalizable 接口的对象才能被ObjectInputStream/ObjectOutputStream所操作！</p>
<p>头<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStream</span></span></div><div class="line">    <span class="keyword">extends</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">ObjectOutput</span>, <span class="title">ObjectStreamConstants</span> &#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInputStream</span></span></div><div class="line">    <span class="keyword">extends</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">ObjectInput</span>, <span class="title">ObjectStreamConstants</span> &#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>演示程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * ObjectInputStream 和 ObjectOutputStream 测试程序</div><div class="line"> *</div><div class="line"> * 注意：通过ObjectInputStream, ObjectOutputStream操作的对象，必须是实现了Serializable或Externalizable序列化接口的类的实例。</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> skywang</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;   </div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;   </div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;   </div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;   </div><div class="line"><span class="keyword">import</span> java.io.Serializable;   </div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStreamTest</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TMP_FILE = <span class="string">"box.tmp"</span>;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </div><div class="line">        testWrite();</div><div class="line">        testRead();</div><div class="line">    &#125;</div><div class="line">  </div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * ObjectOutputStream 测试函数</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWrite</span><span class="params">()</span> </span>&#123;   </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(</div><div class="line">                    <span class="keyword">new</span> FileOutputStream(TMP_FILE));</div><div class="line">            out.writeBoolean(<span class="keyword">true</span>);</div><div class="line">            out.writeByte((<span class="keyword">byte</span>)<span class="number">65</span>);</div><div class="line">            out.writeChar(<span class="string">'a'</span>);</div><div class="line">            out.writeInt(<span class="number">20131015</span>);</div><div class="line">            out.writeFloat(<span class="number">3.14F</span>);</div><div class="line">            out.writeDouble(<span class="number">1.414</span>D);</div><div class="line">            <span class="comment">// 写入HashMap对象</span></div><div class="line">            HashMap map = <span class="keyword">new</span> HashMap();</div><div class="line">            map.put(<span class="string">"one"</span>, <span class="string">"red"</span>);</div><div class="line">            map.put(<span class="string">"two"</span>, <span class="string">"green"</span>);</div><div class="line">            map.put(<span class="string">"three"</span>, <span class="string">"blue"</span>);</div><div class="line">            out.writeObject(map);</div><div class="line">            <span class="comment">// 写入自定义的Box对象，Box实现了Serializable接口</span></div><div class="line">            Box box = <span class="keyword">new</span> Box(<span class="string">"desk"</span>, <span class="number">80</span>, <span class="number">48</span>);</div><div class="line">            out.writeObject(box);</div><div class="line"></div><div class="line">            out.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">            ex.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * ObjectInputStream 测试函数</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRead</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</div><div class="line">                    <span class="keyword">new</span> FileInputStream(TMP_FILE));</div><div class="line">            System.out.printf(<span class="string">"boolean:%b\n"</span> , in.readBoolean());</div><div class="line">            System.out.printf(<span class="string">"byte:%d\n"</span> , (in.readByte()&amp;<span class="number">0xff</span>));</div><div class="line">            System.out.printf(<span class="string">"char:%c\n"</span> , in.readChar());</div><div class="line">            System.out.printf(<span class="string">"int:%d\n"</span> , in.readInt());</div><div class="line">            System.out.printf(<span class="string">"float:%f\n"</span> , in.readFloat());</div><div class="line">            System.out.printf(<span class="string">"double:%f\n"</span> , in.readDouble());</div><div class="line">            <span class="comment">// 读取HashMap对象</span></div><div class="line">            HashMap map = (HashMap) in.readObject();</div><div class="line">            Iterator iter = map.entrySet().iterator();</div><div class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">                Map.Entry entry = (Map.Entry)iter.next();</div><div class="line">                System.out.printf(<span class="string">"%-6s -- %s\n"</span> , entry.getKey(), entry.getValue());</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 读取Box对象，Box实现了Serializable接口</span></div><div class="line">            Box box = (Box) in.readObject();</div><div class="line">            System.out.println(<span class="string">"box: "</span> + box);</div><div class="line"></div><div class="line">            in.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;   </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height; </div><div class="line">    <span class="keyword">private</span> String name;   </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">(String name, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">        <span class="keyword">this</span>.height = height;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"["</span>+name+<span class="string">": ("</span>+width+<span class="string">", "</span>+height+<span class="string">") ]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span>:<span class="keyword">true</span></div><div class="line"><span class="keyword">byte</span>:<span class="number">65</span></div><div class="line"><span class="keyword">char</span>:a</div><div class="line"><span class="keyword">int</span>:<span class="number">20131015</span></div><div class="line"><span class="keyword">float</span>:<span class="number">3.140000</span></div><div class="line"><span class="keyword">double</span>:<span class="number">1.414000</span></div><div class="line">two    -- green</div><div class="line">one    -- red</div><div class="line">three  -- blue</div><div class="line">box: [desk: (<span class="number">80</span>, <span class="number">48</span>) ]</div></pre></td></tr></table></figure></p>
<p>==再次提示==：通过ObjectInputStream, ObjectOutputStream操作的对象，必须是实现了Serializable或Externalizable序列化接口的类的实例。</p>
<h1 id="字节输入流输出流分析结束"><a href="#字节输入流输出流分析结束" class="headerlink" title="字节输入流输出流分析结束"></a>字节输入流输出流分析结束</h1><h1 id="Reader，Writer"><a href="#Reader，Writer" class="headerlink" title="Reader，Writer"></a>Reader，Writer</h1><p>输入流的抽象类Reader，字符输出流的抽象类Writer。</p>
<h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p>Reader是字符输入流的抽象类。看一下类的结构可以知道，子类必须实现的方法只有<code>read(char[], int, int)</code> 和<code>close()</code>函数。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。<br><img src="http://otsgsfu16.bkt.clouddn.com/18-9-29/63621796.jpg" alt=""></p>
<p>看一下类的签名可知其实现了Readable和Closeable接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">implements</span> <span class="title">Readable</span>和, <span class="title">Closeable</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Readable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(java.nio.CharBuffer cb)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Closeable</span> <span class="keyword">extends</span> <span class="title">AutoCloseable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Reader类成员域<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">implements</span> <span class="title">Readable</span>, <span class="title">Closeable</span> </span>&#123;</div><div class="line">    <span class="comment">//用于同步针对此流的操作的对象。</span></div><div class="line">    <span class="keyword">protected</span> Object lock;</div><div class="line">     <span class="comment">/** Maximum skip-buffer size */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSkipBufferSize = <span class="number">8192</span>;</div><div class="line">    <span class="comment">/** Skip buffer, null until allocated */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">char</span> skipBuffer[] = <span class="keyword">null</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造函数之一</div><div class="line">     * 创建一个新的字符流Reader，其重要部分将同步其自身。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Reader</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lock = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造函数之一</div><div class="line">     * 创建一个新的字符流reader，其重要部分将同步给定的对象lock</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Reader</span><span class="params">(Object lock)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.lock = lock;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="read，skip"><a href="#read，skip" class="headerlink" title="read，skip"></a>read，skip</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 试图将字符读入指定的字符缓冲区。</div><div class="line"> * 缓冲区可照原样用作字符的存储库：所做的唯一改变是put操作的结果。不对缓冲区执行翻转或重绕操作。</div><div class="line"> * 将输入流管道中的target.length个字节读取到指定的缓存字符数组target中、返回实际存放到target中的字符数。 </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(java.nio.CharBuffer target)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">//获取此缓冲区中的剩余空间大小</span></div><div class="line">    <span class="keyword">int</span> len = target.remaining();</div><div class="line">    <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[len];</div><div class="line">    <span class="comment">//试图将输入流中的len个字符读入cbuf，返回实际读取的字节数n</span></div><div class="line">    <span class="keyword">int</span> n = read(cbuf, <span class="number">0</span>, len);</div><div class="line">    <span class="comment">//如果实际读到字符的个数大于0</span></div><div class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</div><div class="line">        <span class="comment">//将实际读取到的n个字符存入缓冲区</span></div><div class="line">        target.put(cbuf, <span class="number">0</span>, n);</div><div class="line">    <span class="comment">//返回实际读取的字符数</span></div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 从输入流中读取单个字符。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">char</span> cb[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span> (read(cb, <span class="number">0</span>, <span class="number">1</span>) == -<span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> cb[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 跳过字符</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  n  要跳过的字符数</div><div class="line"> * <span class="doctag">@return</span>    实际跳过的字符数</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">//如果n为负数，抛出异常</span></div><div class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0L</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"skip value is negative"</span>);</div><div class="line">    <span class="comment">//不允许n大于maxSkipBufferSize</span></div><div class="line">    <span class="keyword">int</span> nn = (<span class="keyword">int</span>) Math.min(n, maxSkipBufferSize);</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        <span class="comment">//如果现有缓冲区为null或者大小小于nn，就新建一个大小为nn的缓冲区</span></div><div class="line">        <span class="keyword">if</span> ((skipBuffer == <span class="keyword">null</span>) || (skipBuffer.length &lt; nn))</div><div class="line">            skipBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[nn];</div><div class="line">        <span class="keyword">long</span> r = n;</div><div class="line">        <span class="comment">//循环跳过输入流中字符，一次尝试跳过nn个字符，直到到达输入流末尾或者n个字符被全部跳过</span></div><div class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> nc = read(skipBuffer, <span class="number">0</span>, (<span class="keyword">int</span>)Math.min(r, nn));</div><div class="line">            <span class="keyword">if</span> (nc == -<span class="number">1</span>)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            r -= nc;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//返回实际跳过的字符数</span></div><div class="line">        <span class="keyword">return</span> n - r;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剩下的函数大部分都需要没有具体实现需要子类重写实现自己的处理逻辑。对于大部分操作Reader抽象类，默认是unsupported的</p>
<h2 id="writer"><a href="#writer" class="headerlink" title="writer"></a>writer</h2><p>Writer是字符输出流的抽象类。子类必须实现的方法仅有 <code>write(char[], int, int)</code>、<code>flush()</code> 和 <code>close()</code>。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-9-29/50616007.jpg" alt=""></p>
<p>从类的结构图可以看出，该类实现了Appendable接口的全部的3个抽象函数。并重写了父类Closeable，Flushable的全部的close，flush函数。但只是再次抽象声明，并没有提供默认实现。任然需要子类重写扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 字符缓存数组。</div><div class="line">     * 用于临时存放要写入字符输出流中的字符</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] writeBuffer;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 字符缓存数组的默认大小。</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITE_BUFFER_SIZE = <span class="number">1024</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用于同步此流的操作的对象。</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> Object lock;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造方法</div><div class="line">     * 创建一个新的字符流writer，其关键部分将同步其自身。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Writer</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lock = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造方法</div><div class="line">     * 建一个新的字符流writer，其关键部分将同步给定的对象。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Writer</span><span class="params">(Object lock)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.lock = lock;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 写入单个字符。</div><div class="line"> * 要写入的字符包含在给定整数值的16个低位中，16高位被忽略。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        <span class="keyword">if</span> (writeBuffer == <span class="keyword">null</span>)&#123;</div><div class="line">            writeBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[WRITE_BUFFER_SIZE];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//char为16位。所以要写入的字符包含在给定整数值的16个低位中，16高位被忽略。</span></div><div class="line">        writeBuffer[<span class="number">0</span>] = (<span class="keyword">char</span>) c;</div><div class="line">        write(writeBuffer, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 试图将字符串中从off开始的len个字符写入输出流中。</span></div><div class="line"><span class="comment">// 尽量写入len个字符，但写入的字节数可能少于len个，也可能为零。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        <span class="keyword">char</span> cbuf[];</div><div class="line">        <span class="keyword">if</span> (len &lt;= WRITE_BUFFER_SIZE) &#123;</div><div class="line">            <span class="keyword">if</span> (writeBuffer == <span class="keyword">null</span>) &#123;</div><div class="line">                writeBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[WRITE_BUFFER_SIZE];</div><div class="line">            &#125;</div><div class="line">            cbuf = writeBuffer;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// Don't permanently allocate very large buffers.</span></div><div class="line">            cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[len];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将字符串中从off开始到off+len的字符复制到cbuf中</span></div><div class="line">        str.getChars(off, (off + len), cbuf, <span class="number">0</span>);</div><div class="line">        <span class="comment">// 将该方法的暂存数组写入到输出流中。</span></div><div class="line">        <span class="comment">// 前面的一系列判断决定了是否使用Writer类给定的默认大小的字符串冲数组// 当大小超出则使用临时新定义的更大的缓冲数组</span></div><div class="line">        write(cbuf, <span class="number">0</span>, len);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加字符序列的一部分</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> Writer <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    CharSequence cs = (csq == <span class="keyword">null</span> ? <span class="string">"null"</span> : csq);</div><div class="line">    write(cs.subSequence(start, end).toString());</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Reader是字符输入流的抽象类。子类必须实现的方法只有read(char[], int, int) 和close()。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。如重写read方法提供更高的效率；重写mark/set方法提供标记功能。</li>
<li>Writer是字符输出流的抽象类。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。</li>
</ul>
<h2 id="Reader与InputStream区别"><a href="#Reader与InputStream区别" class="headerlink" title="Reader与InputStream区别"></a>Reader与InputStream区别</h2><ul>
<li>操作对象的不同。字节流操作字节、字符操作字符。</li>
<li>实现的接口不同。Reader比InputStream多实现了一个Readable接口，用于提供一个可以将字符写入到指定缓存数组的方法。</li>
<li>close方法不同。Reader的close方法是抽象的、子类必须重写，而InputStream则不是(空实现，即不要求子类必须重写)。  InputStream的close方法则不是抽象的。</li>
</ul>
<h2 id="Writer与OutputStream区别"><a href="#Writer与OutputStream区别" class="headerlink" title="Writer与OutputStream区别"></a>Writer与OutputStream区别</h2><ul>
<li>操作对象的不同。字节流操作字节、字符操作字符。</li>
<li>实现的接口不同。Writer相比与OutputStream多实现了一个Appendable接口、用于提供几个向此流中追加字符的方法。</li>
<li>close、flush方法不同。Writer的close、flush方法都是抽象的，而OutputStream则不是(空实现，即不要求子类必须重写)。</li>
</ul>
<h1 id="CharArrayReader，CharArrayWriter"><a href="#CharArrayReader，CharArrayWriter" class="headerlink" title="CharArrayReader，CharArrayWriter"></a>CharArrayReader，CharArrayWriter</h1><ul>
<li>CharArrayReader实现一个可用作字符输入流的字符缓冲区。支持mark/set。</li>
<li>CharArrayWriter实现一个可用作字符输出流的字符缓冲区。缓冲区会随向流中写入数据而自动增长。可使用 toCharArray()和 toString()获取数据。</li>
</ul>
<h2 id="CharArrayReader"><a href="#CharArrayReader" class="headerlink" title="CharArrayReader"></a>CharArrayReader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharArrayReader</span> <span class="keyword">extends</span> <span class="title">Reader</span> </span>&#123;</div><div class="line">    <span class="comment">/** 字符缓冲区 */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">char</span> buf[];</div><div class="line"></div><div class="line">    <span class="comment">/** 缓冲区中下一个被获取的字符的索引 */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> pos;</div><div class="line"></div><div class="line">    <span class="comment">/** 缓冲区中标记的位置. */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> markedPos = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** 字符缓冲区大小 **/</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据指定的char数组创建一个CharArrayReader。</div><div class="line">     * </div><div class="line">     * buf不是复制得到的</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharArrayReader</span><span class="params">(<span class="keyword">char</span> buf[])</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.buf = buf;</div><div class="line">        <span class="keyword">this</span>.pos = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.count = buf.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//  根据指定的char数组创建一个CharArrayReader。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharArrayReader</span><span class="params">(<span class="keyword">char</span> buf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">        <span class="comment">//如果offset为负或大于buf.length，或者length为负，或者这两个值的和为负，抛出IllegalArgumentException。</span></div><div class="line">        <span class="keyword">if</span> ((offset &lt; <span class="number">0</span>) || (offset &gt; buf.length) || (length &lt; <span class="number">0</span>) ||</div><div class="line">            ((offset + length) &lt; <span class="number">0</span>)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.buf = buf;</div><div class="line">        <span class="keyword">this</span>.pos = offset;</div><div class="line">        <span class="comment">//count为length或buf.length-offset其中的较小者</span></div><div class="line">        <span class="keyword">this</span>.count = Math.min(offset + length, buf.length);</div><div class="line">        <span class="keyword">this</span>.markedPos = offset;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ensureOpen，ready，reset"><a href="#ensureOpen，ready，reset" class="headerlink" title="ensureOpen，ready，reset"></a>ensureOpen，ready，reset</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 检查流是否被关闭。若字符缓冲为null，则认为流已关闭。*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (buf == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 读取单个字符。</div><div class="line"> * 如果到达缓冲区末尾，返回-1</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        <span class="comment">// 输入流的打开检测</span></div><div class="line">        ensureOpen();</div><div class="line">        <span class="comment">// 缓冲区容量判断</span></div><div class="line">        <span class="keyword">if</span> (pos &gt;= count)</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> buf[pos++];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 判断此流是否已准备好被读取。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        ensureOpen();</div><div class="line">        <span class="comment">// 缓冲区有数据可读即算准备好</span></div><div class="line">        <span class="keyword">return</span> (count - pos) &gt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 将该流重置为最新的标记。</div><div class="line"> * 如果从未标记过，则将其重置到开头。</div><div class="line"> *</div><div class="line"> * <span class="doctag">@exception</span>  IOException  If an I/O error occurs</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        ensureOpen();</div><div class="line">        pos = markedPos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>==注意：== 从ready函数我们可以总结出，CharArrayRead类相比于InputStream抽象类一派的子类来说性能更高，因为InputStream的子类在对需要加锁操作的方法上的处理是直接在函数签名上添加synchronized来保证的。这样的话锁的就是这个对象，这样对一些没有加锁的方法调用时性能就会很受影响。而这里CharArrayRead类则是使用其内部声明的对象锁来保证的，很好地解决了这个问题。</p>
<p>==注意：== 关于reset函数这里再贴一遍是为了提醒自己，不要忘记markPos变量声明时直接指定其值为0。也就是即便函数并没有调用过mark函数指定标记位置，也没有调用<code>public CharArrayReader(char buf[], int offset, int length) {</code>该多参构造函数构造对象，指定其markPos变量为offset位置。该值也会有默认reset到的位置。</p>
<p>测试程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        charArrayReaderTest();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">charArrayReaderTest</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'j'</span>&#125;;</div><div class="line">        CharArrayReader charArrayReader = <span class="keyword">new</span> CharArrayReader(chars);</div><div class="line"></div><div class="line">        <span class="keyword">char</span>[] container = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (charArrayReader.ready()) &#123;</div><div class="line">                <span class="keyword">char</span> target = (<span class="keyword">char</span>) charArrayReader.read();</div><div class="line">                System.out.println(target);<span class="comment">// a - b</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span> (charArrayReader.markSupported()) &#123;</div><div class="line">                    charArrayReader.mark(<span class="number">0</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                charArrayReader.skip(<span class="number">2</span>);<span class="comment">// - d</span></div><div class="line"></div><div class="line">                <span class="keyword">int</span> containerLoaded = charArrayReader.read(container, <span class="number">0</span>, container.length);</div><div class="line">                System.out.println(containerLoaded);<span class="comment">// 2 - g</span></div><div class="line"></div><div class="line">                charArrayReader.reset(); <span class="comment">// - b</span></div><div class="line"></div><div class="line">                container = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">6</span>];</div><div class="line">                charArrayReader.read(container);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; container.length; i++) &#123;</div><div class="line">                    System.out.println(container[i]);<span class="comment">// b-j</span></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (charArrayReader.ready()) &#123;<span class="comment">// 有没有数据要被读</span></div><div class="line">                    charArrayReader.close();</div><div class="line">                    charArrayReader.read(); <span class="comment">// throw IOException</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            log.error(<span class="string">"buf is null"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">a</div><div class="line"><span class="number">2</span></div><div class="line">b</div><div class="line">c</div><div class="line">d</div><div class="line">e</div><div class="line">f</div><div class="line">g</div><div class="line"><span class="number">15</span>:<span class="number">26</span>:<span class="number">12.561</span> [main] ERROR com.mmall.concurrency.TestController - buf is <span class="keyword">null</span></div></pre></td></tr></table></figure></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>CharArrayReader实现了一个可和字符输入流一样使用的<strong>字符缓冲区</strong>。也就是说，其实CharArrayReader只是一个缓冲区，其数据总量也就是CharArrayReader实例在构造时传入的char数组的大小。<ul>
<li>==有意思的是== 它实现了Reader函数，包装成了输入流的样子，可以供我们以输入流的方式读取其缓冲池中的数据。</li>
<li>==有点儿不懂的是==，还没有给默认的缓冲池，一定要求我们以输入流的方式读取我们给定的char数组中的数据。</li>
</ul>
</li>
<li>在做<strong>所有</strong>操作前，都要确认流处于open状态。判断流处于open状态的依据是buf不为null。close方法中会将buf置为null。</li>
<li>CharArrayReader支持<code>mark()</code>，<code>reset()</code>操作。</li>
</ul>
<h2 id="CharArrayWriter"><a href="#CharArrayWriter" class="headerlink" title="CharArrayWriter"></a>CharArrayWriter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharArrayWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 存储数据的字符缓冲区</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">char</span> buf[];</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 缓冲区中的字符个数</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建一个新的CharArrayWriter。</div><div class="line">     * 缓冲区大小默认为32</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharArrayWriter</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="number">32</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建一个新的CharArrayWriter，指定缓冲区大小为initialSize</div><div class="line">     * 如果initialSize为负数，抛出异常</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharArrayWriter</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialSize &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative initial size: "</span>+ initialSize);</div><div class="line">        &#125;</div><div class="line">        buf = <span class="keyword">new</span> <span class="keyword">char</span>[initialSize];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="write，writeTo，reset，toCharArray"><a href="#write，writeTo，reset，toCharArray" class="headerlink" title="write，writeTo，reset，toCharArray"></a>write，writeTo，reset，toCharArray</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将一个指定字符写到缓冲区中</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        <span class="keyword">int</span> newcount = count + <span class="number">1</span>;</div><div class="line">        <span class="comment">//如果buf存满、则将buf容量扩大1倍、并将原来buf中count字符copy到新的buf中  </span></div><div class="line">        <span class="keyword">if</span> (newcount &gt; buf.length) &#123;</div><div class="line">            buf = Arrays.copyOf(buf, Math.max(buf.length &lt;&lt; <span class="number">1</span>, newcount));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 插入到字符数据缓冲区的数据也尽量不要超过2个字节的表示区，</span></div><div class="line">        <span class="comment">// 否则结果不是你想要的，高16位舍去</span></div><div class="line">        buf[count] = (<span class="keyword">char</span>)c;</div><div class="line">        count = newcount;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 将缓冲区的内容写入另一个字符流out。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(Writer out)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        out.write(buf, <span class="number">0</span>, count);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 重置该缓冲区，以便再次使用它而无需丢弃已分配的缓冲区。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line">    count = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回输入数据的副本。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">toCharArray</span><span class="params">()</span>[] </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        <span class="keyword">return</span> Arrays.copyOf(buf, count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>reset方法和toCharArray设计上行还是很简洁的。该类的flush，close方法无效。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>CharArrayWriter实现了一个可用作字符输出流的字符缓冲区，默认大小32。</li>
<li>CharArrayWriter的缓冲区会随着向流中写入数据的增多而自动增长(动态扩容 系数为1)。</li>
<li>可使用CharArrayWritert的toCharArray()和 toString()获取缓冲区中数据或者writeTo数据传递到另一个Writer流中也行。</li>
<li>CharArrayWriter中close()，flush()方法无效(空实现)。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;整个系列的文章&lt;strong&gt;全部参考或直接照搬&lt;/strong&gt;下面两位作者的文章，这里只是根据自己需要对原作者的文章梳理的总结，仅给自己日后复习时提供思路，如有读者看到学习时建议移步原作。再次重申并非我所写&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;潘威威：&lt;a href=&quot;https://blog.csdn.net/panweiwei1994/article/details/78046000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java8 I/O源码-目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;skywang12345：&lt;a href=&quot;https://www.cnblogs.com/skywang12345/category/455711.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java I/O系列&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;助于理解&quot;&gt;&lt;a href=&quot;#助于理解&quot; class=&quot;headerlink&quot; title=&quot;助于理解&quot;&gt;&lt;/a&gt;助于理解&lt;/h1&gt;&lt;p&gt;需要铭记的就是，字符输入输出流，最终我们都只是在操作各字符输入输出流中的char数组。所以它才叫字符输入输出流。各种不同类型的字符输入输出流在构造时需要传入的对象也是Reader和Writer而不可能是InputStream和OutputStream。&lt;/p&gt;
&lt;p&gt;字符输入流操控字符，字节输入流操控字节。一定要搞清楚这一点。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://www.jiyongguang.xin/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM 快速入门</title>
    <link href="http://www.jiyongguang.xin/java-jvm-1.html"/>
    <id>http://www.jiyongguang.xin/java-jvm-1.html</id>
    <published>2018-10-11T08:36:38.000Z</published>
    <updated>2018-10-11T08:45:36.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>文章整理自 Java3y 的<a href="https://www.jianshu.com/p/904b15a8281f" target="_blank" rel="external">学习JVM是如何从入门到放弃的？</a>一文。</p>
<p>！！！！！！！！！！！！！！！</p>
<p>并非我原创，整理记录只是方便自己查阅温习。如果能帮助到你，我也非常开心。</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>Java默认有三种类加载器：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-5fdead2c4ed39b34?imageMogr2/auto-orient/strip%7CimageView2/2/w/386/format/webp" alt=""></p>
<a id="more"></a>
<p>各个加载器的工作责任：</p>
<ul>
<li>Bootstrap ClassLoader：负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类</li>
<li>Extension ClassLoader：负责加载java平台中<strong>扩展功能</strong>的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包</li>
<li>App ClassLoader：负责加载<strong>classpath</strong>中指定的jar包及目录中class</li>
</ul>
<p><strong>工作过程：</strong></p>
<ol>
<li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li>
<li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li>
<li>如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</li>
<li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载</li>
<li>如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException</li>
</ol>
<p>其实这就是所谓的==双亲委派模型==。简单来说：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。</p>
<p><strong>好处：</strong></p>
<ul>
<li><strong>防止内存中出现多份同样的字节码</strong>(安全性角度)</li>
</ul>
<p><strong>特别说明：</strong></p>
<p>类加载器在成功加载某个类之后，会把得到的 <code>java.lang.Class</code>类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载(所以就不会出现多份同样的类字节码)。</p>
<h1 id="类加载详细过程"><a href="#类加载详细过程" class="headerlink" title="类加载详细过程"></a>类加载详细过程</h1><ol>
<li>加载，查找并加载类的二进制数据，同时在Java堆中也创建一个该类对应的<code>java.lang.Class</code>类对象。</li>
<li>连接，连接又包含三块内容：验证、准备、解析。<ol>
<li>验证：文件格式、元数据、字节码、符号引用验证；</li>
<li>准备：为类的静态变量分配内存，并将其初始化为默认值；</li>
<li>解析：把类中的符号引用转换为直接引用</li>
</ol>
</li>
<li>初始化，为类的静态变量赋予正确的初始值。</li>
</ol>
<p>在类加载检查过程通过后，接下来虚拟机将为新生对象分配内存。</p>
<p>类的生命周期：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-c06a3c88ea043029?imageMogr2/auto-orient/strip%7CimageView2/2/w/694/format/webp" alt=""></p>
<h1 id="JIT即时编辑器"><a href="#JIT即时编辑器" class="headerlink" title="JIT即时编辑器"></a>JIT即时编辑器</h1><p>JVM是这样实现的：</p>
<ul>
<li>就是把这些Java字节码<strong>重新编译优化</strong>，生成机器码，让CPU直接执行。这样编出来的代码效率会更高。</li>
<li>编译也是要花费时间的，我们一般对<strong>热点代码</strong>做编译(JIT即是编译器)，非热点代码直接解析就好了。</li>
</ul>
<blockquote>
<p>热点代码解释：一、多次调用的方法。二、多次执行的循环体</p>
</blockquote>
<p>使用热点探测来检测是否为热点代码，热点探测有两种方式：</p>
<ul>
<li>采样</li>
<li>计数器</li>
</ul>
<p>目前HotSpot使用的是计数器的方式，它为每个方法准备了两类计数器：</p>
<ul>
<li>方法调用计数器（Invocation Counter）</li>
<li>回边计数器（Back EdgeCounter）。</li>
<li>在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，<strong>当计数器超过阈值溢出了，就会触发JIT编译。</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-12b504153edd53a0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""></p>
<h1 id="JVM的运行时数据区"><a href="#JVM的运行时数据区" class="headerlink" title="JVM的运行时数据区"></a>JVM的运行时数据区</h1><p>基于jdk1.8画的JVM的内存模型，<br>这张图的<strong>常量池</strong>是不存在的。指的是class文件中的常量池中的内容。<br><img src="https://upload-images.jianshu.io/upload_images/5291509-6f34ee3b9a188fac?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""></p>
<ul>
<li>堆：<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存</li>
<li>虚拟机栈：虚拟机栈描述的是<strong>Java方法执行的内存模型</strong>：每个方法被执行的时候都会同时创建一个<strong>栈帧</strong>（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息</li>
<li>本地方法栈：和虚拟机栈一致，只不过是为Java的<strong>Native方法服务</strong>。</li>
<li>方法区：存储<strong>已被虚拟机加载的类元数据信息</strong>(元空间)</li>
<li>程序计数器：当前线程所执行的字节码的<strong>行号指示器</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-b4794f35e7adf169?imageMogr2/auto-orient/strip%7CimageView2/2/w/720/format/webp" alt=""></p>
<ul>
<li><a href="https://blog.csdn.net/qq_39470733/article/details/80935743" target="_blank" rel="external">JVM运行时数据区和JMM(Java内存模型)的区别</a></li>
</ul>
<h1 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h1><p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/chenyangyao/p/5296807.html" target="_blank" rel="external">图解JAVA对象的创建过程</a></li>
<li><a href="https://www.jianshu.com/p/904b15a8281f" target="_blank" rel="external">Java3yJVM文章的1.5.2例子中的流程</a></li>
<li><a href="http://www.cnblogs.com/qiumingcheng/p/5398610.html" target="_blank" rel="external">Java程序编译和运行的过程</a></li>
</ul>
<h1 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h1><p>JVM对程序中不需要的对象可以自动进行垃圾回收，但是进行垃圾回收操作前必定有一步判断对象是活着还是已死的步骤。常用有两种方式：</p>
<ul>
<li>引用计数法–&gt;这种难以解决对象之间的循环引用的问题</li>
<li>可达性分析算法–&gt;主流的JVM采用的是这种方式</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-c304206b698ce953?imageMogr2/auto-orient/strip%7CimageView2/2/w/808/format/webp" alt=""></p>
<p>判断了哪些对象是死亡对象后就可以对这些死亡对象进行垃圾回收了。对于JMM中的垃圾对象来说，不同区域的对象死亡的快慢不同，回收的方式也是有讲究的。如果一个区域的对象，你知道程序从头到尾他都不会死亡，你还一直扫描他对他垃圾回收毫无疑问效率是极其低的。</p>
<p>所以垃圾回收也有好几种算法：</p>
<ul>
<li>标记-清除算法(老年代)</li>
<li>复制算法(新生代)</li>
<li>标记-整理算法(老年代)</li>
<li>分代收集算法</li>
</ul>
<p>无论是可达性分析算法，还是垃圾回收算法，JVM使用的都是<strong>准确式GC。</strong> JVM是使用一组称为<strong>OopMap的数据结构</strong>，来存储所有的对象<strong>引用</strong>(这样就不用遍历整个内存去查找了，<strong>空间换时间</strong>)。<br>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举（可达性分析）。</p>
<p>上面所讲的垃圾收集算法只能算是<strong>方法论</strong>，落地实现的是<strong>垃圾收集器</strong>：</p>
<ul>
<li>Serial收集器</li>
<li>ParNew收集器</li>
<li>Parallel Scavenge收集器</li>
<li>Serial Old收集器</li>
<li>Parallel Old收集器</li>
<li>CMS收集器</li>
<li>G1收集器</li>
</ul>
<p>上面这些收集器大部分是可以互相<strong>组合使用</strong>的</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-4db5143c6b5b4cc4?imageMogr2/auto-orient/strip%7CimageView2/2/w/719/format/webp" alt=""></p>
<h1 id="JVM参数与调优"><a href="#JVM参数与调优" class="headerlink" title="JVM参数与调优"></a>JVM参数与调优</h1><ul>
<li><a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html" target="_blank" rel="external">JVM系列三:JVM参数设置、分析</a></li>
</ul>
<h1 id="JVM面试题"><a href="#JVM面试题" class="headerlink" title="JVM面试题"></a>JVM面试题</h1><ol>
<li>详细jvm内存模型</li>
<li>讲讲什么情况下回出现内存溢出，内存泄漏？</li>
<li>说说Java线程栈</li>
<li>JVM 年轻代到年老代的晋升过程的判断条件是什么呢？</li>
<li>JVM 出现 fullGC 很频繁，怎么去线上排查问题？</li>
<li>类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？</li>
<li>类的实例化顺序</li>
<li>JVM垃圾回收机制，何时触发MinorGC等操作</li>
<li>JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的</li>
<li>各种回收器，各自优缺点，重点CMS、G1</li>
<li>各种回收算法</li>
<li>OOM错误，stackoverflow错误，permgen space错误</li>
</ol>
<h2 id="详细jvm内存模型"><a href="#详细jvm内存模型" class="headerlink" title="详细jvm内存模型"></a>详细jvm内存模型</h2><p>jdk1.7以前的PermGen（永久代），jdk1.8替换成Metaspace（元空间）</p>
<ul>
<li>原本永久代存储的数据：符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap</li>
<li>Metaspace（元空间）存储的是类的元数据信息（metadata）</li>
<li>元空间的本质和永久代类似，都是<strong>对JVM规范中方法区的实现</strong>。不过元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存。</strong></li>
<li><strong>替换的好处</strong>：一、字符串存在永久代中，容易出现性能问题和内存溢出。二、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-35502d5d55009f74?imageMogr2/auto-orient/strip%7CimageView2/2/w/589/format/webp" alt=""></p>
<p>图片来源：<a href="https://blog.csdn.net/tophawk/article/details/78704074" target="_blank" rel="external">https://blog.csdn.net/tophawk/article/details/78704074</a></p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="external">https://www.cnblogs.com/paddix/p/5309550.html</a></li>
</ul>
<h2 id="讲讲什么情况下回出现内存溢出，内存泄漏？"><a href="#讲讲什么情况下回出现内存溢出，内存泄漏？" class="headerlink" title="讲讲什么情况下回出现内存溢出，内存泄漏？"></a>讲讲什么情况下回出现内存溢出，内存泄漏？</h2><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>内存泄漏的原因很简单：</p>
<ul>
<li>对象是可达的(一直被引用)</li>
<li>但是对象不会被使用</li>
</ul>
<p>常见的内存泄漏例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Set set = <span class="keyword">new</span> HashSet();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            Object object = <span class="keyword">new</span> Object();</div><div class="line">            set.add(object);</div><div class="line"></div><div class="line">            <span class="comment">// 设置为空，这对象我不再用了</span></div><div class="line">            object = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 但是set集合中还维护这obj的引用，gc不会回收object对象</span></div><div class="line">        System.out.println(set);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>解决这个内存泄漏问题也很简单，将set设置为null，那就可以避免上诉内存泄漏问题了。其他内存泄漏得一步一步分析了。</p>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>内存溢出的原因：</p>
<ul>
<li>内存泄露导致堆栈内存不断增大，从而引发内存溢出。(堆)</li>
<li>大量的jar，class文件加载，装载类的空间不够，溢出。(元空间)</li>
<li>操作大量的对象导致堆内存空间已经用满了，溢出。(老年代)</li>
<li>nio直接操作内存，内存过大导致溢出</li>
</ul>
<p>解决：</p>
<ul>
<li>查看程序是否存在内存泄漏的问题</li>
<li>设置参数加大空间</li>
<li>代码中是否存在死循环或循环产生过多重复的对象实体、</li>
<li>查看是否使用了nio直接操作内存。</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/bingosblog/p/6661527.html" target="_blank" rel="external">java内存溢出的情况解决方法</a></li>
<li><a href="http://www.importnew.com/14604.html" target="_blank" rel="external">Java常见内存溢出异常分析</a></li>
</ul>
<h2 id="说说线程栈"><a href="#说说线程栈" class="headerlink" title="说说线程栈"></a>说说线程栈</h2><p>JVM规范让每个Java线程拥有自己的独立的JVM栈，也就是Java方法的调用栈。</p>
<p>当方法调用的时候，会生成一个栈帧。栈帧是保存在虚拟机栈中的，栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息</p>
<p>线程运行过程中，只有一个栈帧是处于活跃状态，<strong>称为“当前活跃栈帧”</strong>，当前活动栈帧始终是虚拟机栈的<strong>栈顶元素</strong>。</p>
<p>通过jstack工具查看线程状态</p>
<p>参考资料：</p>
<ul>
<li><a href="http://wangwengcn.iteye.com/blog/1622195" target="_blank" rel="external">http://wangwengcn.iteye.com/blog/1622195</a></li>
<li><a href="https://www.cnblogs.com/Codenewbie/p/6184898.html" target="_blank" rel="external">https://www.cnblogs.com/Codenewbie/p/6184898.html</a></li>
<li><a href="https://blog.csdn.net/u011734144/article/details/60965155" target="_blank" rel="external">https://blog.csdn.net/u011734144/article/details/60965155</a></li>
</ul>
<h2 id="JVM-新生代到年老代的晋升过程的判断条件是什么呢？"><a href="#JVM-新生代到年老代的晋升过程的判断条件是什么呢？" class="headerlink" title="JVM 新生代到年老代的晋升过程的判断条件是什么呢？"></a>JVM 新生代到年老代的晋升过程的判断条件是什么呢？</h2><ol>
<li>部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。</li>
<li>如果对象的大小大于Eden的二分之一会直接分配在old，如果old也分配不下，会做一次majorGC，如果小于eden的一半但是没有足够的空间，就进行minorgc也就是新生代GC。</li>
<li>minor gc后，survivor仍然放不下(大对象原本在Eden区存放，当进行一次minorGC的时候存活对象会从Eden区转移到survivorTo区，此时如果survivorTo区存不下转移过来的大对象)，则放到老年代。</li>
<li>动态年龄判断 ，大于等于某个年龄的对象且超过了survivor空间一半 ，或者直接大于等于某个年龄的对象直接进入老年代。</li>
</ol>
<h2 id="JVM-出现-fullGC-很频繁，怎么去线上排查问题"><a href="#JVM-出现-fullGC-很频繁，怎么去线上排查问题" class="headerlink" title="JVM 出现 fullGC 很频繁，怎么去线上排查问题"></a>JVM 出现 fullGC 很频繁，怎么去线上排查问题</h2><p>Full GC触发条件：</p>
<ul>
<li>调用System.gc时，系统建议执行Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的对象平均大小大于老年代的可用内存</li>
<li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/41922036/answer/93079526" target="_blank" rel="external">R大回答 — Major GC和Full GC的区别是什么？触发条件呢？</a></li>
<li><a href="https://blog.csdn.net/YHYR_YCY/article/details/52566105" target="_blank" rel="external">GC详解及Minor GC和Full GC触发条件总结</a></li>
</ul>
<p>这题就依据full GC的触发条件来做：</p>
<ul>
<li>如果有perm gen的话(jdk1.8就没了)，要给perm gen分配空间，但没有足够的空间时，会触发full gc。<ul>
<li>所以看看是不是perm gen区的值设置得太小了。</li>
</ul>
</li>
<li>System.gc()方法的调用</li>
<li>当统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间，则会触发full gc(这就可以从多个角度上看了)<ul>
<li>是不是频繁创建了大对象(也有可能eden区设置过小)(大对象直接分配在老年代中，导致老年代空间不足—&gt;从而频繁gc)</li>
<li>是不是老年代的空间设置过小了(Minor GC几个对象就大于老年代的剩余空间了)</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-926a59e7853f56b8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""></p>
<h2 id="类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？"><a href="#类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？" class="headerlink" title="类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？"></a>类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？</h2><p>双亲委托模型的重要用途是为了解决类载入过程中的<strong>安全性问题。</strong></p>
<ul>
<li>假设有一个开发者自己编写了一个名为java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。</li>
<li>然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它</li>
</ul>
<p>Java的类加载是否一定遵循双亲委托模型？</p>
<ul>
<li>在实际开发中，我们可以通过自定义ClassLoader，并重写父类的loadClass方法，来打破这一机制。</li>
<li>SPI就是打破了双亲委托机制的(SPI：服务提供发现，Service Provider Interface)。SPI资料：<ul>
<li><a href="https://zhuanlan.zhihu.com/p/28909673" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/28909673</a></li>
<li><a href="https://www.cnblogs.com/huzi007/p/6679215.html" target="_blank" rel="external">https://www.cnblogs.com/huzi007/p/6679215.html</a></li>
<li><a href="https://blog.csdn.net/sigangjun/article/details/79071850" target="_blank" rel="external">https://blog.csdn.net/sigangjun/article/details/79071850</a></li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/markzy/article/details/53192993" target="_blank" rel="external">Classloader的双亲委托机制</a></li>
</ul>
<h2 id="类的实例化顺序"><a href="#类的实例化顺序" class="headerlink" title="类的实例化顺序"></a>类的实例化顺序</h2><ol>
<li>父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行</li>
<li>子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行</li>
<li>父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行</li>
<li>父类构造方法</li>
<li>子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行</li>
<li>子类构造方法</li>
</ol>
<p><strong>每一次的 new 都经历了</strong></p>
<ol>
<li>加载: 将 Class 文件读入内存，并为之创建一个 java.lang.Class 对象 </li>
<li>连接: 为静态域分配内存 </li>
<li>初始化: 初始化超类，执行 static </li>
<li>实例化: 创建一个 Object 对象</li>
</ol>
<p><strong>每一次 new 一个对象时都会（都是先父类再子类）</strong></p>
<ol>
<li>如果是第一次 new ，则按顺序执行静态代码块和静态变量（凌驾于所有动态代码块和构造器之上）</li>
<li>按顺序执行动态代码块和动态变量（非 static 的变量都是动态变量）</li>
<li>构造器</li>
</ol>
<p>监测代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dervied</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name = <span class="string">"Java3y"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dervied</span><span class="params">()</span> </span>&#123;</div><div class="line">        tellName();</div><div class="line">        printName();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tellName</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Dervied tell name: "</span> + name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Dervied print name: "</span> + name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Dervied();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name = <span class="string">"公众号"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</div><div class="line">        tellName();</div><div class="line">        printName();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tellName</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Base tell name: "</span> + name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Base print name: "</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Dervied tell name: <span class="keyword">null</span></div><div class="line">Dervied print name: <span class="keyword">null</span></div><div class="line">Dervied tell name: Java3y</div><div class="line">Dervied print name: Java3y</div></pre></td></tr></table></figure></p>
<p>如果父类构造器调用了被子类重写的方法，且通过子类构造函数创建子类对象，调用了这个父类构造器（无论显示还是隐式），就会导致父类在构造时实际上调用的是子类覆盖的方法（你需要了解java继承中的初始化机制）。</p>
<p>==缺点：== 如果在父类构造函数中调用被子类重写的方法，会导致子类重写的方法在子类构造器的所有代码之前执行，从而导致子类重写的方法访问不到子类实例变量的值，因为此时这些变量还没有被初始化。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/wxmdevelop/p/7111019.html" target="_blank" rel="external">java父类调用被子类重写的方法</a></li>
</ul>
<h2 id="JVM垃圾回收机制，何时触发MinorGC等操作"><a href="#JVM垃圾回收机制，何时触发MinorGC等操作" class="headerlink" title="JVM垃圾回收机制，何时触发MinorGC等操作"></a>JVM垃圾回收机制，何时触发MinorGC等操作</h2><p>当young gen中的eden区分配满的时候触发MinorGC(新生代的空间不够放的时候)。</p>
<h2 id="JVM-中一次完整的-GC-流程（从-ygc-到-fgc）是怎样的"><a href="#JVM-中一次完整的-GC-流程（从-ygc-到-fgc）是怎样的" class="headerlink" title="JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的"></a>JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的</h2><blockquote>
<p>YGC和FGC是什么</p>
<ul>
<li>YGC ：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。</li>
<li>FGC ：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。以我们生产环境为例，一般比较少会触发fgc，有时10天或一周左右会有一次。GC的速度比较慢</li>
</ul>
<p>什么时候执行YGC和FGC</p>
<ul>
<li>eden空间不足,执行 young gc</li>
<li>old空间不足，perm空间不足，调用方法System.gc() ，ygc时的悲观策略, dump live的内存信息时(jmap –dump:live)，都会执行full gc</li>
</ul>
</blockquote>
<h2 id="各种回收算法"><a href="#各种回收算法" class="headerlink" title="各种回收算法"></a>各种回收算法</h2><p>GC最基础的算法有三种：</p>
<ul>
<li>标记 -清除算法</li>
<li>复制算法</li>
<li>标记-压缩算法</li>
<li>分代收集算法：我们常用的垃圾回收器一般都采用分代收集算法(其实就是组合上面的算法，不同的区域使用不同的算法)。</li>
</ul>
<p>具体：</p>
<ul>
<li>标记-清除算法：“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先<strong>标记出所有需要回收的对象</strong>，在标记完成后统一回收掉所有被标记的对象。</li>
<li>复制算法，“复制”（Copying）的收集算法，它<strong>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。</strong> 当这一块的内存用完了，就==将<strong>还存活着的对象</strong>复制到另外一块上面==，然后再把已使用过的内存空间一次清理掉。</li>
<li>标记-压缩算法：<strong>标记过程仍然与“标记-清除”算法一样，对所有可回收对象进行标记</strong>，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向内存一端移动</strong>，然后直接清理掉<strong>端边界</strong>以外的内存</li>
<li>分代收集算法，“分代收集”（Generational Collection）算法，<strong>把Java堆分为新生代和老年代</strong>，这样就可以根据各个年代的特点采用最适当的收集算法。</li>
</ul>
<h2 id="各种回收器，各自优缺点，重点CMS、G1"><a href="#各种回收器，各自优缺点，重点CMS、G1" class="headerlink" title="各种回收器，各自优缺点，重点CMS、G1"></a>各种回收器，各自优缺点，重点CMS、G1</h2><p>图中两个收集器之间有连线，说明它们可以配合使用。<br><img src="https://upload-images.jianshu.io/upload_images/5291509-207d8bd2c1b3784e?imageMogr2/auto-orient/strip%7CimageView2/2/w/508/format/webp" alt=""></p>
<ul>
<li>Serial收集器，串行收集器是最古老，<strong>最稳定以及效率高的收集器</strong>，但可能会产生<strong>较长的停顿</strong>，只使用一个线程去回收。</li>
<li>ParNew收集器，ParNew收集器其实就是Serial收集器的<strong>多线程版本</strong>。</li>
<li>Parallel Scavenge收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器<strong>更关注系统的吞吐量</strong>。</li>
<li>Parallel Old收集器，Parallel Old是Parallel Scavenge收集器的<strong>老年代版本</strong>，使用多线程“标记－整理”算法</li>
<li>CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间为目标的收集器</strong>。它需要<strong>消耗额外的CPU和内存资源</strong>，在CPU和内存资源紧张，CPU较少时，会加重系统负担。CMS<strong>无法处理浮动垃圾</strong>。CMS的“标记-清除”算法，会导致大量空间碎片的产生。</li>
<li>G1收集器，G1 (Garbage-First)是一款<strong>面向服务器的垃圾收集器</strong>,主要针对配备多颗处理器及大容量内存的机器. <strong>以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。</strong></li>
</ul>
<h2 id="stackoverflow错误，permgen-space错误"><a href="#stackoverflow错误，permgen-space错误" class="headerlink" title="stackoverflow错误，permgen space错误"></a>stackoverflow错误，permgen space错误</h2><p>stackoverflow错误主要出现：</p>
<ul>
<li>在虚拟机栈中(线程请求的栈深度大于虚拟机栈锁允许的最大深度)</li>
</ul>
<p>permgen space错误(针对jdk之前的1.7版本)：</p>
<ul>
<li>大量加载class文件</li>
<li>常量池内存溢出</li>
</ul>
<p>1.6的时候可能是字符串常量池溢出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h1&gt;&lt;p&gt;文章整理自 Java3y 的&lt;a href=&quot;https://www.jianshu.com/p/904b15a8281f&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;学习JVM是如何从入门到放弃的？&lt;/a&gt;一文。&lt;/p&gt;
&lt;p&gt;！！！！！！！！！！！！！！！&lt;/p&gt;
&lt;p&gt;并非我原创，整理记录只是方便自己查阅温习。如果能帮助到你，我也非常开心。&lt;/p&gt;
&lt;h1 id=&quot;类加载器&quot;&gt;&lt;a href=&quot;#类加载器&quot; class=&quot;headerlink&quot; title=&quot;类加载器&quot;&gt;&lt;/a&gt;类加载器&lt;/h1&gt;&lt;p&gt;Java默认有三种类加载器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5291509-5fdead2c4ed39b34?imageMogr2/auto-orient/strip%7CimageView2/2/w/386/format/webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://www.jiyongguang.xin/categories/JVM/"/>
    
    
      <category term="JVM 学习" scheme="http://www.jiyongguang.xin/tags/JVM-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java编程的逻辑 -- 并发章 -- 线程的中断</title>
    <link href="http://www.jiyongguang.xin/java-concurrentProgramming-readingNotes-15-4.html"/>
    <id>http://www.jiyongguang.xin/java-concurrentProgramming-readingNotes-15-4.html</id>
    <published>2018-06-25T09:43:58.000Z</published>
    <updated>2018-06-25T09:45:04.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h1><p>在Java中，停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，<strong>它是一种协作机制</strong>，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出。本节我们主要就是来理解Java的中断机制</p>
<p>线程中断的三个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean isInterrupted()</div><div class="line">public void interrupt()</div><div class="line">public static boolean interrupted()</div></pre></td></tr></table></figure></p>
<ul>
<li>isInterrupted返回当前线程是否被中断。true/false</li>
<li>interrupted不但具有isInterrupted的共同，同时每次调用还会清空该中断标志位。即某一个线程被中断了第一次调用为true第二次一般就为false。需要注意的是该方法是静态方法，<strong>中断的是正在执行的线程。</strong> 而其他两个方法则是中断this对象指定的线程。</li>
<li>interrupt中断对应线程。</li>
</ul>
<a id="more"></a>
<h1 id="线程不同状态对中断的反应"><a href="#线程不同状态对中断的反应" class="headerlink" title="线程不同状态对中断的反应"></a>线程不同状态对中断的反应</h1><p>interrupt ()对线程的影响与线程的状态和在进行的IO操作有关。我们主要考虑线程的状态，I/O操作的影响和具I/O以及操作系统有关，我们就不讨论了。</p>
<p>线程状态有：</p>
<ul>
<li><strong>RUNNABLE</strong>:线程在运行或具备运行条件只是在等待操作系统调度。</li>
<li><strong>WAITING/TIMED_WAITING</strong>:线程在等待某个条件或超时。</li>
<li><strong>BLOCKED</strong>:线程在等待锁，试图进入同步块。</li>
<li><strong>NEWATERMINATED</strong>:线程还未启动或已结束。</li>
</ul>
<h2 id="1-RUNNABLE"><a href="#1-RUNNABLE" class="headerlink" title="1.RUNNABLE"></a>1.RUNNABLE</h2><p><strong>如果线程在运行中，且没行执行I/O操作</strong>，interrupt()只是会设置线程的中断标忐位，没行任何其他作用。线程应该在运行过程中合适的位置检查中断标志位，比如，<strong>如果主体代码是一个循环，可以在循环开始处进行检查</strong>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class InterruptRunnableDemo extends Thread &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        while(!Thread.currentThread().isInterrupted()) &#123;</div><div class="line">            //…单词循环代码</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;done &quot;);</div><div class="line">    &#125;</div><div class="line">    //其他代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2-WAITING-TIMED-WAITING"><a href="#2-WAITING-TIMED-WAITING" class="headerlink" title="2.WAITING/TIMED_WAITING"></a>2.WAITING/TIMED_WAITING</h2><p>线程调用join/wait/sleep方法会进入<code>WAITING</code>或<code>TIMED_WAITING</code>状态。在对线程对象调用interrupt()后，当线程处于中断状态时，如果再由wait、sleep以及jion三个方法引起的阻塞，那么JVM会将线程的<strong>中断标志重新设置为false</strong>，并抛出一个InterruptedException异常。比如，执行如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Thread t = new Thread ()&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(1000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            System.out.println(isInterrupted());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">t.start();</div><div class="line">try &#123;</div><div class="line">    Thread.sleep(100);// 确保该线程 睡开了</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">&#125;</div><div class="line">t.interrupt();</div></pre></td></tr></table></figure></p>
<p>程序的输出为false。</p>
<p>IntemiptedException是一个受检异常，线程必须进行处理。我们在异常处理中介绍过，处理异常的基本思路是：如果知道怎么处理，就进行处理，如果不知道，就应该向上传递，通常情况下不应该捕获异常然后忽略。</p>
<p>捕获到InterruptedException,通常表示<strong>希望结朿该线程</strong>，线程大致有两种处理方式：</p>
<ol>
<li>向上传递该异常，这使得该方法也变成一个可中断的方法(相当于封装了一下)，需要调用者记性处理。</li>
<li>有些情况，不能向上传递异常，比如 <strong>Thread的run方法，它的声明是固定的，不能 ++<em>抛出</em>++ 任何受检异应该捕获异常，</strong>  进行合适的清理操作，<strong>清理后，一般应该调用Thread的interrupt方法设置中断标志位，使得其他代码有办法知道它发生了中断。</strong></li>
</ol>
<p>第一种示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">对Thread类的sleep方法进行了封装而不是直接在run方法中调用就可以保证interruptedException可以在run方法调用该interruptibleMethod方法时被抛出了。</div><div class="line">public void interruptibleMethod() throws InterruptedException&#123;</div><div class="line">    //…这里可以是wait, join 或者 sleep 方法</div><div class="line">    Thread.sleep(1000);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二种示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class InterruptWaitingDemo extends Thread &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        while(!Thread.currentThread().isInterrupted()) &#123;</div><div class="line">            try &#123;</div><div class="line">                //模拟任务代码</div><div class="line">                Thread.sleep(2000);</div><div class="line">            &#125; catch(InterruptedException e) &#123;</div><div class="line">                //…清理操作</div><div class="line">                //重新设置中断标志位 方便其他代码知道该线程发生了中断</div><div class="line">                Thread.currentThread().interrupt();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(isInterrupted());</div><div class="line">    &#125;</div><div class="line">    //其他代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-BLOCKED"><a href="#3-BLOCKED" class="headerlink" title="3.BLOCKED"></a>3.BLOCKED</h2><p>当线程处于BLOCKED状态等待CPU调度时。调用线程的<strong>interrupt()方法并不能使一个正在等待的线程真正中断。</strong></p>
<h2 id="4-NEW-TERMINATE"><a href="#4-NEW-TERMINATE" class="headerlink" title="4.NEW/TERMINATE"></a>4.NEW/TERMINATE</h2><p>如果线程尚未启动(NEW)，或者已经结束(TERMINATE)，则调用interrupt()方法对其没有任何效果。并且线程的中断标志位也不会被设置。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节主要讲的是如何取消以及关闭线程，主要采用的是中断技术。他是一种协作机制，并不会强制中断线程。并且介绍了线程在不同状态下对于中断操作的反应。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程中断&quot;&gt;&lt;a href=&quot;#线程中断&quot; class=&quot;headerlink&quot; title=&quot;线程中断&quot;&gt;&lt;/a&gt;线程中断&lt;/h1&gt;&lt;p&gt;在Java中，停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，&lt;strong&gt;它是一种协作机制&lt;/strong&gt;，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出。本节我们主要就是来理解Java的中断机制&lt;/p&gt;
&lt;p&gt;线程中断的三个方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;public boolean isInterrupted()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public void interrupt()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public static boolean interrupted()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;isInterrupted返回当前线程是否被中断。true/false&lt;/li&gt;
&lt;li&gt;interrupted不但具有isInterrupted的共同，同时每次调用还会清空该中断标志位。即某一个线程被中断了第一次调用为true第二次一般就为false。需要注意的是该方法是静态方法，&lt;strong&gt;中断的是正在执行的线程。&lt;/strong&gt; 而其他两个方法则是中断this对象指定的线程。&lt;/li&gt;
&lt;li&gt;interrupt中断对应线程。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="并发" scheme="http://www.jiyongguang.xin/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java编程的逻辑 -- 并发章 -- 线程的基本协作机制</title>
    <link href="http://www.jiyongguang.xin/java-concurrentProgramming-readingNotes-15-3.html"/>
    <id>http://www.jiyongguang.xin/java-concurrentProgramming-readingNotes-15-3.html</id>
    <published>2018-06-22T12:20:06.000Z</published>
    <updated>2018-06-22T12:21:13.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的基本协作"><a href="#线程的基本协作" class="headerlink" title="线程的基本协作"></a>线程的基本协作</h1><p>多线程间除了竞争访问同一资源外，也经常需要相互协作的去执行一些任务。而对于协作的基本机制用的最多的无疑是wait/notify。</p>
<h2 id="协作的场景"><a href="#协作的场景" class="headerlink" title="协作的场景"></a>协作的场景</h2><ul>
<li>生产者消费者模式：共享队列，一个负责放一个负责取。如果队列长度有限且满了之后则等待。</li>
<li>同时开始：类似运动员比赛，多个线程同时开始执行。</li>
<li>等待结束：主线程分发给各个子任务去执行任务，主任务开始执行前需要等待各个子任务执行完毕。</li>
<li>异步结果：</li>
<li>集合点</li>
</ul>
<a id="more"></a>
<h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h2><p>wait和notify方法都是Object类提供给所有子类进行线程协作的一种实现机制。</p>
<p>wait:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public final void wait() throws InterruptedException</div><div class="line">public final native void wait(long timeout) throws InterruptedException;</div></pre></td></tr></table></figure></p>
<p>一个带时间参数，表示最多等待这么长时间。<br>一个不带，默认为0，表示无限期等待。</p>
<p>如果在wait的过程中线程被中断，则会抛出InterruptedException。我们在之前关于Thread类的的博文中也提到过这个。</p>
<p><strong>wait在等什么？</strong></p>
<p>我们之前说过的<strong>每个对象都有一把锁和一个等待队列</strong>，一个线程在进入synchronized代码块时，会尝试获取锁，如果获取不到则会把当前线程加入等待队列中，其实，除了对于锁的等待队列，<strong>每个对象还有另一个等待队列，即条件队列，该队列用于线程间的协作</strong>。调用<br>wait就会把当前线程放到条件队列上并阻塞，表示当前线程执行不下去了，它需要等待一个条件，<strong>这个条件它自己改变不了</strong>，需要其他线程改变。当其他线程改变了条件后，应该调用Object(<strong>等待哪个对象就用哪个对象</strong>)的notify方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public final native void notify();</div><div class="line">public final native void notifyAll();</div></pre></td></tr></table></figure></p>
<p>notify做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒，notifyAll和notify的区別是，它会移除条件队列中所有的线程并全部唤醒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class WaitThread extends Thread &#123;</div><div class="line">    private volatile boolean fire = false;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                while(!fire) &#123;</div><div class="line">                    wait();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;fired&quot;);</div><div class="line">        &#125; catch(InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public synchronized void fire() &#123;</div><div class="line">        this.fire = true;</div><div class="line">        notify();</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        WaitThread waitThread = new WaitThread();</div><div class="line">        waitThread.start();</div><div class="line">        Thread.sleep(1000);</div><div class="line">        System.out.println(&quot;fire&quot;);</div><div class="line">        waitThread.fire();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码中的协作的条件变量式fire，两个线程都要访问该fire变量，容易出现竞态条件所以相关代码都被synchronized保护了。</p>
<p><strong>需要特别注意的是：</strong> wait和notify方法的调用只能再synchronized代码块中。如果在调用wait/notify方法时，当前线程没有对象锁的话，那么会抛出<code>java.lang.IllegalMonitor-StateException</code>。</p>
<p><strong>wait的具体过程：</strong></p>
<ol>
<li>把当前线程放入<strong>条件等待队列</strong>，<strong>++释放对象锁++</strong>，阻塞等待，线程状态变为<code>WAITING</code>或<br><code>TIMED_WAITING</code></li>
<li>等待时间到或被其他线程调用notify/notifyAll从条件队列中移除，这时，要重新竞争对象锁<ul>
<li>如果能够获得锁，线程状态变为<code>RUNNABLE</code>，并从wait调用中返回。</li>
<li>否则，该线程加入<strong>对象锁等待队列</strong>，线程状态变为<code>BLOCKED</code>，只有在获得锁后才会从wait调用返回。</li>
</ul>
</li>
</ol>
<p>这里我们一定要区别好两个等待队列，一个是<strong>线程没有分配到cpu时间片进入到的对象锁等待队列</strong>。另一个则是<strong>线程执行遇到条件不满足的情况进入条件等待队列</strong>。</p>
<p>当线程从条件队列中返回不代表其等待的条件就满足了，也有可能是wait方法限定的时间到达了。我们在使用wait方法的时候当其跳出后还应该再判断一次。一般我们通过while循环的方式来做到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">synchronized (obj) &#123;</div><div class="line">    while(条件不成立)</div><div class="line">        obj.wait();</div><div class="line">        </div><div class="line">    …//执行条件满足后的操作</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用notify会把在条件队列中等侍的线程唤醍并从队列中移除，但<strong>它不会释放对象锁</strong>，也就是说，<strong>只有在包含notify的synchronized代码块(被synchronized修饰过了)执行完后，等待的线程才会从wait调用中返回</strong>。这一点需要铭记</p>
<p>我们在使用wait时最难的是搞清楚<strong>wait到底等的是什么？</strong>，而<strong>notify通知的又是什么？</strong> 我们需要知道，它们被不同的线程调用，并共亨相同的锁和条件等待队列（相同对象的<br>synchronized代码块内），它们围绕一个共享的条件变量进行协作，这个条件变量是程序自己维护的，当条件不成立时，线程调用wait进入条件等待队列，另一个线程修改条件后调用notify,调用wait的线程被唤醒后需要重新检查条件变量。从多线程的角度看，它们围绕共享变量进行协作，从调用wait的线程角度看，它阻塞等待一个条件的成立。<strong>我们在设立多线程协作时，需要想清楚协作的<em>++共享变量++</em>和<em>++条件++</em>是什么，这是协作的核心。</strong></p>
<h1 id="线程的基本协作示例"><a href="#线程的基本协作示例" class="headerlink" title="线程的基本协作示例"></a>线程的基本协作示例</h1><p>我们前面说了线程基本协作的场景，这里书上给出了对于这几种场景的代码示例：</p>
<ul>
<li>生产者消费者模式</li>
<li>同时开始</li>
<li>等待结束</li>
<li>异步结果</li>
<li>集合点</li>
</ul>
<h2 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者/消费者模式"></a>生产者/消费者模式</h2><p>队列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static class MyBlockingQueue&lt;E&gt; &#123;</div><div class="line">    private Queue&lt;E&gt; queue = null;</div><div class="line">    private int limit;</div><div class="line">    public MyBlockingQueue(int limit) &#123;</div><div class="line">        this.limit = limit;</div><div class="line">        queue = new ArrayDeque&lt;&gt;(limit);</div><div class="line">    &#125;</div><div class="line">    public synchronized void put(E e) throws InterruptedException &#123;</div><div class="line">        while(queue.size() == limit) &#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">        queue.add(e);</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    public synchronized E take() throws InterruptedException &#123;</div><div class="line">        while(queue.isEmpty()) &#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">        E e = queue.poll();</div><div class="line">        notifyAll();</div><div class="line">        return e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生产者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static class Producer extends Thread &#123;</div><div class="line">    MyBlockingQueue&lt;String&gt; queue;</div><div class="line">    public Producer(MyBlockingQueue&lt;String&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        int num = 0;</div><div class="line">        try &#123;</div><div class="line">            while(true) &#123;</div><div class="line">                String task = String.valueOf(num);</div><div class="line">                queue.put(task);</div><div class="line">                System.out.println(&quot;produce task &quot; + task);</div><div class="line">                num++;</div><div class="line">                Thread.sleep((int) (Math.random() * 100));</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>消费者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">static class Consumer extends Thread &#123;</div><div class="line">    MyBlockingQueue&lt;String&gt; queue;</div><div class="line">    public Consumer(MyBlockingQueue&lt;String&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            while(true) &#123;</div><div class="line">                String task = queue.take();</div><div class="line">                System.out.println(&quot;handle task &quot; + task);</div><div class="line">                Thread.sleep((int)(Math.random()*100));</div><div class="line">            &#125;</div><div class="line">        &#125; catch(InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    MyBlockingQueue&lt;String&gt; queue = new MyBlockingQueue&lt;&gt;(10);</div><div class="line">    new Producer(queue).start();</div><div class="line">    new Consumer(queue).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在生产者消费者模式中，put等待的是队满而take等待的却是队空。但他们都会进入相同的对象的条件等待队列中。由于等待的条件不同，但两者的共享变量却都是该队列，所以此处不能使用notify，因为notify只能唤醒一个线程，而由于线程调度的机制。唤醒的如果是同类线程的话则起不到协调的作用，<strong>所以在共用同一个条件队列而等待的条件却相反时应该使用notifyAll。</strong></p>
<p>Java提供了专门的阻塞队列，包括：</p>
<ul>
<li>接口 BlockingQueue和BlockingDeque</li>
<li>基于数组的实现类 ArrayBlockingQueue</li>
<li>基于链表的实现类 LinkedBlockingQueue和LinkedBlockingDeque</li>
<li>基于堆的实现类 PriorityBlockingQueue</li>
</ul>
<p><strong>在实际场景中，应该优先使用这些实现类。</strong></p>
<h2 id="同时开始"><a href="#同时开始" class="headerlink" title="同时开始"></a>同时开始</h2><p>同时开始的按例好比运动员比赛，一个主线程(裁判)决定着各个子线程(运动员)何时开始。</p>
<p>协作对象fired：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static class FireFlag &#123;</div><div class="line">    private volatile boolean fired = false;</div><div class="line">    public synchronized void waitForFire() throws InterruptedException &#123;</div><div class="line">        while(!fired) &#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public synchronized void fire() &#123;</div><div class="line">        this.fired = true;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运动员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static class Racer extends Thread &#123;</div><div class="line">    FireFlag fireFlag;</div><div class="line">    public Racer(FireFlag fireFlag) &#123;</div><div class="line">        this.fireFlag = fireFlag;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            this.fireFlag.waitForFire();</div><div class="line">            System.out.println(&quot;start run &quot;</div><div class="line">                    + Thread.currentThread().getName());</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>裁判：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    int num = 10;</div><div class="line">    FireFlag fireFlag = new FireFlag();</div><div class="line">    Thread[] racers = new Thread[num];</div><div class="line">    for(int i = 0; i &lt; num; i++) &#123;</div><div class="line">        racers[i] = new Racer(fireFlag);</div><div class="line">        racers[i].start();</div><div class="line">    &#125;</div><div class="line">    Thread.sleep(1000);</div><div class="line">    fireFlag.fire();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="等待结束"><a href="#等待结束" class="headerlink" title="等待结束"></a>等待结束</h2><p>Thread类的join方法的实现其实就是借助于wait方法。其主要代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (isAlive()) &#123;</div><div class="line">    wait(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该代码意义是：只要该等待线程活着就会一直等待，join的结束依赖与线程运行结束的时候Java系统调用notifyAll来通知该等待线程。</p>
<p>使用join有时比较麻烦需要等待各个子线程结束。这里书上给出的例子采用了另一种写法，主线程与子线程协作的是一个数，这个数表示未完成的线程的个数，初始值为子线程个数，主线程需要等待该值变为0，每个子线程结束后需要将该值减一，当为0时调用notifyAll。</p>
<p>协作对象MyLatch：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class MyLatch &#123;</div><div class="line">    private int count;</div><div class="line">    public MyLatch(int count) &#123;</div><div class="line">        this.count = count;</div><div class="line">    &#125;</div><div class="line">    public synchronized void await() throws InterruptedException &#123;</div><div class="line">        while(count &gt; 0) &#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public synchronized void countDown() &#123;</div><div class="line">        count--;</div><div class="line">        if(count &lt;= 0) &#123;</div><div class="line">            notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>子线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static class Worker extends Thread &#123;</div><div class="line">    MyLatch latch;</div><div class="line">    public Worker(MyLatch latch) &#123;</div><div class="line">        this.latch = latch;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            //simulate working on task</div><div class="line">            Thread.sleep((int) (Math.random() * 1000));</div><div class="line">            this.latch.countDown();</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    int workerNum = 100;</div><div class="line">    MyLatch latch = new MyLatch(workerNum);</div><div class="line">    Worker[] workers = new Worker[workerNum];</div><div class="line">    for(int i = 0; i &lt; workerNum; i++) &#123;</div><div class="line">        workers[i] = new Worker(latch);</div><div class="line">        workers[i].start();</div><div class="line">    &#125;</div><div class="line">    latch.await();</div><div class="line">    System.out.println(&quot;collect worker results&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>MyLatch也可以应用在“同时开始”的场景，初始值设为1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class RacerWithLatchDemo &#123;</div><div class="line">    static class Racer extends Thread &#123;</div><div class="line">        MyLatch latch;</div><div class="line">        public Racer(MyLatch latch) &#123;</div><div class="line">            this.latch = latch;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                this.latch.await();</div><div class="line">                System.out.println(&quot;start run &quot;</div><div class="line">                        + Thread.currentThread().getName());</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        int num = 10;</div><div class="line">        MyLatch latch = new MyLatch(1);</div><div class="line">        Thread[] racers = new Thread[num];</div><div class="line">        for(int i = 0; i &lt; num; i++) &#123;</div><div class="line">            racers[i] = new Racer(latch);</div><div class="line">            racers[i].start();</div><div class="line">        &#125;</div><div class="line">        Thread.sleep(1000);</div><div class="line">        latch.countDown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java中提供了一个专门的<strong>同步类CountDownLatch</strong>，在实际开发中应该使用它。</p>
<h2 id="异步结果"><a href="#异步结果" class="headerlink" title="异步结果"></a>异步结果</h2><p>在主从模式中，手工创建线程比较麻烦。一种常见的模式是异步调用，异步调用一般返回一个名为Future的对象，通过它可以获得最终的结果。在Java中表示子任务的接口是Callable。如下是书上例子：</p>
<p>子任务：<strong>Callable</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Callable&lt;V&gt; &#123;</div><div class="line">    V call() throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>异步调用的结果：<strong>Future</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface MyFuture &lt;V&gt; &#123;</div><div class="line">    V get() throws Exception ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过该接口的get方法返回真正的结果。如果结果还没有计算完成，get方法会阻寒直到计算完成，如果调用过程发生异常，则get方法抛出调用过程中的异常。</p>
<p>方便主线程调用子任务的类 <strong>MyExecutor</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public &lt;V&gt; MyFuture&lt;V&gt; execute(final Callable&lt;V&gt; task)</div></pre></td></tr></table></figure></p>
<p>通过该方法<strong>主线程就不需要在创建并管理子线程</strong>了。可以方便的获取到异步调用的结果。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    MyExecutor executor = new MyExecutor();</div><div class="line">    // 子任务</div><div class="line">    Callable&lt;Integer&gt; subTask = new Callable&lt;Integer&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public Integer call() throws Exception &#123;</div><div class="line">            //…执行异步任务</div><div class="line">            int millis = (int) (Math.random() * 1000);</div><div class="line">            Thread.sleep(millis);</div><div class="line">            return millis;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    //异步调用子任务，返回一个MyFuture对象</div><div class="line">    MyFuture&lt;Integer&gt; future = executor.execute(subTask);//内部创了个子线程去执行</div><div class="line">    //…执行其他操作</div><div class="line">    try &#123;</div><div class="line">        //获取异步调用的结果</div><div class="line">        Integer result = future.get();</div><div class="line">        System.out.println(result);</div><div class="line">    &#125; catch(Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以重点是，MyExecutor类的execute方法是怎么实现的呢 <strong>？它封装了创建子线程，同步获取结果的过程，它会创建一个执行子线程。</strong></p>
<p>MyFuture类的execute具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public &lt;V&gt; MyFuture&lt;V&gt; execute(final Callable&lt;V&gt; task) &#123;</div><div class="line">    final Object lock = new Object();</div><div class="line">    final ExecuteThread&lt;V&gt; thread = new ExecuteThread&lt;&gt;(task, lock);</div><div class="line">    thread.start();</div><div class="line">    MyFuture&lt;V&gt; future = new MyFuture&lt;V&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public V get() throws Exception &#123;</div><div class="line">            synchronized (lock) &#123;</div><div class="line">                while(!thread.isDone()) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        lock.wait();</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if(thread.getException() != null) &#123;</div><div class="line">                    throw thread.getException();</div><div class="line">                &#125;</div><div class="line">                return thread.getResult();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    return future;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>execute方法启动一个执行子线程，并返回携带执行结果的MyFuture对象。MyFuture的方法会阻塞等待知道子线程运行结束返回结果。</p>
<p>执行子线程 <strong>ExecuteThread</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">static class ExecuteThread&lt;V&gt; extends Thread &#123;</div><div class="line">    private V result = null;</div><div class="line">    private Exception exception = null;</div><div class="line">    private boolean done = false;</div><div class="line">    private Callable&lt;V&gt; task;</div><div class="line">    private Object lock;</div><div class="line">    public ExecuteThread(Callable&lt;V&gt; task, Object lock) &#123;</div><div class="line">        this.task = task;</div><div class="line">        this.lock = lock;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            result = task.call();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            exception = e;</div><div class="line">        &#125; finally &#123;</div><div class="line">            synchronized (lock) &#123;</div><div class="line">                done = true;</div><div class="line">                lock.notifyAll();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public V getResult() &#123;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">    public boolean isDone() &#123;</div><div class="line">        return done;</div><div class="line">    &#125;</div><div class="line">    public Exception getException() &#123;</div><div class="line">        return exception;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java中也已经包含了一套完善的方案，有：</p>
<ul>
<li>表示<strong>异步结果</strong>的接口Future和实现类FutureTask。</li>
<li>用于<strong>执行异步任务</strong>的接口Executor，以及有更多功能的子接口ExecutorService。<ul>
<li>用于创建Executor和ExecutorService的工厂方法类Executors。  </li>
</ul>
</li>
</ul>
<h2 id="集合点"><a href="#集合点" class="headerlink" title="集合点"></a>集合点</h2><p>和之前等待结束和同时开始案例相似。各线程分开行动，各自到大一个集合点，在集合点需要集齐所有线程，交换数据然后再进行下一步动作。协作的共享变量n，初始值为线程总数，当有一个线程到达集合点n减一。直到变为0即最后一个也到达，通过notifyAll来唤醒所有条件等待线程。</p>
<p>协作对象：<strong>AssemblePoint</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">协作对象public class AssemblePoint &#123;</div><div class="line">    private int n;</div><div class="line">    public AssemblePoint(int n) &#123;</div><div class="line">        this.n = n;</div><div class="line">    &#125;</div><div class="line">    public synchronized void await() throws InterruptedException &#123;</div><div class="line">        if(n &gt; 0) &#123;</div><div class="line">            n--;</div><div class="line">            if(n == 0) &#123;</div><div class="line">                notifyAll();</div><div class="line">            &#125; else &#123;</div><div class="line">                while(n != 0) &#123;</div><div class="line">                    wait();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主线程：<strong>AssemblePointDemo</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class AssemblePointDemo &#123;</div><div class="line">    static class Tourist extends Thread &#123;</div><div class="line">        AssemblePoint ap;</div><div class="line">        public Tourist(AssemblePoint ap) &#123;</div><div class="line">            this.ap = ap;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                //模拟先各自独立运行</div><div class="line">                Thread.sleep((int) (Math.random() * 1000));</div><div class="line">                //㼿㼿</div><div class="line">                ap.await();</div><div class="line">                System.out.println(&quot;arrived&quot;);</div><div class="line">                //…㼿㼿㼿㼿㼿㼿㼿㼿㼿</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final int num = 10;</div><div class="line">        Tourist[] threads = new Tourist[num];</div><div class="line">        AssemblePoint ap = new AssemblePoint(num);</div><div class="line">        for(int i = 0; i &lt; num; i++) &#123;</div><div class="line">            threads[i] = new Tourist(ap);</div><div class="line">            threads[i].start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java中有一个专门的同步工具类CyclicBarrier可以替代该AssemblePoint类。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该节主要介绍了Java中线程间协作的基本机制wait/notify，协作关键要想淸楚协作的共享变贵和条件是什么。Java中有专门为协作而建的阻塞队列、同步工具类，以及Executors框架。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程的基本协作&quot;&gt;&lt;a href=&quot;#线程的基本协作&quot; class=&quot;headerlink&quot; title=&quot;线程的基本协作&quot;&gt;&lt;/a&gt;线程的基本协作&lt;/h1&gt;&lt;p&gt;多线程间除了竞争访问同一资源外，也经常需要相互协作的去执行一些任务。而对于协作的基本机制用的最多的无疑是wait/notify。&lt;/p&gt;
&lt;h2 id=&quot;协作的场景&quot;&gt;&lt;a href=&quot;#协作的场景&quot; class=&quot;headerlink&quot; title=&quot;协作的场景&quot;&gt;&lt;/a&gt;协作的场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;生产者消费者模式：共享队列，一个负责放一个负责取。如果队列长度有限且满了之后则等待。&lt;/li&gt;
&lt;li&gt;同时开始：类似运动员比赛，多个线程同时开始执行。&lt;/li&gt;
&lt;li&gt;等待结束：主线程分发给各个子任务去执行任务，主任务开始执行前需要等待各个子任务执行完毕。&lt;/li&gt;
&lt;li&gt;异步结果：&lt;/li&gt;
&lt;li&gt;集合点&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="并发" scheme="http://www.jiyongguang.xin/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java编程的逻辑 -- 并发章 -- Synchronized</title>
    <link href="http://www.jiyongguang.xin/java-concurrentProgramming-readingNotes-15.2.html"/>
    <id>http://www.jiyongguang.xin/java-concurrentProgramming-readingNotes-15.2.html</id>
    <published>2018-06-22T00:26:46.000Z</published>
    <updated>2018-06-22T00:29:20.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><p>共享内存有两个重要问题，一个是<strong>竞态条件</strong>，一个是<strong>内存可见性</strong>。其实一种解决方案则是Synchronized</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们首先来看一段synchronized修饰方法和代码块的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line">	//修饰方法</div><div class="line">    public synchronized void test1()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">	</div><div class="line">    public void test2()&#123;</div><div class="line">		// 修饰代码块</div><div class="line">        synchronized (this)&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来反编译看一下：<br><img src="https://img-blog.csdn.net/20170205213401778?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnNzeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从上面可以看出，<strong>同步代码块</strong>是使用monitorenter和monitorexit指令实现的，<strong>同步方法</strong>（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。 </p>
<p><strong>同步代码块</strong>：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁。synchronized底层是通过monitor对象，对象有自己的对象头，存储了很多信息，其中一个信息标示是被哪个线程持有。</p>
<p><strong>同步方法</strong>：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。(摘自：<a href="http://www.cnblogs.com/javaminer/p/3889023.html" target="_blank" rel="external">http://www.cnblogs.com/javaminer/p/3889023.html</a>)</p>
<p>具体可参考：</p>
<ul>
<li><a href="https://blog.csdn.net/chenssy/article/details/54883355" target="_blank" rel="external">https://blog.csdn.net/chenssy/article/details/54883355</a></li>
<li><a href="https://blog.csdn.net/u012465296/article/details/53022317" target="_blank" rel="external">https://blog.csdn.net/u012465296/article/details/53022317</a></li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="1-实例方法"><a href="#1-实例方法" class="headerlink" title="1. 实例方法"></a>1. 实例方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Counter &#123;</div><div class="line">    private int count;</div><div class="line">    public synchronized void incr()&#123;</div><div class="line">        count ++;</div><div class="line">    &#125;</div><div class="line">    public synchronized int getCount() &#123;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Synchronized可以用来修饰实例方法，静态方法，(静态或实例)代码块。</p>
<p>多个线程可以同时执行一个Synchronized方法，只要他们访问的不是同一个实例对象即可。</p>
<p><strong>Synchronized实际上保护的是当前实例对象</strong>，而不是它仅描述的那个方法。此时this对象有一个锁和一个等待队列，<strong>锁只能被一个线程持有，</strong> 其他试图获得同样锁的线程需要等待。当前线程不能获得锁的时候，它会加入等待队列，线程的状态会变为<strong>BLOCKED</strong>。</p>
<hr>
<p>Thread有一个与其状态对应的枚举类。Thread.State枚举类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public enum State &#123;</div><div class="line">  NEW,</div><div class="line">  RUNNABLE,</div><div class="line">  BLOCKED,</div><div class="line">  WAITING,</div><div class="line">  TIMED_WAITING,</div><div class="line">  TERMINATED;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于这些状态.我们简单解释下：<br>1) <strong>NEW</strong>:没有调用start的线程状态为NEW。<br>2) <strong>TERMINATED</strong>:线程运行结朿后状态为TERMINATED。<br>3) <strong>RUNNABLE</strong>:调用start后线程在执行run方法且没有阻寒时状态为RUNNABLE,不过，<br>RUNNABLE不代表CPU—定在执行该线程的代码，可能正在执行也可能在等待操作系统分配时间片，只<br>是它没有在等待其他条件。</p>
<h2 id="4-BLOCKED、WAITING、TIMED-WAmNG-都表示线程被阻塞了，在等待一些条件。其中BLOCKED表示当前线程在等待的是CPU的时间片而WAITING、TIMED-WAmNG则等待的是外部条件。"><a href="#4-BLOCKED、WAITING、TIMED-WAmNG-都表示线程被阻塞了，在等待一些条件。其中BLOCKED表示当前线程在等待的是CPU的时间片而WAITING、TIMED-WAmNG则等待的是外部条件。" class="headerlink" title="4) BLOCKED、WAITING、TIMED_WAmNG:都表示线程被阻塞了，在等待一些条件。其中BLOCKED表示当前线程在等待的是CPU的时间片而WAITING、TIMED_WAmNG则等待的是外部条件。"></a>4) <strong>BLOCKED、WAITING、TIMED_WAmNG</strong>:都表示线程被阻塞了，在等待一些条件。其中BLOCKED表示当前线程在等待的是CPU的时间片而WAITING、TIMED_WAmNG则等待的是外部条件。</h2><p><strong>Synchronized保护的是对象而非方法块</strong>，只要访问的是同一个对象的synchronized方法，即使是不同的方法块，也会被同步顺序访问。比如，对于Counter类中的两个同步实例方法get和incr，对同一个Counter对象，一个线程执行get，另一个执行incr,它们是不能同时执行的，会被synchronized同步顺序执行。</p>
<p>此外，需要说明的是，<strong><strong>synchronized方法不能防止非synchronized方法被同时执行</strong></strong>。比如，如果给Counler类增加一个非synchronized方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void decr()&#123;</div><div class="line">    count --;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>则该方法可以和synchronized的incr方法同时执行，这通常会出现非期望的结果，所以，<strong>一般在保护变量时，需要在所有访问该变量的方法前加shsynchronizcd(不一定)</strong>。</p>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a>2. 静态方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class StaticCounter &#123;</div><div class="line">    private static int count = 0;</div><div class="line">    public static synchronized void incr() &#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">    public static synchronized int getCount() &#123;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对实例方法，synchronized保护的是当前实例对象this,<strong>对静态方法，保护的是类对象</strong>，这里是StaticCounter.class。实际上，每个对象都有一个锁和一个等待队列，Class类对象也不例外。</p>
<p>synchronized静态方法和synchronized实例方法保护的是不同的对象，不同的两个线程，可以一个执行synchronized静态方法，另一个执行synchronized实例方法。所以他们可以同时运行</p>
<h3 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3. 代码块"></a>3. 代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Counter &#123;</div><div class="line">    private int count;</div><div class="line">    public void incr()&#123;</div><div class="line">    </div><div class="line">        synchronized(this)&#123;</div><div class="line">            count ++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    public int getCount() &#123;</div><div class="line">        synchronized(this)&#123;</div><div class="line">            return count;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>synchronized括号里即保护的对象，对于实例方法而言则是<strong>this</strong>，<code>{}</code>是执行同步的代码。对于上例中的StaticCounter类，等价的代码则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class StaticCounter &#123;</div><div class="line">    private static int count = 0;</div><div class="line">    public static void incr() &#123;</div><div class="line">        synchronized(StaticCounter.class)&#123;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static int getCount() &#123;</div><div class="line">        synchronized(StaticCounter.class)&#123;</div><div class="line">            return count;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>synchronized同步的对象可以是任意对象，任意对象都有一个锁和等待队列，或者说，任何对象都可以作为锁对象。如下的类成员lock。所以在如下这种情况中，所有的线程中所跑的涉及域lock的方法都会在一个等待队列中排队执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Counter &#123;</div><div class="line">    private int count;</div><div class="line">    private Object lock = new Object();</div><div class="line">    public void incr()&#123;</div><div class="line">        synchronized(lock)&#123;</div><div class="line">            count ++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public int getCount() &#123;</div><div class="line">        synchronized(lock)&#123;</div><div class="line">            return count;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>可重入性</li>
<li>内存可见性</li>
<li>死锁</li>
</ul>
<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>Synchronized是一种可重入锁。</p>
<p><strong>可重入锁是通过记录锁的持有线程和持有数来实现的</strong>，当调用被synchronized保护的代码时，检查对象是否已被锁，如果是，再检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁<br>定，才加入等待队列，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。</p>
<h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>Synchronized除了可以保证原子性，同时还可以保证内存可见性。在释放锁时，所有的写入都会从寄存器或缓存(工作内存)写回内存，而获得锁后都会从内存中获得最新数据。</p>
<p>但如果只是为了保证内存可见性，使用synchronized关键字的成本则要高于volatile修饰符的使用。</p>
<p>如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Switcher &#123;</div><div class="line">    private boolean on;</div><div class="line">    public boolean isOn() &#123;</div><div class="line">        return on;</div><div class="line">    &#125;</div><div class="line">    public void setOn(boolean on) &#123;</div><div class="line">        this.on = on;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该代码在并发执行的时候不涉及非原子操作，仅修改变量on的状态，是一个原子操作。所以这里完全不必要用synchronized修饰符来附加在setOn方法上来锁住整个对象。它并不面临原子性问题，而是面临的内存可见性问题，只需要对on变量用volatile来修饰即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Switcher &#123;</div><div class="line">    private volatile boolean on;</div><div class="line">    public boolean isOn() &#123;</div><div class="line">        return on;</div><div class="line">    &#125;</div><div class="line">    public void setOn(boolean on) &#123;</div><div class="line">        this.on = on;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>经典示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class DeadLockDemo &#123;</div><div class="line">    private static Object lockA = new Object();</div><div class="line">    private static Object lockB = new Object();</div><div class="line">    private static void startThreadA() &#123;</div><div class="line">        Thread aThread = new Thread() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (lockA) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(1000);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                    &#125;</div><div class="line">                    synchronized (lockB) &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        aThread.start();</div><div class="line">    &#125;</div><div class="line">    private static void startThreadB() &#123;</div><div class="line">        Thread bThread = new Thread() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (lockB) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(1000);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                    &#125;</div><div class="line">                    synchronized (lockA) &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        bThread.start();</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        startThreadA();</div><div class="line">        startThreadB();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行后aThread和bThread陷入了相互等待。怎么解决呢？首先，座该尽量避免在持有一个锁的同时去中请另一个锁，如果确实需要多个锁，所有代码都砹该按照相同的顺序去申请锁。比如，对于上面的例子，可以约定都先申请lockA，再申请lockB，而不是像代码中那样分开申请。</p>
<p>不过，在复杂的项目代码中，这种约定可能难以做到。还有一种方法是显示锁接口Lock，它支持尝试获取锁（tryLock)和带时间限制的获取锁方法，使用这些方法可以在获取不到锁的时候释放已经持有的锁，然后再次尝试获取锁或干脆放弃，以避免死锁。<br>如采还是出现了死锁，Java不会主动处理，不过借助一些工貝，我们可以发现运行中的死锁，比如，Java自带的<strong>jsiadc命令</strong>会报告发现的死锁。</p>
<h2 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h2><p>类Collections中提供了一些方法，返回线程安全的同步容器。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-21/46493932.jpg" alt=""></p>
<p>它们是給所有容器方法都加上synchronized来实现线程安全的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt; &#123;</div><div class="line">    final Collection&lt;E&gt; c;  //Backing Collection</div><div class="line">    final Object mutex;     //Object on which to synchronize</div><div class="line">    SynchronizedCollection(Collection&lt;E&gt; c) &#123;</div><div class="line">        if(c==null)</div><div class="line">            throw new NullPointerException();</div><div class="line">        this.c = c;</div><div class="line">        mutex = this;</div><div class="line">    &#125;</div><div class="line">    public int size() &#123;</div><div class="line">        synchronized (mutex) &#123;return c.size();&#125;</div><div class="line">    &#125;</div><div class="line">    public boolean add(E e) &#123;</div><div class="line">        synchronized (mutex) &#123;return c.add(e);&#125;</div><div class="line">    &#125;</div><div class="line">    public boolean remove(Object o) &#123;</div><div class="line">        synchronized (mutex) &#123;return c.remove(o);&#125;</div><div class="line">    &#125;</div><div class="line">   //…</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的线程安全指的是容器对象，即当多个线程并发访问同一个容器对象时不需要额外的同步操作，也不会出现错误的结果。</p>
<p>加了synchronized之后所有操作都变成了原子操作，但并不意味着客户端在调用的时候就绝对安全了。以下情况还需注意：</p>
<ul>
<li>复合操作，比如先检查后更新</li>
<li>伪同步</li>
<li>迭代</li>
</ul>
<h3 id="1-复合操作"><a href="#1-复合操作" class="headerlink" title="1. 复合操作"></a>1. 复合操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class EnhancedMap &lt;K, V&gt; &#123;</div><div class="line">    Map&lt;K, V&gt; map;</div><div class="line">    public EnhancedMap(Map&lt;K,V&gt; map)&#123;</div><div class="line">        this.map = Collections.synchronizedMap(map);</div><div class="line">    &#125;</div><div class="line">    public V putIfAbsent(K key, V value)&#123;</div><div class="line">         V old = map.get(key);</div><div class="line">         if(old!=null)&#123;</div><div class="line">             return old;</div><div class="line">         &#125;</div><div class="line">         return map.put(key, value);</div><div class="line">     &#125;</div><div class="line">    public V put(K key, V value)&#123;</div><div class="line">        return map.put(key, value);</div><div class="line">    &#125;</div><div class="line">    //…</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码中的putIfAbsent方法在多线程下显然是不安全的。如果多个线程都执行这一步则必然会出现竞态条件。</p>
<h3 id="2-伪同步"><a href="#2-伪同步" class="headerlink" title="2. 伪同步"></a>2. 伪同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public synchronized V putIfAbsent(K key, V value)&#123;</div><div class="line">    V old = map.get(key);</div><div class="line">    if(old!=null)&#123;</div><div class="line">        return old;</div><div class="line">    &#125;</div><div class="line">    return map.put(key, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上代码即便加上synchronized关键字修饰也任然是不安全的。因为我们<strong>同步错了对象</strong>，putlfAbsent同步使用的是EnhancedMap对象，而其他方法(如代码中的put方法）使用的是Collections.synchronizedMap返回的对象map、两者是不同的对象。要解决这个问题，<strong>所有方法必须使用相同的锁</strong>，可以使用EnhancedMap的对象锁，也可以使用map对象锁。使用EnhancedMap对象作为锁，则Enhanced-Map中的所有方法都需耍加上synchronized。使用map作为锁，putlfAbsent方法可以改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public V putIfAbsent(K key, V value)&#123;</div><div class="line">    synchronized(map)&#123;</div><div class="line">         V old = map.get(key);</div><div class="line">         if(old!=null)&#123;</div><div class="line">             return old;</div><div class="line">         &#125;</div><div class="line">         return map.put(key, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-迭代"><a href="#3-迭代" class="headerlink" title="3. 迭代"></a>3. 迭代</h3><p>对于同步容器虽然单个操作是安全的，但是迭代却不是。如下代码截取自Collections.SynchronizedList类。可以看到函数并不是同步实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ListIterator&lt;E&gt; listIterator() &#123;</div><div class="line">    return list.listIterator(); // Must be manually synched by user</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ListIterator&lt;E&gt; listIterator(int index) &#123;</div><div class="line">    return list.listIterator(index); // Must be manually synched by user</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们通过两个线程来并发的修改和迭代该同步容器则会出现List迭代时规定的并发修改异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">private static void startModifyThread(final List&lt;String&gt; list) &#123;</div><div class="line">    Thread modifyThread = new Thread(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for(int i = 0; i &lt; 100; i++) &#123;</div><div class="line">                list.add(&quot;item &quot; + i);</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep((int) (Math.random() * 10));</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    modifyThread.start();</div><div class="line">&#125;</div><div class="line">private static void startIteratorThread(final List&lt;String&gt; list) &#123;</div><div class="line">    Thread iteratorThread = new Thread(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            while (true) &#123;</div><div class="line">                for(String str : list) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    iteratorThread.start();</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    final List&lt;String&gt; list = Collections</div><div class="line">            .synchronizedList(new ArrayList&lt;String&gt;());</div><div class="line">    startIteratorThread(list);</div><div class="line">    startModifyThread(list);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;Thread-0&quot; java.util.ConcurrentModificationException</div><div class="line">    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:859)</div><div class="line">    at java.util.ArrayList$Itr.next(ArrayList.java:831)</div></pre></td></tr></table></figure></p>
<p>我们知道对于遍历操作而言，如果迭代时容器发生了结构性变化。就会抛出该异常。很显然同步容器并没有解决这个问题，要想避免这个问题则需要在<strong>遍历的时候给整个容器对象加锁。</strong> 即谁无法保证线程安全，方法体中的代码块就锁谁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private static void startIteratorThread(final List&lt;String&gt; list) &#123;</div><div class="line">    Thread iteratorThread = new Thread(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            while(true) &#123;</div><div class="line">                synchronized(list)&#123;</div><div class="line">                    for(String str : list) &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-并发容器"><a href="#4-并发容器" class="headerlink" title="4. 并发容器"></a>4. 并发容器</h3><p>在使用synchronized的时候除了需要注意以上注意事项，同时同步容器的性能也是比较低的，当并发访问量比较大的时候性能比较差。但Java还为我们提供了很多专为并发设计的容器类。比如：</p>
<ul>
<li>CopyOnWriteArrayList</li>
<li>ConcurrentHashMap</li>
<li>ConcurrentLinkedQueue</li>
<li>ConcurrentSkipListSet</li>
</ul>
<p>这些容器类都是线程安全的，仍但都没有使用synchronized，没存迭代问题，直接支持一些复合操作，<br>性能也搞得多。</p>
<h2 id="释放锁的时机"><a href="#释放锁的时机" class="headerlink" title="释放锁的时机"></a>释放锁的时机</h2><ul>
<li>当方法(代码块)执行完毕后会自动释放锁，不需要做任何的操作。</li>
<li>当一个线程执行的代码出现异常时，其所持有的锁会自动释放。</li>
</ul>
<p>不会由于异常导致出现死锁现象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Synchronized&quot;&gt;&lt;a href=&quot;#Synchronized&quot; class=&quot;headerlink&quot; title=&quot;Synchronized&quot;&gt;&lt;/a&gt;Synchronized&lt;/h1&gt;&lt;p&gt;共享内存有两个重要问题，一个是&lt;strong&gt;竞态条件&lt;/s
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>并发编程实战读书笔记</title>
    <link href="http://www.jiyongguang.xin/java-concurrent-shizhan.html"/>
    <id>http://www.jiyongguang.xin/java-concurrent-shizhan.html</id>
    <published>2018-06-15T09:06:41.000Z</published>
    <updated>2018-06-22T00:28:34.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从今天开始读并发编程实战，</p>
<p>这边文章仅简单记录自己学习时遇到的琐碎知识点</p>
<h1 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="第一章 简介"></a>第一章 简介</h1><p>操作系统保证了系统可以运行多个程序，它为多个不同的进程分配各种资源，包括内存，文件句柄，以及安全证书等。如果需要，不同进程间还可以通过一些粗粒度的通信机制来交换数据，包括：套接字，信号处理器，共享内存，信号量及文件。</p>
<p><strong>同一个程序中的多个线程也可以被同时调度到多个CPU上运行。</strong></p>
<a id="more"></a>
<p>如果在程序中只有一个线程，那么它最多同时只能在一个处理器上运行。在有十个处理器的的系统上，单线程的程序只能使用1/10的CPU资源。另一方面多线程程序可以同时在多个处理器上工作，进而提高处理器的利用率来提升系统吞吐率。</p>
<p>使用多个线程还有助于在单处理器系统上获得更高的吞吐率。如果程序是单线程的，那么当程序等待某个同步 I/O 操作(<strong>CPU置空</strong>)完成时，处理器将处于空闲状态。而在多线程程序中，如果一个、线程在等待 I/O 操作完成，另一个线程可以继续运行，使程序能够在 I/O 阻塞期间继续运行。（这就好比在等待水烧开的同时看报纸，而不是等到水烧开之后再开始看报纸）。</p>
<p>非线程安全的数值序列生成器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@NotThreadSafe</div><div class="line">public class UnsafeSequence &#123;</div><div class="line"></div><div class="line">    private int value;</div><div class="line"></div><div class="line">    /* 返回一个唯一的数值 */</div><div class="line">    public int getValue() &#123;</div><div class="line">        return value++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并发情况下程序可能的执行流程：<br>A：线程A，B：线程B<br><img src="http://otsgsfu16.bkt.clouddn.com/18-6-12/95933787.jpg" alt=""></p>
<p>由于JVM中存在指令重排序的可能，因此实际情况可能更糟。</p>
<p>在多线程的环境下，只要我们<strong>不使用成员变量(线程间共享数据)</strong>,那么就不会出现线程安全的问题了。</p>
<p><strong>活跃性问题</strong>：当某个操作无法继续执行下去时，就会发生活跃性问题。形式单线程中之一就是程序无意中造成的无限循环，多线程情况下的死锁问题。</p>
<p><strong>性能问题</strong>：在多线程程序中，当线程调度器临时挂起活跃线程并转而运行另一个线程时，就<strong>会频繁地出现上下文</strong>切换操作，这种操作将带来极大的开销：保存和恢复执行上下文，丢失局部性，并且<strong>CPU时间将更多地花在线程调度而不是线程运行上。</strong> 当线程共享数据时，必须使用同步机制，而这些机制往往<strong>会抑制某些编译器优化</strong>，使内存缓存区(工作内存)中的数据无效，以及增加共享内存总线的同步流量。</p>
<h1 id="第二章-线程安全性"><a href="#第二章-线程安全性" class="headerlink" title="第二章 线程安全性"></a>第二章 线程安全性</h1><p>Java 中的主要同步机制是关键字 synchronized ，它提供了一种独占的加锁方式，但“同步”．这个术语还包括 volatile 类型的变量，显式锁（ ExPllcit Lock ）以及原子变量。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-14/94017935.jpg" alt=""></p>
<p>有时候，面向对象中的抽象和封装会降低程序的性能（尽管很少有开发人员相信），但在编写并发应用程序时，一种正确的编程方法就是：<strong>首先使代码正确运行，然后再提高代码的速度。</strong> 即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能提升时，才进行优化。 </p>
<p>需要明白的是，<strong>完全由线程安全类构成的程序并不一定就是线程安全的，</strong> 而在线程安全的类中也可以包含非线程安全的类。</p>
<p>一个类是无状态的意味着该类不包含任何属于本类的域(<strong>成员变量</strong>)，也不包含任何其他类中域的引用(其他类属性)。<strong>无状态对象一定是线程安全的。</strong></p>
<ul>
<li>竞态条件：当某个计算的正确性需要<strong>依赖多线程交替执行</strong>时。如下代码块：<ul>
<li>避免：要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。</li>
</ul>
</li>
</ul>
<p>延迟初始化示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@NotThreadSafe</div><div class="line">public class Singleton &#123;</div><div class="line"></div><div class="line">    private Singleton singleton = null;</div><div class="line"></div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">       </div><div class="line">        if (singleton == null) &#123;// 竞态条件</div><div class="line">            singleton = new Singleton();</div><div class="line">        &#125;</div><div class="line">        return singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了确保线程安全性，“先检查后执行”（例如延迟初始化）和“读取一修改一写入” （例如递增运算）等<strong>操作必须是原子的</strong>。我们将“先检查后执行”以及“读取一修改一写入”等操作统称为复合操作：包含了一组必须以原子方式执行的操作以确保线程安全性。</p>
<p>改进写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@ThreadSafe</div><div class="line">public class Singleton &#123;</div><div class="line"></div><div class="line">    private static volatile Singleton singleton = null;</div><div class="line">    /* 这里使用volatile修饰的目的是可以提升程序的性能，</div><div class="line">    对于没有进入if代码块的线程关于singleton变量的修改可以第一时间被通知到，</div><div class="line">    这样就不会有过多的线程由于没有拿到已被初始化的singleton了</div><div class="line">    ，而出的大量的涌入到同步代码块中去争锁的情况。*/</div><div class="line"></div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        if (singleton == null) &#123;</div><div class="line">            synchronized (Singleton.class) &#123;// 通过synchronized关键字来对代码块上锁</div><div class="line">                if (singleton == null) &#123;</div><div class="line">                    singleton = new Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>延迟初始化示例中我们通过synchronized独占锁来保证了“先检查后执行”操作的原子性。</p>
<p>在没有synchronized关键字做出保证的情况下，只有volatile关键字修饰的变量，在不能保证运算操作的原子性问题上我们可以借助Java提供的concurrent包下的atomic包中的原子类来保证。</p>
<ul>
<li>数据竞争：多线程情况下<strong>数据不同步</strong>导致带来的并发修改等问题，(volatile关键字做的事情就是在其修饰的变量保证不涉及非原子性的操作的基础上，来保证多线程间共享变量的同步的)</li>
</ul>
<p>在一般实际开发过程中的多线程环境下，应尽可能的使用现有的线程安全对象(例如AtomicLong)来管理类的状态。即类中的成员属性应该尽可能的都由线程安全的对象来修饰，进而保证如果以后这类成员变量遇到修改操作等 可以直接拿来使用，扩展性更高。(当某个成员变量已经可以通过其他同步方式保证那么不建议这么做)</p>
<p>要保证多线程中状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。</p>
<p>以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以 Class 对象作为锁。</p>
<p>synchronized关键字的锁是一种排它锁，通过其修饰的内容可以保证了多线程间的安全问题，但紧接着就会出现的是性能问题。</p>
<p>我们在书写同步代码块的时候，应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去。</p>
<p>如果一种同步机制已经可以在安全上带来保证，那么应该杜绝多种同步机制的联合使用。比如对于一个并发计数操作，我们一个基本类型的int变量在同步代码块中已经保证了他的并发修改的安全性，你还要把这个int类型的变量用AtomicInteger来取代。那么无论从性能上还是安全上来考虑都是极不合理的。</p>
<p>要判断同步代码块的合理大小，个铃求必须得到满足）、需要在各种设计需求之间进行权衡，简单性和性能。有时候．包括安全性(这个需求必须得到满足)，简单性和性能。有时候，在简单性与性能之间会发生冲突，在二者之间通常能找到某种合理的平衡。当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性(这可能会破坏安全性)。</p>
<p>当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论是执行计算密集的操作，还是在执行某个可能阻塞的操作．如果持有锁的时间过长，那么都会带来活跃性或性能问题。当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。</p>
<h1 id="第三章-对象的共享"><a href="#第三章-对象的共享" class="headerlink" title="第三章 对象的共享"></a>第三章 对象的共享</h1><h1 id="第四章-对象的组合"><a href="#第四章-对象的组合" class="headerlink" title="第四章 对象的组合"></a>第四章 对象的组合</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从今天开始读并发编程实战，&lt;/p&gt;
&lt;p&gt;这边文章仅简单记录自己学习时遇到的琐碎知识点&lt;/p&gt;
&lt;h1 id=&quot;第一章-简介&quot;&gt;&lt;a href=&quot;#第一章-简介&quot; class=&quot;headerlink&quot; title=&quot;第一章 简介&quot;&gt;&lt;/a&gt;第一章 简介&lt;/h1&gt;&lt;p&gt;操作系统保证了系统可以运行多个程序，它为多个不同的进程分配各种资源，包括内存，文件句柄，以及安全证书等。如果需要，不同进程间还可以通过一些粗粒度的通信机制来交换数据，包括：套接字，信号处理器，共享内存，信号量及文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同一个程序中的多个线程也可以被同时调度到多个CPU上运行。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="并发" scheme="http://www.jiyongguang.xin/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Thread类源码剖析</title>
    <link href="http://www.jiyongguang.xin/java-thread.html"/>
    <id>http://www.jiyongguang.xin/java-thread.html</id>
    <published>2018-06-11T03:10:18.000Z</published>
    <updated>2018-06-11T03:12:26.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thread-类-常见Api剖析"><a href="#Thread-类-常见Api剖析" class="headerlink" title="Thread 类 常见Api剖析"></a>Thread 类 常见Api剖析</h1><h2 id="Thread类构造函数"><a href="#Thread类构造函数" class="headerlink" title="Thread类构造函数"></a>Thread类构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public Thread() &#123;</div><div class="line">    init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Thread(Runnable target) &#123;</div><div class="line">    init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Thread(Runnable target, String name) &#123;</div><div class="line">    init(null, target, name, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Thread(String name) &#123;</div><div class="line">    init(null, null, name, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>虽然4个构造函数的函数签名不同，但是低层调用的init方法却是一致的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Initializes a Thread with the current AccessControlContext.</div><div class="line"> * @see #init(ThreadGroup,Runnable,String,long,AccessControlContext)</div><div class="line"> */</div><div class="line">private void init(ThreadGroup g, Runnable target, String name,</div><div class="line">                  long stackSize) &#123;</div><div class="line">    init(g, target, name, stackSize, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该初始化方法负责构造当前线程所在的线程组ThreadGroup，真实运行的线程对象target，线程名name，线程栈的大小stackSize，访问控制的上下文null。</p>
<h2 id="getName"><a href="#getName" class="headerlink" title="getName"></a>getName</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Returns this thread&apos;s name.</div><div class="line"> */</div><div class="line">private volatile String name; // 线程名，volatile修饰保证了并发修改情况下的可见性</div><div class="line"></div><div class="line">public final String getName() &#123;</div><div class="line">    return name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="setName"><a href="#setName" class="headerlink" title="setName"></a>setName</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/* Java thread status for tools,</div><div class="line"> * initialized to indicate thread &apos;not yet started&apos;</div><div class="line"> */</div><div class="line"></div><div class="line">private volatile int threadStatus = 0;// 线程状态 初始为0，表示已被创建</div><div class="line"></div><div class="line">/**</div><div class="line"> * Changes the name of this thread to be equal to the argument</div><div class="line"> * &lt;code&gt;name&lt;/code&gt;.</div><div class="line"> */</div><div class="line">public final synchronized void setName(String name) &#123;</div><div class="line">    checkAccess();// 查看当前线程是否为null 以及是否具有修改权限</div><div class="line">    if (name == null) &#123;</div><div class="line">        throw new NullPointerException(&quot;name cannot be null&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    this.name = name;</div><div class="line">    if (threadStatus != 0) &#123;</div><div class="line">        setNativeName(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="checkAccess"><a href="#checkAccess" class="headerlink" title="checkAccess"></a>checkAccess</h2><p>该checkAccess方法可以确定当前正在运行的线程是否有权修改此线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Determines if the currently running thread has permission to</div><div class="line"> * modify this thread.</div><div class="line"> */</div><div class="line">public final void checkAccess() &#123;</div><div class="line">    SecurityManager security = System.getSecurityManager();</div><div class="line">    if (security != null) &#123;</div><div class="line">        security.checkAccess(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void checkAccess(Thread t) &#123;</div><div class="line">    if (t == null) &#123;</div><div class="line">        throw new NullPointerException(&quot;thread can&apos;t be null&quot;);</div><div class="line">    &#125;</div><div class="line">    if (t.getThreadGroup() == rootGroup) &#123;</div><div class="line">        checkPermission(SecurityConstants.MODIFY_THREAD_PERMISSION);</div><div class="line">    &#125; else &#123;</div><div class="line">        // just return</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>守护线程是为其他线程服务的</p>
<ul>
<li>垃圾回收线程就是守护线程</li>
</ul>
<p>守护线程有一个特点：</p>
<ul>
<li>当别的用户线程执行完了，虚拟机就会退出，守护线程也就会被停止掉了。</li>
<li>也就是说：守护线程作为一个<strong>服务线程</strong>，没有服务对象就没有必要继续运行了。</li>
</ul>
<p><strong>使用线程的时候要注意的地方</strong></p>
<ol>
<li><strong>在线程启动前</strong>设置为守护线程，方法是<code>setDaemon(boolean on)</code></li>
<li>使用守护线程<strong>不要访问共享资源</strong>(数据库、文件等)，因为它可能会在任何时候就挂掉了。</li>
<li>守护线程中产生的新线程也是守护线程</li>
</ol>
<h2 id="setDaemon"><a href="#setDaemon" class="headerlink" title="setDaemon"></a>setDaemon</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Marks this thread as either a &#123;@linkplain #isDaemon daemon&#125; thread</div><div class="line"> * or a user thread. The Java Virtual Machine exits when the only</div><div class="line"> * threads running are all daemon threads.</div><div class="line"> */</div><div class="line">public final void setDaemon(boolean on) &#123;</div><div class="line">    checkAccess();</div><div class="line">    if (isAlive()) &#123;// 如果当前线程活着</div><div class="line">        throw new IllegalThreadStateException();</div><div class="line">    &#125;</div><div class="line">    daemon = on;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过注释可以看出，当运行的唯一线程也为守护线程的时候JVM退出。</li>
<li>通过代码中if语句的判断也可以看出，我们需要在线程启动之前即调用start函数之前设置其是否为守护线程。否则会跑出异常</li>
</ul>
<h1 id="优先级线程"><a href="#优先级线程" class="headerlink" title="优先级线程"></a>优先级线程</h1><p>线程优先级高仅仅表示线程获取的CPU时间片的几率高，但这不是一个确定的因素！</p>
<p><strong>线程的优先级是高度依赖于操作系统的</strong>，Windows和Linux就有所区别(Linux下优先级可能就被忽略了)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * The minimum priority that a thread can have.</div><div class="line"> */</div><div class="line">public final static int MIN_PRIORITY = 1;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The default priority that is assigned to a thread.</div><div class="line"> */</div><div class="line">public final static int NORM_PRIORITY = 5;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The maximum priority that a thread can have.</div><div class="line"> */</div><div class="line">public final static int MAX_PRIORITY = 10;</div></pre></td></tr></table></figure>
<h2 id="setPriority"><a href="#setPriority" class="headerlink" title="setPriority"></a>setPriority</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Changes the priority of this thread.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * ···</div><div class="line"> * ···</div><div class="line"> * Otherwise, the priority of this thread is set to the smaller of</div><div class="line"> * the specified &lt;code&gt;newPriority&lt;/code&gt; and the maximum permitted</div><div class="line"> * priority of the thread&apos;s thread group.</div><div class="line"> */</div><div class="line">public final void setPriority(int newPriority) &#123;</div><div class="line">    ThreadGroup g;</div><div class="line">    checkAccess();</div><div class="line">    if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</div><div class="line">        throw new IllegalArgumentException();</div><div class="line">    &#125;</div><div class="line">    if((g = getThreadGroup()) != null) &#123;</div><div class="line">        if (newPriority &gt; g.getMaxPriority()) &#123;// newProiority控制在当前线程组的最大值中。</div><div class="line">            newPriority = g.getMaxPriority();</div><div class="line">        &#125;</div><div class="line">        setPriority0(priority = newPriority);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private native void setPriority0(int newPriority);</div></pre></td></tr></table></figure>
<p>头注释也交代的很清楚，如果该传入的参数<code>newPriority</code>大于当前线程所在线程组的最大优先值得话就让该<code>newPriority</code>等于线程组的最大优先值。</p>
<h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><p>线程有3个基本状态：执行、就绪、阻塞</p>
<p>Thread上很多的方法都是用来切换线程的状态的，这一部分是重点！</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-8/94955655.jpg" alt=""></p>
<p>其实上面这个图是不够完整的，省略掉了一些东西。后面在讲解的线程状态的时候我会重新画一个。</p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Causes the currently executing thread to sleep (temporarily cease</div><div class="line"> * execution) for the specified number of milliseconds, subject to</div><div class="line"> * the precision and accuracy of system timers and schedulers. The thread</div><div class="line"> * does not lose ownership of any monitors.</div><div class="line"> */</div><div class="line">public static native void sleep(long millis) throws InterruptedException;</div></pre></td></tr></table></figure>
<p>如头注释所说在指定的毫秒数内让当前正在执行的线程休眠（阻塞状态）。且该线程不丢失任何监视器的所属权。</p>
<p>需要注意的是，等时间到了，<strong>进入的是就绪状态而并非是运行状态。</strong> 如图所示：</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-9/84736935.jpg" alt=""></p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A hint to the scheduler that the current thread is willing to yield</div><div class="line"> * its current use of a processor. The scheduler is free to ignore this</div><div class="line"> * hint</div><div class="line"> */</div><div class="line">public static native void yield();</div></pre></td></tr></table></figure>
<p>如头注释所述yield方法会向调度程序提示当前线程愿意让出正在使用的CPU，但是这个调度程序可以自由的忽略这个提示。<br>言外之意当前线程调用yield方法会先让别的线程执行，但是不不确保真正的让出了CPU，最终还是要看调度器是什么行为。该方法很少被使用，因为他并不是一个确定的行为。</p>
<ul>
<li>我有空，可以的话(CPU决定)，让你们先执行</li>
</ul>
<p>此时刚才的图就能补充成这样：<br><img src="http://otsgsfu16.bkt.clouddn.com/18-6-9/90517865.jpg" alt=""></p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>调用join方法，会等待该线程执行完毕后(死亡)才执行别的线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Waits for this thread to die.</div><div class="line"> */</div><div class="line">public final void join() throws InterruptedException &#123;</div><div class="line">    join(0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Waits at most &#123;@code millis&#125; milliseconds for this thread to</div><div class="line"> * die. A timeout of &#123;@code 0&#125; means to wait forever.</div><div class="line"> *</div><div class="line"> * &lt;p&gt; This implementation uses a loop of &#123;@code this.wait&#125; calls</div><div class="line"> * conditioned on &#123;@code this.isAlive&#125;. As a thread terminates the</div><div class="line"> * &#123;@code this.notifyAll&#125; method is invoked. It is recommended that</div><div class="line"> * applications not use &#123;@code wait&#125;, &#123;@code notify&#125;, or</div><div class="line"> * &#123;@code notifyAll&#125; on &#123;@code Thread&#125; instances.</div><div class="line"> */</div><div class="line">public final synchronized void join(long millis)</div><div class="line">    throws InterruptedException &#123;</div><div class="line">    long base = System.currentTimeMillis();// 记录当前系统时间 毫秒单位</div><div class="line">    long now = 0;</div><div class="line"></div><div class="line">    if (millis &lt; 0) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (millis == 0) &#123;</div><div class="line">        while (isAlive()) &#123;// millis == 0时，在当前线程活动状态下无线等待</div><div class="line">            wait(0);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        while (isAlive()) &#123;// millis非0有限定时间 一段时间内该线程没有死亡就不等了</div><div class="line">            long delay = millis - now;</div><div class="line">            if (delay &lt;= 0) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            wait(delay);</div><div class="line">            now = System.currentTimeMillis() - base;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>join(long millis)</code>方法头注释所述：</p>
<ul>
<li>等待该线程终止的时间最长为<code>millis</code>毫秒。如果<code>millis</code>为0意味着要一直等下去。</li>
<li>依赖isAlive()判断条件判断当前线程所处的状态，如果为活动状态那么循环调用wait方法直到其死亡。<ul>
<li>当线程终止时，调用notifyAll方法来唤醒。建议应用程序不要在Thread实例上使用wait，notify或notifyAll方法(像join方法所示类中直接调用)。</li>
</ul>
</li>
</ul>
<h3 id="join-方法参考资料"><a href="#join-方法参考资料" class="headerlink" title="join 方法参考资料"></a>join 方法参考资料</h3><ul>
<li><a href="https://www.zhihu.com/question/27485990/answer/36824828" target="_blank" rel="external">https://www.zhihu.com/question/27485990/answer/36824828</a></li>
</ul>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>wait方法是在Object上定义的，它是native本地方法。函数意图：在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final native void wait(long timeout) throws InterruptedException;</div></pre></td></tr></table></figure></p>
<p>wait方法实际上它也是<strong>计时等待(如果带时间参数)</strong> 的一种！，于是我们的图就可以补充为：</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-9/80274308.jpg" alt=""><br>等待处，即我们调用join方法来使当前线程在一段时间内等待其死亡，如果死亡了那么他就结束了。如果没有那就进入就绪态等待获取执行权继续执行。</p>
<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p>线程中断在之前的版本有stop方法，但是被设置过时了。现在已经<strong>没有强制线程终止的方法了</strong>！</p>
<p>由于stop方法可以让一个线程A终止掉另一个线程B</p>
<ul>
<li>被终止的线程B会<strong>立即释放锁</strong>，这可能会让<strong>对象处于不一致的状态。</strong></li>
<li><strong>线程A也不知道线程B什么时候能够被终止掉，</strong> 如果线程B还处于运行计算阶段，线程A调用stop方法将线程B终止，那么进度就丢失了。</li>
</ul>
<p>总而言之，Stop方法看起来设计的就很不合理，不安全而且太暴力，所以被设置过时了。</p>
<p>在终止线程上我们一般使用的是interrupt方法来<strong>请求终止线程。</strong></p>
<ul>
<li>要注意的是：<strong>interrupt不会真正停止一个线程</strong>，它仅仅是给这个线程发了一个信号告诉它，它应该要结束了(明白这一点非常重要！)</li>
<li>也就是说：Java设计者实际上是想<strong>线程自己来终止</strong>，通过上面的信号，就可以判断处理什么业务了。</li>
<li>具体到底中断还是继续运行，应该由<strong>被通知的线程自己处理</strong></li>
</ul>
<p>也就是我们不会杀死当前线程，只是给它标记了一个标志位告诉他他该中断了。但是具体是否要中断由它自己。</p>
<p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Thread t1 = <span class="keyword">new</span> Thread( <span class="keyword">new</span> Runnable()&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 若未发生中断，就正常执行任务</span></div><div class="line">        <span class="keyword">while</span>(!Thread.currentThread.isInterrupted())&#123;</div><div class="line">            <span class="comment">// 正常任务代码……</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 中断的处理代码……</span></div><div class="line">        doSomething();</div><div class="line">    &#125;</div><div class="line">&#125; ).start();</div></pre></td></tr></table></figure></p>
<p>再次说明：调用interrupt()<strong>并不是要真正终止掉当前线程</strong>，仅仅是设置了一个<strong>中断标志</strong>。这个中断标志可以给我们用来判断什么时候该干什么活！什么时候中断由我们自己来决定，这样就可以<strong>安全地终止线程了</strong>！</p>
<p>来看一下源码是如何叙述的：<br><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d8e16e2e908f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<ul>
<li>只有当前线程自己可以调用interrupt中断方法。否则会抛出SecurityException。</li>
<li>如果当前线程在调用Object的<code>wait()</code>，<code>wait(long)</code>或<code>wait(long, int)</code>方法，或者该类的 <code>join(),</code>、<code>join(long)</code>,<code>join(long, int)</code>,<code>sleep(long)</code>或 <code>sleep(long, int)</code>方法时被调用interrupt方法而中断了的话。由于那些方法本身已经使线程中断，所以interrupt方法在这里所做的功能就是解除线程中断的左右。所以该线程的中断状态将被解除，JVM会将线程的中断标志重新设置为false(interrupt方法有这个功能)，并且还将收到一个 InterruptedException。这些调用时会抛出InterruptedException的方法是支持线程中断的方法(就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常)。</li>
<li>被阻塞的类调用中断状态是没有意义的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void interrupt() &#123;</div><div class="line">    if (this != Thread.currentThread())// 判断是否是当前线程本身调用的</div><div class="line">        checkAccess();</div><div class="line"></div><div class="line">    synchronized (blockerLock) &#123;</div><div class="line">        Interruptible b = blocker;</div><div class="line">        if (b != null) &#123;// 判断线程是否被阻塞了</div><div class="line">            interrupt0();           // interrupt status将清除 </div><div class="line">            b.interrupt(this); // 打断线程并抛出InterruptedException</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    interrupt0();// 如果没有被阻塞那么直接修改线程中断标记位即可。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看看刚才说抛出的异常是什么东东吧：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d8e16e562fe4f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>所以说：<strong>interrupt方法压根是不会对线程的状态造成影响的，它仅仅设置一个标志位罢了</strong></p>
<p>interrupt线程中断还有另外<strong>两个方法(检查该线程是否被中断)</strong>：</p>
<ul>
<li>静态方法interrupted()–&gt;会清除中断标志位</li>
<li>实例方法isInterrupted()–&gt;不会清除中断标志位</li>
</ul>
<p><strong>interrupted()</strong></p>
<p>测试当前线程是否已经中断。如果已经中断那么调用该方法会清除线程的中断标志位，如果没有中断则返回false。函数功能相当于<strong>解除线程中断标志的功能</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static boolean interrupted() &#123;</div><div class="line">    return currentThread().isInterrupted(true);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>isInterrupted</strong></p>
<p>测试线程是否已经中断。线程的中断状态不受该方法的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean isInterrupted() &#123;</div><div class="line">    return isInterrupted(false);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面还提到了，如果阻塞线程调用了interrupt()方法，那么会抛出异常，设置标志位为false，同时该线程会退出阻塞的。我们来测试一波：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Main main = new Main();</div><div class="line"></div><div class="line">        // 创建线程并启动</div><div class="line">        Thread t = new Thread(main.runnable);</div><div class="line">        System.out.println(&quot;This is main &quot;);</div><div class="line">        t.start();</div><div class="line"></div><div class="line">        try &#123;</div><div class="line"></div><div class="line">            // 在 main线程睡个3秒钟</div><div class="line">            Thread.sleep(3000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            System.out.println(&quot;In main&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 设置中断</div><div class="line">        t.interrupt();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Runnable runnable = () -&gt; &#123;</div><div class="line">        int i = 0;</div><div class="line">        try &#123;</div><div class="line">            while (i &lt; 1000) &#123;</div><div class="line"></div><div class="line">                // 睡个半秒钟我们再执行</div><div class="line">                Thread.sleep(500);</div><div class="line"></div><div class="line">                System.out.println(i++);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line"></div><div class="line"></div><div class="line">            // 判断该阻塞线程是否还在</div><div class="line">            System.out.println(Thread.currentThread().isAlive());</div><div class="line"></div><div class="line">            // 判断该线程的中断标志位状态</div><div class="line">            System.out.println(Thread.currentThread().isInterrupted());</div><div class="line"></div><div class="line">            System.out.println(&quot;In Runnable&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d8e175c87cfbb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>接下来我们分析它的执行流程是怎么样的：<br><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d8e1786e316a1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>其实中心思想也就是我们新开的线程任在sleep的时候main线程中调用了t.interrupt方法让新线程中断。但是我们前面说过如下异常：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d8e16e562fe4f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>我们新线程正在调用sleep或者wait方法的时候会短暂的让该线程处于阻塞状态，阻塞状态下让该线程中断则是不合理的。那么就会设置其中断位为false并且跑出异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void interrupt() &#123;</div><div class="line">    if (this != Thread.currentThread())</div><div class="line">        checkAccess();</div><div class="line"></div><div class="line">    synchronized (blockerLock) &#123;</div><div class="line">        Interruptible b = blocker;</div><div class="line">        if (b != null) &#123;</div><div class="line">            interrupt0();           // Just to set the interrupt flag</div><div class="line">            b.interrupt(this);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    interrupt0();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次结合源码的处理逻辑来思考。</p>
<h3 id="interrupt-方法参考资料"><a href="#interrupt-方法参考资料" class="headerlink" title="interrupt 方法参考资料"></a>interrupt 方法参考资料</h3><ul>
<li>www.cnblogs.com/w-wfy/p/641…</li>
<li>www.cnblogs.com/carmanlonel…</li>
<li>www.zhihu.com/question/41…</li>
<li>www.zhihu.com/question/41…</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Thread-类-常见Api剖析&quot;&gt;&lt;a href=&quot;#Thread-类-常见Api剖析&quot; class=&quot;headerlink&quot; title=&quot;Thread 类 常见Api剖析&quot;&gt;&lt;/a&gt;Thread 类 常见Api剖析&lt;/h1&gt;&lt;h2 id=&quot;Thread类构造函数&quot;&gt;&lt;a href=&quot;#Thread类构造函数&quot; class=&quot;headerlink&quot; title=&quot;Thread类构造函数&quot;&gt;&lt;/a&gt;Thread类构造函数&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;public Thread() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    init(null, null, &amp;quot;Thread-&amp;quot; + nextThreadNum(), 0);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public Thread(Runnable target) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    init(null, target, &amp;quot;Thread-&amp;quot; + nextThreadNum(), 0);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public Thread(Runnable target, String name) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    init(null, target, name, 0);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public Thread(String name) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    init(null, null, name, 0);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="并发" scheme="http://www.jiyongguang.xin/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>thymeleaf渲染视图失败</title>
    <link href="http://www.jiyongguang.xin/templateEngine-thymeleaf.html"/>
    <id>http://www.jiyongguang.xin/templateEngine-thymeleaf.html</id>
    <published>2018-06-08T12:58:52.000Z</published>
    <updated>2018-06-08T13:03:09.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在最近做课设的时候，由于前台视图需要用到模板引擎来进行渲染，所以选用了thymeleaf这个模板引擎。但是在解析视图的时候却报了如下错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">org.thymeleaf.exceptions.TemplateProcessingException: Could not parse as expression: &quot;</div><div class="line">&#123;checkbox: true, fixed: true&#125;</div><div class="line">, &#123;field: &apos;originalFileName&apos;, title: &apos;文件名&apos;, width: 400, sort: true&#125;</div><div class="line">, &#123;field: &apos;fileType&apos;, title: &apos;文件类型&apos;, width: 100&#125;</div><div class="line">, &#123;field: &apos;fileSize&apos;, title: &apos;文件大小&apos;, width: 110, sort: true&#125;</div><div class="line">, &#123;field: &apos;createTime&apos;, title: &apos;上传时间&apos;, width: 170, sort: true&#125;</div><div class="line">, &#123;field: &apos;dpStatus&apos;, title: &apos;数据处理状态&apos;, width: 122, templet: &apos;#statusTpl&apos;, sort: true&#125;</div><div class="line">, &#123;field: &apos;updateTime&apos;, title: &apos;数据处理完成时间&apos;, width: 170, templet: &apos;#updateTimeTpl&apos;, sort: true&#125;</div><div class="line">, &#123;fixed: &apos;right&apos;, title: &apos;操作&apos;, align: &apos;center&apos;, width: 300, toolbar: &apos;#operating&apos;&#125;</div><div class="line">&quot; (template: &quot;textManagement&quot; - line 125, col 22)</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>即意为无法解析。这是因为<code>[[…]]</code>之间的表达式在thymeleaf被认为是内联表达式,所以渲染错误。</p>
<p>我们需要把其中所有的<code>[[ ]]</code>都改成如下这种写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line"></div><div class="line">    [</div><div class="line"></div><div class="line">    ]</div><div class="line"></div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>但由于我所用的视图文件是框架自动生成的，每个有2万+的代码，所以出现这种异常的地方也是数不胜数。后来我果断采取了另一种解决方式，换了另一种模板引擎。采用了Freemaker</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>解决方式也很简单，只需要<code>pom</code>文件把thymeleaf的依赖改成<code>freemaker</code>的依赖即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!--&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;--&gt;</div><div class="line"></div><div class="line">&lt;!-- 由于 thymeleaf 语法中[[…]]是它的内联表达式,不支持 echarts 生成的模板中的[[]]排版，所以会渲染错误，所以弃用 --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/rjkkaikai/article/details/80452128" target="_blank" rel="external"><br>thymeleaf+layui渲染错误</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在最近做课设的时候，由于前台视图需要用到模板引擎来进行渲染，所以选用了thymeleaf这个模板引擎。但是在解析视图的时候却报了如下错误:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;org.thymeleaf.exceptions.TemplateProcessingException: Could not parse as expression: &amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;checkbox: true, fixed: true&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;field: &amp;apos;originalFileName&amp;apos;, title: &amp;apos;文件名&amp;apos;, width: 400, sort: true&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;field: &amp;apos;fileType&amp;apos;, title: &amp;apos;文件类型&amp;apos;, width: 100&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;field: &amp;apos;fileSize&amp;apos;, title: &amp;apos;文件大小&amp;apos;, width: 110, sort: true&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;field: &amp;apos;createTime&amp;apos;, title: &amp;apos;上传时间&amp;apos;, width: 170, sort: true&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;field: &amp;apos;dpStatus&amp;apos;, title: &amp;apos;数据处理状态&amp;apos;, width: 122, templet: &amp;apos;#statusTpl&amp;apos;, sort: true&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;field: &amp;apos;updateTime&amp;apos;, title: &amp;apos;数据处理完成时间&amp;apos;, width: 170, templet: &amp;apos;#updateTimeTpl&amp;apos;, sort: true&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;fixed: &amp;apos;right&amp;apos;, title: &amp;apos;操作&amp;apos;, align: &amp;apos;center&amp;apos;, width: 300, toolbar: &amp;apos;#operating&amp;apos;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot; (template: &amp;quot;textManagement&amp;quot; - line 125, col 22)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.jiyongguang.xin/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="模板引擎" scheme="http://www.jiyongguang.xin/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 对resources-templates目录下的View视图文件访问404问题</title>
    <link href="http://www.jiyongguang.xin/springboot-thymeleaf-404.html"/>
    <id>http://www.jiyongguang.xin/springboot-thymeleaf-404.html</id>
    <published>2018-06-08T12:57:28.000Z</published>
    <updated>2018-06-08T13:03:09.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在做课设的时候Controller层原本要映射<code>resources</code>目录下的<code>templates</code>目录下html页面。但是不知道什么原因总是出现404的情况。无论访问任何<code>templates</code>下的视图都会出现这种情况。即静态资源无法映射，这让自己有点儿不解，对于SpringBoot而言，<code>resources</code>目录不是它默认的视图资源映射路径吗。应该是不走<code>DispatcherServlet</code>进行分发的啊，它是Vip通道啊，可为什么会出现这种情况呢？</p>
<p><img src="https://images2018.cnblogs.com/blog/1319881/201805/1319881-20180529005409093-778602346.png" alt=""></p>
<a id="more"></a>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>思考之后只有一种猜想有可能，<strong>默认映射肯定出问题了</strong>。说明SpringBoot的默认的静态资源的访问规则没有起作用。但是为什么会出现这种问题呢，网上查阅后说是启用了<code>@EnableWebMvc</code>这个注解。这个注解意思是你想完全地进行web配置，那么Spring就会忽略默认的配置信息，去寻找相应的你的设置文件。如果你没有设置，就会出现上面这个问题了。</p>
<p>可是我非常明确的是我并没有启用它，但不知道为什么还是莫名其妙的出现了这个问题。所以我就尝试着根据这个问题来进行解决它。只要配置我们默认的资源映射路径即可</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>由于原本的<code>WebMvcConfigurerAdapter</code>在Spring最新版本已经过时了。所以我们应该选用<code>WebMvcConfigurationSupport</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span></span>&#123;</div><div class="line">        registry.addResourceHandler(<span class="string">"/**"</span>)</div><div class="line">                .addResourceLocations(<span class="string">"classpath:/templates/"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就这样问题就解决了。</p>
<p>参考：<a href="https://www.cnblogs.com/wangnig/p/9103144.html" target="_blank" rel="external">SpringBoot添加对静态文件css/html/jpg等的直接访问的支持</a></p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>在找解决办法的时候在SegmentFault上看到的别人遇到的问题，虽然和我遇到的问题情况一样，但是问题却是不同的。但这个问题看上去也很难处理，所以这里简单记录一下，以防以后自己用到。</p>
<p>它也是正常配置，没有启用<code>@EnableWebMvc</code>这个注解。所以也没有自己配置<code>@Configuration</code>中静态资源的路径。而是jar包的问题，他清除了maven 的m2目录，然后打开项目让maven重新下载之后就解决了。</p>
<p>参考：<a href="https://segmentfault.com/q/1010000010541125" target="_blank" rel="external">Spring Boot项目访问template模板文件页面返回404</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在做课设的时候Controller层原本要映射&lt;code&gt;resources&lt;/code&gt;目录下的&lt;code&gt;templates&lt;/code&gt;目录下html页面。但是不知道什么原因总是出现404的情况。无论访问任何&lt;code&gt;templates&lt;/code&gt;下的视图都会出现这种情况。即静态资源无法映射，这让自己有点儿不解，对于SpringBoot而言，&lt;code&gt;resources&lt;/code&gt;目录不是它默认的视图资源映射路径吗。应该是不走&lt;code&gt;DispatcherServlet&lt;/code&gt;进行分发的啊，它是Vip通道啊，可为什么会出现这种情况呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1319881/201805/1319881-20180529005409093-778602346.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.jiyongguang.xin/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://www.jiyongguang.xin/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>net--error</title>
    <link href="http://www.jiyongguang.xin/net-error.html"/>
    <id>http://www.jiyongguang.xin/net-error.html</id>
    <published>2018-06-08T12:55:54.000Z</published>
    <updated>2018-06-08T13:03:09.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在做课设的时候自己找了几个不错的html想做视图，但是奈何映射的时候一直没有效果。后来网上查阅资料说是视图找不到依赖的资源文件所导致的。如下</p>
<p><img src="https://img-blog.csdn.net/20180410114028318?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUwODkz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<a id="more"></a>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>后来才发现自己确实资源文件的请求路径错了。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-1/29704824.jpg" alt=""></p>
<p>比如<code>navigat.ftl</code>视图需要引入static目录下的<code>style.css</code>文件。</p>
<p><strong>我之前的写法</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;../static/css/style.css&quot;/&gt;</div></pre></td></tr></table></figure>
<p>但是却忘记了对于SpringBoot而言static目录也是它默认的静态资源映射路径。所以相当于<code>templates</code>和<code>static</code>目录下的资源文件是在同一个文件目录下的。所以其实我们就不需要再在目录间切来切去的了 </p>
<p><strong>改正后的写法</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;/&gt;</div></pre></td></tr></table></figure>
<p>就这样问题解决啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在做课设的时候自己找了几个不错的html想做视图，但是奈何映射的时候一直没有效果。后来网上查阅资料说是视图找不到依赖的资源文件所导致的。如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180410114028318?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUwODkz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前台" scheme="http://www.jiyongguang.xin/categories/%E5%89%8D%E5%8F%B0/"/>
    
    
      <category term="前台" scheme="http://www.jiyongguang.xin/tags/%E5%89%8D%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java中的static关键字解析</title>
    <link href="http://www.jiyongguang.xin/java-keyword-static.html"/>
    <id>http://www.jiyongguang.xin/java-keyword-static.html</id>
    <published>2018-06-08T12:51:52.000Z</published>
    <updated>2018-06-08T13:03:09.352Z</updated>
    
    <content type="html"><![CDATA[<p>static关键字是很多朋友在编写代码和阅读代码时碰到的比较难以理解的一个关键字，也是各大公司的面试官喜欢在面试时问到的知识点之一。下面就先讲述一下static关键字的用法和平常容易误解的地方，最后列举了一些面试笔试中常见的关于static的考题。</p>
<p>转载自：海子：<a href="http://www.cnblogs.com/dolphin0520/p/3799052.html" target="_blank" rel="external">Java中的static关键字解析</a></p>
<h1 id="一、static关键字的用途"><a href="#一、static关键字的用途" class="headerlink" title="一、static关键字的用途"></a>一、static关键字的用途</h1><p>　　在《Java编程思想》P86页有这样一段话：</p>
<p>　　“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”</p>
<a id="more"></a>
<p>　　这段话虽然只是说明了static方法的特殊之处，但是可以看出static关键字的基本作用，简而言之，一句话来描述就是：</p>
<p>　　方便在没有创建对象的情况下来进行调用（方法/变量）。</p>
<p>　　很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。</p>
<p>　　static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。</p>
<h2 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h2><p>　　static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。
　　</p>
<p><strong>但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。</strong> 举个简单的例子：</p>
<p>在上面的代码中，由于print2方法是独立于对象存在的，可以直接用过类名调用。假如说可以在静态方法中访问非静态方法/变量的话，那么如果在main方法中有下面一条语句：</p>
<p>　　MyObject.print2();</p>
<p>　　此时对象都没有，str2根本就不存在，所以就会产生矛盾了。同样对于方法也是一样，由于你无法预知在print1方法中是否访问了非静态成员变量，所以也禁止在静态成员方法中访问非静态成员方法。</p>
<p>　　而对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的。</p>
<p>　　因此，如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。我们最常见的static方法就是main方法，至于为什么main方法必须是static的，现在就很清楚了。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。</p>
<p>　　另外记住，关于构造器是否是static方法可参考：<a href="http://blog.csdn.net/qq_17864929/article/details/48006835" target="_blank" rel="external">http://blog.csdn.net/qq_17864929/article/details/48006835</a></p>
<h2 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h2><p>　　static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p>
<p>　　static成员变量的初始化顺序按照定义的顺序进行初始化。</p>
<h2 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h2><p><strong>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。</strong> static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p>
<p>　　为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。下面看个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Person&#123;</div><div class="line">    private Date birthDate;</div><div class="line">     </div><div class="line">    public Person(Date birthDate) &#123;</div><div class="line">        this.birthDate = birthDate;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    boolean isBornBoomer() &#123;</div><div class="line">        Date startDate = Date.valueOf(&quot;1946&quot;);</div><div class="line">        Date endDate = Date.valueOf(&quot;1964&quot;);</div><div class="line">        return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　isBornBoomer是用来这个人是否是1946-1964年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Person&#123;</div><div class="line">    private Date birthDate;</div><div class="line">    private static Date startDate,endDate;</div><div class="line">    static&#123;</div><div class="line">        startDate = Date.valueOf(&quot;1946&quot;);</div><div class="line">        endDate = Date.valueOf(&quot;1964&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public Person(Date birthDate) &#123;</div><div class="line">        this.birthDate = birthDate;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    boolean isBornBoomer() &#123;</div><div class="line">        return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p>
<h1 id="二、static关键字的误区"><a href="#二、static关键字的误区" class="headerlink" title="二、static关键字的误区"></a>二、static关键字的误区</h1><h2 id="static关键字会改变类中成员的访问权限吗？"><a href="#static关键字会改变类中成员的访问权限吗？" class="headerlink" title="static关键字会改变类中成员的访问权限吗？"></a>static关键字会改变类中成员的访问权限吗？</h2><p>　　有些初学的朋友会将java中的static与C/C++中的static关键字的功能混淆了。在这里只需要记住一点：与C/C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。看下面的例子就明白了：</p>
<p>　　提示错误”Person.age 不可视”，这说明static关键字并不会改变变量和方法的访问权限。</p>
<h2 id="能通过this访问静态成员变量吗？"><a href="#能通过this访问静态成员变量吗？" class="headerlink" title="能通过this访问静态成员变量吗？"></a>能通过this访问静态成员变量吗？</h2><p>　　虽然对于静态方法来说没有this，那么在非静态方法中能够通过this访问静态成员变量吗？先看下面的一个例子，这段代码输出的结果是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;　　</div><div class="line">    static int value = 33;</div><div class="line"> </div><div class="line">    public static void main(String[] args) throws Exception&#123;</div><div class="line">        new Main().printValue();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    private void printValue()&#123;</div><div class="line">        int value = 3;</div><div class="line">        System.out.println(this.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　这里面主要考察队this和static的理解。this代表什么？this代表当前对象，那么通过new Main()来调用printValue的话，当前对象就是通过new Main()生成的对象。而static变量是被对象所享有的，因此在printValue中的this.value的值毫无疑问是33。在printValue方法内部的value是局部变量，根本不可能与this关联，所以输出结果是33。在这里永远要记住一点：<strong>静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。</strong></p>
<h2 id="static能作用于局部变量么？"><a href="#static能作用于局部变量么？" class="headerlink" title="static能作用于局部变量么？"></a>static能作用于局部变量么？</h2><p>　　在C/C++中static是可以作用域局部变量的，但是在Java中切记：<strong>static是不允许用来修饰局部变量。</strong>，这是Java语法的规定。</p>
<p>　　具体原因可以参考这篇博文的讨论：<a href="http://www.debugease.com/j2se/178932.html" target="_blank" rel="external">Java static关键字为什么不能应用于局部变量？</a></p>
<h1 id="三、常见的笔试面试题"><a href="#三、常见的笔试面试题" class="headerlink" title="三、常见的笔试面试题"></a>三、常见的笔试面试题</h1><p>　　下面列举一些面试笔试中经常遇到的关于static关键字的题目，仅供参考，如有补充欢迎下方留言。</p>
<p><strong>1.下面这段代码的输出结果是什么？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Test extends Base&#123;</div><div class="line"> </div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;test static&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public Test()&#123;</div><div class="line">        System.out.println(&quot;test constructor&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new Test();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Base&#123;</div><div class="line">     </div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;base static&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public Base()&#123;</div><div class="line">        System.out.println(&quot;base constructor&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　至于为什么是这个结果，我们先不讨论，先来想一下这段代码具体的执行过程，在执行开始，先要寻找到main方法，因为main方法是程序的入口，<strong>但是在执行main方法之前，必须先加载Test类(加载Test类是执行Main方法的前驱事件，必须先把其所在类进行加载 )，</strong> 而在加载Test类的时候发现Test类继承自Base类，因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现Test类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行new Test()的时候会先调用父类的构造器，然后再调用自身的构造器。因此，便出现了上面的输出结果。</p>
<p><strong>2.这段代码的输出结果是什么？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    Person person = new Person(&quot;Test&quot;);</div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;test static&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public Test() &#123;</div><div class="line">        System.out.println(&quot;test constructor&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new MyClass();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Person&#123;</div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;person static&quot;);</div><div class="line">    &#125;</div><div class="line">    public Person(String str) &#123;</div><div class="line">        System.out.println(&quot;person &quot;+str);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">class MyClass extends Test &#123;</div><div class="line">    Person person = new Person(&quot;MyClass&quot;);</div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;myclass static&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public MyClass() &#123;</div><div class="line">        System.out.println(&quot;myclass constructor&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　类似地，我们还是来想一下这段代码的具体执行过程。首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。<strong>而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，</strong> 而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。</p>
<p><strong>3.这段代码的输出结果是什么？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">     </div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;test static 1&quot;);</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;test static 2&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　虽然在main方法中没有任何语句，但是还是会输出，原因上面已经讲述过了。另外，static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的。</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>　　<a href="http://lavasoft.blog.51cto.com/62575/18771/" target="_blank" rel="external">http://lavasoft.blog.51cto.com/62575/18771/</a></p>
<p>　　<a href="http://www.51cto.com/specbook/24/35011.htm" target="_blank" rel="external">http://www.51cto.com/specbook/24/35011.htm</a></p>
<p>　　<a href="http://blog.csdn.net/zhu_apollo/article/details/1888219" target="_blank" rel="external">http://blog.csdn.net/zhu_apollo/article/details/1888219</a></p>
<p>　　<a href="http://blog.sina.com.cn/s/blog_70b845780100n9zz.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_70b845780100n9zz.html</a></p>
<p>　　<a href="http://hi.baidu.com/yuiezt/item/b71ff5fbfe9c385cc8f3370d" target="_blank" rel="external">http://hi.baidu.com/yuiezt/item/b71ff5fbfe9c385cc8f3370d</a></p>
<p>　　<a href="http://bbs.csdn.net/topics/330251070" target="_blank" rel="external">http://bbs.csdn.net/topics/330251070</a></p>
<p>　　<a href="http://yezixingchen.iteye.com/blog/1597186" target="_blank" rel="external">http://yezixingchen.iteye.com/blog/1597186</a></p>
<p>　　《Java编程思想》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;static关键字是很多朋友在编写代码和阅读代码时碰到的比较难以理解的一个关键字，也是各大公司的面试官喜欢在面试时问到的知识点之一。下面就先讲述一下static关键字的用法和平常容易误解的地方，最后列举了一些面试笔试中常见的关于static的考题。&lt;/p&gt;
&lt;p&gt;转载自：海子：&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3799052.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java中的static关键字解析&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、static关键字的用途&quot;&gt;&lt;a href=&quot;#一、static关键字的用途&quot; class=&quot;headerlink&quot; title=&quot;一、static关键字的用途&quot;&gt;&lt;/a&gt;一、static关键字的用途&lt;/h1&gt;&lt;p&gt;　　在《Java编程思想》P86页有这样一段话：&lt;/p&gt;
&lt;p&gt;　　“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多线程简单了解一下</title>
    <link href="http://www.jiyongguang.xin/multi-threading.html"/>
    <id>http://www.jiyongguang.xin/multi-threading.html</id>
    <published>2018-06-08T12:25:07.000Z</published>
    <updated>2018-06-08T12:26:43.501Z</updated>
    
    <content type="html"><![CDATA[<p>参考自：<br>Fysddsw_lc：<a href="https://juejin.im/post/5acf05515188255c6163625d" target="_blank" rel="external">java 多线程</a></p>
<h1 id="进程，线程"><a href="#进程，线程" class="headerlink" title="进程，线程"></a>进程，线程</h1><p><strong>进程：</strong></p>
<p>进程是程序或者任务的执行过程，<strong>进程是系统进行资源分配和调度的独立单位。</strong> 每一个进程都有它自己的内存空间和系统资源。他是内存和线程的载体。</p>
<ul>
<li>每个进程在执行的时候都会被分配内存</li>
<li>其中的线程就比如QQ在聊天的线程和接受文件的线程等，处理同一个进程(程序)不同任务的执行。</li>
</ul>
<p><strong>进程已经是可以进行资源分配和调度了，为什么还要线程呢？</strong></p>
<a id="more"></a>
<p>多任务处理被所有的现代操作系统所支持。然而，多任务处理有两种截然不同的类型：基于进程的和基于线程的。</p>
<p>基于进程的多任务处理是更熟悉的形式。进程（process）本质上是一个执行的程序。因此基于进程的多任务处理的特点是允许你的计算机同时运行两个或更多的程序。</p>
<p>比如，基于进程的多任务处理是你在编辑文本的时候可以同时运行Java编译器。</p>
<p>为使程序能并发执行，系统必须进行以下的一系列操作：</p>
<ol>
<li>创建进程，系统在创建一个进程时，必须为它分配其所必需的、除处理机以外的所有资源，如内存空间、I/O设备，以及建立相应的PCB；</li>
<li>撤消进程，系统在撤消进程时，又必须先对其所占有的资源执行回收操作，然后再撤消PCB；</li>
<li>进程切换，对进程进行上下文切换时，需要保留当前进程的CPU环境，设置新选中进程的CPU环境，因而须花费不少的处理机时间。</li>
</ol>
<p>如图所示：<br><img src="https://upload-images.jianshu.io/upload_images/5291509-7efab3cb7f00d193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>可以看到进程实现多处理机环境下的进程调度，分派，切换时，<strong>都需要花费较大的时间和空间开销</strong></p>
<p>而在基于线程（thread-based）的多任务处理环境中，线程是最小的执行单位。这意味着一个程序可以同时执行两个或者多个任务的功能。</p>
<p>比如，一个文本编辑器可以在打印的同时格式化文本。</p>
<p>而线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以线程的切换负担比进程切换的负担要小。引入线程主要是<strong>为了提高系统的执行效率，减少处理机的空转时间和调度切换的时间，以及便于系统管理。</strong> 使OS具有更好的并发性</p>
<p>简单来说：进程实现多处理非常耗费CPU的资源，而我们引入线程是作为调度和分派的基本单位（取代进程的部分基本功能【调度】）。</p>
<p><strong>线程：</strong></p>
<p>线程是系统中最小的执行单元，进程的一个实体，是CPU调度和分派的基本单位。同样的进程中可以有多个线程，而线程共享进程的资源。<strong>多线程编程的目的，就是“最大限度地利用cpu资源”</strong></p>
<p>线程交互方式：</p>
<ul>
<li>互斥：通常表现在多个线程竞争同一资源，所以也就面临着线程等待的问题</li>
<li>同步：同步就是协同步调，按预定的先后次序进行运行。如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行；B依言执行，再将结果给A；A再继续操作。</li>
</ul>
<h2 id="线程-vs-进程"><a href="#线程-vs-进程" class="headerlink" title="线程 vs 进程"></a>线程 vs 进程</h2><ul>
<li>进程作为资源<strong>分配</strong>的基本单位</li>
<li>线程作为资源<strong>调度</strong>的基本单位，是程序的执行单元，执行路径(单线程：一条执行路径，多线程：多条执行路径)。是程序使用CPU的最基本单位。</li>
</ul>
<h2 id="并发，并行"><a href="#并发，并行" class="headerlink" title="并发，并行"></a>并发，并行</h2><p><strong>并行：</strong></p>
<ul>
<li>并行性是指同一时刻内发生两个或多个事件。</li>
<li>并行是在不同实体上的多个事件</li>
</ul>
<p><strong>并发：</strong></p>
<ul>
<li>并发性是指同一时间间隔内发生两个或多个事件。</li>
<li>并发是在同一实体上的多个事件</li>
</ul>
<p>由此可见：并行是针对进程的，并发是针对线程的。</p>
<h1 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h1><p>在Java中通过run方法为线程指明要完成的任务，有两种技术来为线程提供run方法：</p>
<ol>
<li>继承Thread类并重写它的run方法。之后创建这个子类的对象并调用start()方法。</li>
<li>通过定义实现Runnable接口的实现类进而实现run方法。这个类的对象在创建Thread对象的时候会被作为参数而传入，然后调用Thread对象的start()方法。</li>
</ol>
<p>两种方法都需要执行线程Thread的start()方法为线程分配必须的系统资源，调度线程运行并执行线程的run（）方法。</p>
<p><strong>需要注意的是：</strong></p>
<ul>
<li>start（）方法是启动线程的唯一的方法。start()方法首先为线程的执行准备好系统资源，然后再去调用它的run（）方法。一个线程只能启动一次，再次启动就不合法了。</li>
<li>run（）方法中放入了线程的逻辑，即我们要这个线程去做事情。</li>
</ul>
<p>通常我一般是使用第二种方法来实现的，第一种方式会在单继承的规则上制约我们的扩展。即当一个线程已经继承了另一个类时，只能用第二种方法来构造，即实现Runnable接口。</p>
<h2 id="Thread-实现"><a href="#Thread-实现" class="headerlink" title="Thread 实现"></a>Thread 实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">    static class SonOfThread extends Thread &#123;</div><div class="line"></div><div class="line">        private String threadName;</div><div class="line"></div><div class="line">        public SonOfThread(String threadName) &#123;</div><div class="line">            this.threadName = threadName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">                System.out.println(threadName + &quot; : &quot; + i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        SonOfThread sonOfThread = new SonOfThread(&quot;sonOfThread&quot;);</div><div class="line"></div><div class="line">        sonOfThread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当使用第一种方式（继承Thread的方式）来生成线程对象时，我们需要重写run()方法，因为Thread类的run()方法默认是调用构造Thread对象时传入的Runnable接口的实现类对象的run方法。但我们这里并没有打算通过这种方式构建Thread对象，所以这里默认的run函数什么都不会做，我们应该重写它。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* What will be run. */</span></div><div class="line"><span class="keyword">private</span> Runnable target;</div><div class="line">····</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">        target.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Runnable-实现"><a href="#Runnable-实现" class="headerlink" title="Runnable 实现"></a>Runnable 实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">    static class MyThread implements Runnable &#123;</div><div class="line">    </div><div class="line">        private String threadName;</div><div class="line"></div><div class="line">        public MyThread(String threadName) &#123;</div><div class="line">            this.threadName = threadName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line"></div><div class="line">            for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">                System.out.println(threadName + &quot; : &quot; + i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        MyThread myThread = new MyThread(&quot;myThread&quot;);</div><div class="line">        Thread thread = new Thread(myThread);</div><div class="line"></div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实还是很好理解的，我们最终都要执行线程的run方法，而start方法是run方法执行的唯一入口，我们只能通过Thread对象来显示的调用start方法来为线程的执行准备好系统资源，并由start方法来后续调用run方法。</p>
<h2 id="Runnable源码"><a href="#Runnable源码" class="headerlink" title="Runnable源码"></a>Runnable源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.lang;</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>需要注意的是：</strong></p>
<p>当生成一个线程对象时，如果没有为其指定名字，那么线程对象的名字将使用如下形式：<code>Thread-number</code>，该number是自动增加的数字，并被所有的Thread对象所共享，因为它是一个static的成员变量。</p>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程　"></a>停止线程　</h2><p>现在线程的消亡不能通过调用stop()命令，应该让run()方法自然结束。stop()方法是不安全的，已经废弃。</p>
<p>　　停止线程推荐的方式：设定一个标志变量，在run()方法中是一个循环，由该标志变量控制循环是继续执行还是跳出；循环跳出，则线程结束。
　　</p>
<h1 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h1><p><strong>值得注意的是：</strong> 多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率，程序的执行其实都是在抢CPU的资源，CPU的执行权。多个进程是在抢这个资源，而其中的某一个进程如果执行路径比较多，就会有更高的几率抢到CPU的执行权</p>
<p>多线程编程很常见的情况下是希望多个线程共享资源， 通过多个线程同时消费资源来提高效率，但是新手一不小心很容易陷入一个编码误区。</p>
<p>举个例子：</p>
<p>下面的代码，希望通过 3 个线程同时执行 i– ，使得输出i的值为 0，但3次输出的结果都为2。这是因为在main方法中创建的三个线程都独自持有一个i变量，该变量式线程独有的，它并非static变量并不是线程共有的。我们的目的应该是3个线程共享一个i变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class ThreadTest1 extends Thread &#123;</div><div class="line">    private int i = 3;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        i--;</div><div class="line">        System.out.println(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ThreadTest &#123;</div><div class="line">    public static void main(String[] strings) &#123;</div><div class="line">        Thread thread1 = new ThreadTest1();</div><div class="line">        thread1.start();</div><div class="line">        Thread thread2 = new ThreadTest1();</div><div class="line">        thread2.start();</div><div class="line">        Thread thread3 = new ThreadTest1();</div><div class="line">        thread3.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出 // 2 2 2</div></pre></td></tr></table></figure></p>
<p>在这种非共有变量的情况下我们应该这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">应该这么写</div><div class="line"></div><div class="line">public class ThreadTest &#123;</div><div class="line">    public static void main(String[] strings) &#123;</div><div class="line">        Thread thread1 = new ThreadTest1();</div><div class="line">        thread1.start();</div><div class="line">        thread1.start();</div><div class="line">        thread1.start();    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即让该线程的run方法执行3次。每次对i进行<code>--</code>操作。</p>
<h2 id="多个线程执行同样的代码"><a href="#多个线程执行同样的代码" class="headerlink" title="多个线程执行同样的代码"></a>多个线程执行同样的代码</h2><p>在这种情况下，可以使用同一个Runnable对象（看上一篇博客，这是一种创建线程的方式）将需要共享的数据，植入这个Runnable对象里面。例如买票系统，余票是需要共享的，不过在这样做的时候，我想还应该加上synchronized关键字修饰！</p>
<h2 id="多个线程执行的代码不一样"><a href="#多个线程执行的代码不一样" class="headerlink" title="多个线程执行的代码不一样"></a>多个线程执行的代码不一样</h2><p>在这种情况下，就两种思路可以实现（这里参考张孝祥老师的观点）</p>
<p>其一：将共享数据封装再另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。每个线程对共享数据的操作方法也分配到那个对象身上去完成，这样容易实现对改数据进行的各个操作的互斥和通信。</p>
<p>其二：将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方法也分配给外部类，以便实现对共享数据进行的各个操作的互斥和通信，作为内部类的各个Runnable对象调用外部类的这些方法。</p>
<p>组合：将共享数据封装再另外一个对象中，每个线程对共享数据的操作方法也分配到那个对象身上去完成，对象作为这个外部类中的成员变量或方法中的局部变量，每个线程的Runnable对象作为外部类中的成员内部类或局部内部类。（示例代码所使用的方法），总之，要同步互斥的几段代码最好是分别放在几个独立的方法中，这些方法再放在同一个类中，这样比较好容易实现它们之间的同步互斥通信</p>
<h2 id="简单粗暴的方式"><a href="#简单粗暴的方式" class="headerlink" title="简单粗暴的方式"></a>简单粗暴的方式</h2><p>在程序中，定义一个static变量</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>线程的生命周期其实就是一个线程从创建到消亡的过程。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-8/94955655.jpg" alt=""></p>
<p>线程可以有6种状态：</p>
<p>New（新创建），Runnable（可运行），Blocked（被阻塞），Waiting（等待），Timed waiting（计时等待） Terminated(被终止)。</p>
<p>要想确定一个线程的当前状态，可调用getState()方法。</p>
<h2 id="1-创建状态"><a href="#1-创建状态" class="headerlink" title="1.创建状态"></a>1.创建状态</h2><p>当用new操作符创建一个新的线程对象时，如 new Thread(t)，该线程还没有开始运行,该线程处于创建状态，程序还没有开始运行线程中代码。<strong>处于创建状态的线程只是一个空的线程对象，系统不为它分配资源。</strong></p>
<h2 id="2-可运行状态"><a href="#2-可运行状态" class="headerlink" title="2.可运行状态"></a>2.可运行状态</h2><p>一旦调用了start()方法，线程处于<strong>runnable</strong>状态。一个可运行的线程可能正在运行页可能没有运行，<strong>这取决于操作系统给线程提供运行的时间。</strong></p>
<p> 一旦一个线程开始运行，它不必始终保持运行。事实上，运行的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。</p>
<p> 记住，在任何给定时刻，一个可运行的线程可能正在运行页可能没有运行，这就是为什么说成为runnable状态后才能为可运行而不是运行。</p>
<h2 id="3-不可运行状态"><a href="#3-不可运行状态" class="headerlink" title="3.不可运行状态"></a>3.不可运行状态</h2><p>不可运行状态包括被<strong>阻塞或等待</strong>状态，此时线程暂时不活动，不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。</p>
<p>当一个线程试图获取一个内部的对象锁，而该锁被其他线程所持有，则进入阻塞状态。当所有其他线程释放完琐，线程调度器允许该线程持有它的时候，该线程将变成非阻塞状态。</p>
<p>当线程等待另一个线程通知 调度器调度一个条件时，它自己进入等待转态。在thread对象调用wait方法和join方法时，就会出现这种情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final void wait()&#123;&#125;</div><div class="line"></div><div class="line">在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。</div><div class="line"></div><div class="line">public final void join(long millis)&#123;&#125;</div><div class="line"></div><div class="line">等待该线程终止。</div></pre></td></tr></table></figure>
<p>有些方法有一个超时参数，例如，sleep，wait，join。调用他们导致线程进入计时等待状态。这一状态将保持到超时期满或者受到适当通知。</p>
<p><strong>通俗一点：</strong></p>
<p><strong>当发生下列事件时，处于运行状态的线程会转入到不可运行状态：</strong></p>
<ul>
<li>调用了sleep()方法；</li>
<li>线程调用wait()方法等待特定条件的满足；</li>
<li>线程输入/输出阻塞。</li>
</ul>
<p><strong>返回可运行状态：</strong></p>
<ul>
<li><p>处于睡眠状态的线程在指定的时间过去后；</p>
</li>
<li><p>如果线程在等待某一条件，另一个对象必须通过notify()或notifyAll()方法通知等待线程条件的改变；</p>
</li>
<li><p>如果线程是因为输入输出阻塞，等待输入输出完成。</p>
</li>
</ul>
<h2 id="4-被终止状态"><a href="#4-被终止状态" class="headerlink" title="4.被终止状态"></a>4.被终止状态</h2><p>线程因如下两个原因之一而被终止：</p>
<ul>
<li>因为run方法正常退出而自然消亡</li>
<li>因为一个没有捕获的异常终止了run方法而消亡</li>
</ul>
<h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>Java线程有优先级的设定，高优先级的线程比低优先级的线程有更高的几率得到执行。</p>
<ol>
<li>当前线程没有指定优先级时，所有线程都是普通优先级。</li>
<li>优先级从1到10的范围指定。10表示最高优先级，1表示最低优先级，5是普通优先级。</li>
<li>优先级最高的线程在执行时被给予优先。但是<strong>不能保证线程在启动时就进入运行状态。</strong></li>
<li>与在线程池中等待运行机会的线程相比，<strong>正在运行的线程可能总是拥有更高的优先级。</strong></li>
<li>由调度程序决定哪一个线程被执行。</li>
<li><code>t.setPriority()</code>用来设定线程的优先级。</li>
<li><strong>记住在线程开始方法被调用之前，线程的优先级应该被设定。</strong></li>
<li>你可以使用常量，如<code>MIN_PRIORITY,MAX_PRIORITY</code>，<code>NORM_PRIORITY</code>来设定优先级Java线程的优先级是一个整数，其取值范围是1(<code>Thread.MIN_PRIORITY</code>) —— 10(<code>Thread.MAX_PRIORITY</code>)。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static final int MIN_PRIORITY = 1;</div><div class="line">public static final int NORM_PRIORITY = 5;</div><div class="line">public static final int MAX_PRIORITY = 10;</div></pre></td></tr></table></figure>
<p>可以通过setPriority方法（final的，不能被子类重载）更改优先级。优先级不能超过1-10的取值范围，否则抛出IllegalArgumentException。<strong>另外如果该线程已经属于一个线程组（ThreadGroup），该线程的优先级不能超过该线程组的优先级。</strong></p>
<h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><p>通过前面的理论论述我们知道了Java实现多线程是通过Thread类来实现的。所以我们接下来了解一下Thread这个类</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-e1f448bb431cf3e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>可以根据图中标注处来了解Thread类的声明规范。但该图标注处并非我所翻译。所以其实该图是有对源码理解有误的地方的。</p>
<p>可以结合<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="external">jdk中文官方文档</a>来理解。</p>
<p><strong>总的来说：</strong></p>
<ol>
<li>Java 虚拟机允许应用程序并发地运行多个执行线程</li>
<li>每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。</li>
<li>每个线程都可能被标记为一个守护程序。</li>
<li>当某个线程中运行的代码创建一个新 Thread 对象时，该新线程的初始优先级被设定为创建线程的优先级，并且当且仅当创建线程是守护线程时，被创建的新线程才是守护程序。</li>
<li>当 Java 虚拟机启动时，通常都会有一个非守护线程（它通常调用一些指定类的main方法）Java虚拟机将继续执行线程，直到出现以下任一情况。<ul>
<li>调用了 Runtime 类的 exit 方法，并且安全管理器允许退出操作发生。</li>
<li>非守护线程的所有线程都已停止运行，无论是通过从对 run 方法的调用中返回，还是通过抛出一个传播到 run 方法之外的异常。</li>
</ul>
</li>
<li>创建新执行线程有两种方法。<ul>
<li>一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。接下来可以分配并启动该子类的实例。</li>
<li>另一种方法是声明实现 Runnable 接口的实现类。该类要实现Runnable接口的 run 方法。然后再声明一个该类的实例，并在创建 Thread 实例时作为其构造函数的参数来传入并调用其start函数来启动该线程。</li>
</ul>
</li>
<li>每个线程都有一个标识名，多个线程可以同名。如果线程创建时没有指定标识名，就会为其生成一个新名称。</li>
<li>除非函数特别表情，否则将一个为null的参数传递给构造函数或者其他函数都会抛出一个空指针异常。</li>
</ol>
<p>之前我们说过了创建多线程的两种方式，这里测试一下运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">    static class MyThread implements Runnable &#123;</div><div class="line">        private String threadName;</div><div class="line"></div><div class="line">        public MyThread(String threadName) &#123;</div><div class="line">            this.threadName = threadName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line"></div><div class="line">            for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">                System.out.println(threadName + &quot; : &quot; + i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class SonOfThread extends Thread &#123;</div><div class="line"></div><div class="line">        private String threadName;</div><div class="line"></div><div class="line">        public SonOfThread(String threadName) &#123;</div><div class="line">            this.threadName = threadName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">                System.out.println(threadName + &quot; : &quot; + i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        MyThread myThread = new MyThread(&quot;myThread&quot;);</div><div class="line">        Thread thread = new Thread(myThread);</div><div class="line"></div><div class="line">        SonOfThread sonOfThread = new SonOfThread(&quot;sonOfThread&quot;);</div><div class="line"></div><div class="line">        sonOfThread.start();</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-8/61675035.jpg" alt=""></p>
<p>最后都会正确输出各自线程的处理结果99。</p>
<h1 id="关于Thread需要注意的点"><a href="#关于Thread需要注意的点" class="headerlink" title="关于Thread需要注意的点"></a>关于Thread需要注意的点</h1><p><strong>run()和start()方法区别：</strong></p>
<ul>
<li>run():仅仅是封装被线程执行的代码，直接调用是普通方法，线程并没有启动，系统资源也就更不会被分配了。</li>
<li>start():首先启动了线程，然后再由jvm去调用该线程的run()方法。</li>
</ul>
<hr>
<p><strong>jvm虚拟机的启动是单线程的还是多线程的?</strong></p>
<p>是多线程的。不仅仅是启动main线程，还至少会启动垃圾回收线程的，不然谁帮你回收不用的内存~</p>
<hr>
<p><strong>两种方式实现多线程，我们使用哪一种？</strong></p>
<p>一般我们使用实现Runnable接口</p>
<ul>
<li>可以避免java中的单继承的限制</li>
<li>应该将并发运行任务和运行机制解耦，因此我们选择实现Runnable接口这种方式！</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考自：&lt;br&gt;Fysddsw_lc：&lt;a href=&quot;https://juejin.im/post/5acf05515188255c6163625d&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;java 多线程&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;进程，线程&quot;&gt;&lt;a href=&quot;#进程，线程&quot; class=&quot;headerlink&quot; title=&quot;进程，线程&quot;&gt;&lt;/a&gt;进程，线程&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;进程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程是程序或者任务的执行过程，&lt;strong&gt;进程是系统进行资源分配和调度的独立单位。&lt;/strong&gt; 每一个进程都有它自己的内存空间和系统资源。他是内存和线程的载体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个进程在执行的时候都会被分配内存&lt;/li&gt;
&lt;li&gt;其中的线程就比如QQ在聊天的线程和接受文件的线程等，处理同一个进程(程序)不同任务的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进程已经是可以进行资源分配和调度了，为什么还要线程呢？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="并发" scheme="http://www.jiyongguang.xin/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 如何有效地避免OOM：善于利用软引用和弱引用</title>
    <link href="http://www.jiyongguang.xin/reference.html"/>
    <id>http://www.jiyongguang.xin/reference.html</id>
    <published>2018-06-07T08:31:35.000Z</published>
    <updated>2018-06-07T08:32:37.278Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p>
<p>海子：<a href="http://www.cnblogs.com/dolphin0520/p/3784171.html" target="_blank" rel="external">Java 如何有效地避免OOM：善于利用软引用和弱引用</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想必很多朋友对OOM（OutOfMemory）这个错误不会陌生，而当遇到这种错误如何有效地解决这个问题呢？今天我们就来说一下如何利用软引用和弱引用来有效地解决程序中出现的OOM问题。</p>
<h1 id="了解-强引用、软引用、弱引用、虚引用的概念"><a href="#了解-强引用、软引用、弱引用、虚引用的概念" class="headerlink" title="了解 强引用、软引用、弱引用、虚引用的概念"></a>了解 强引用、软引用、弱引用、虚引用的概念</h1><p>在Java中，虽然不需要程序员手动去管理对象的生命周期，但是如果希望某些对象具备一定的生命周期的话（比如内存不足时JVM就会自动回收某些对象从而避免OutOfMemory的错误）就需要用到软引用和弱引用了。</p>
<a id="more"></a>
<p>　　从Java SE2开始，就提供了四种类型的引用：强引用、软引用、弱引用和虚引用。Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。下面来阐述一下这四种类型引用的概念：</p>
<h2 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h2><p>　　强引用就是指在程序代码之中普遍存在的，比如下面这段代码中的object和str都是强引用：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object object = new Object();</div><div class="line">String str = &quot;hello&quot;;</div></pre></td></tr></table></figure></p>
<p>只要某个对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。比如下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new Main().fun1();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public void fun1() &#123;</div><div class="line">        Object object = new Object();</div><div class="line">        Object[] objArr = new Object[1000];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当运行至Object[] objArr = new Object[1000];这句时，如果内存不足，JVM会抛出OOM错误也不会回收object指向的对象。不过要注意的是，当fun1运行完之后，object和objArr都已经不存在了，所以它们指向的对象都会被JVM回收。</p>
<p>　　如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。</p>
<p>　　比如Vector类的clear方法中就是通过将引用赋值为null来实现清理工作的：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Removes the element at the specified position in this Vector.</div><div class="line"> * Shifts any subsequent elements to the left (subtracts one from their</div><div class="line"> * indices).  Returns the element that was removed from the Vector.</div><div class="line"> *</div><div class="line"> * @throws ArrayIndexOutOfBoundsException if the index is out of range</div><div class="line"> *         (&#123;@code index &lt; 0 || index &gt;= size()&#125;)</div><div class="line"> * @param index the index of the element to be removed</div><div class="line"> * @return element that was removed</div><div class="line"> * @since 1.2</div><div class="line"> */</div><div class="line">public synchronized E remove(int index) &#123;</div><div class="line">modCount++;</div><div class="line">if (index &gt;= elementCount)</div><div class="line">    throw new ArrayIndexOutOfBoundsException(index);</div><div class="line">Object oldValue = elementData[index];</div><div class="line"></div><div class="line">int numMoved = elementCount - index - 1;</div><div class="line">if (numMoved &gt; 0)</div><div class="line">    System.arraycopy(elementData, index+1, elementData, index,</div><div class="line">             numMoved);</div><div class="line">elementData[--elementCount] = null; // Let gc do its work</div><div class="line"></div><div class="line">return (E)oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h2><p>软引用是用来描述一些有用但并不是必需的对象，在Java中用java.lang.ref.SoftReference类来表示。<strong>对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。</strong> 因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>
<p>　　软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。下面是一个使用示例：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import java.lang.ref.SoftReference;</div><div class="line"> </div><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">         </div><div class="line">        SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String(&quot;hello&quot;));</div><div class="line">        System.out.println(sr.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h2><p>　　弱引用也是用来描述非必需对象的，<strong>当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。</strong> 在java中，用java.lang.ref.WeakReference类来表示。下面是使用示例：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import java.lang.ref.WeakReference;</div><div class="line"> </div><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">     </div><div class="line">        WeakReference&lt;String&gt; sr = new WeakReference&lt;String&gt;(new String(&quot;hello&quot;));</div><div class="line">         </div><div class="line">        System.out.println(sr.get());</div><div class="line">        System.gc();                //通知JVM的gc进行垃圾回收</div><div class="line">        System.out.println(sr.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello</div><div class="line">null</div></pre></td></tr></table></figure>
<p>第二个输出结果是null，这说明只要JVM进行垃圾回收，被弱引用关联的对象必定会被回收掉。不过要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。</p>
<p>　　弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。
　　</p>
<h2 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h2><p>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。<strong>如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</strong></p>
<p>　　要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import java.lang.ref.PhantomReference;</div><div class="line">import java.lang.ref.ReferenceQueue;</div><div class="line"> </div><div class="line"> </div><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;String&gt;();</div><div class="line">        PhantomReference&lt;String&gt; pr = new PhantomReference&lt;String&gt;(new String(&quot;hello&quot;), queue);</div><div class="line">        System.out.println(pr.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="进一步理解软引用和弱引用"><a href="#进一步理解软引用和弱引用" class="headerlink" title="进一步理解软引用和弱引用"></a>进一步理解软引用和弱引用</h1><p>　对于强引用，我们平时在编写代码时经常会用到。而对于其他三种类型的引用，使用得最多的就是软引用和弱引用，这2种既有相似之处又有区别。它们都是用来描述非必需对象的，<strong>但是被软引用关联的对象只有在++内存不足时才会被回收++，而被弱引用关联的对象在++JVM进行垃圾回收时总会被回收++。</strong></p>
<p>　　在SoftReference类中，有三个方法，两个构造方法和一个get方法（WekReference类似）：</p>
<p>　　两个构造方法：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public SoftReference(T referent) &#123;</div><div class="line">    super(referent);</div><div class="line">    this.timestamp = clock;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public SoftReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</div><div class="line">    super(referent, q);</div><div class="line">    this.timestamp = clock;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　get方法用来获取与软引用关联的对象的引用，如果该对象被回收了，则返回null。</p>
<p> 　　在使用软引用和弱引用的时候，我们可以显示地通过System.gc()来通知JVM进行垃圾回收，但是要注意的是，虽然发出了通知，JVM不一定会立刻执行，<strong>也就是说这句是无法确保此时JVM一定会进行垃圾回收的。</strong></p>
<h1 id="如何利用软引用和弱引用解决OOM问题"><a href="#如何利用软引用和弱引用解决OOM问题" class="headerlink" title="如何利用软引用和弱引用解决OOM问题"></a>如何利用软引用和弱引用解决OOM问题</h1><p>　　前面讲了关于软引用和弱引用相关的基础知识，那么到底如何利用它们来优化程序性能，从而避免OOM的问题呢？</p>
<p>　　下面举个例子，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。</p>
<p>　　设计思路是：用一个HashMap来保存图片的路径 和 相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。在Android开发中对于大量图片下载会经常用到。</p>
<p>下面这段代码是摘自博客：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">.....</div><div class="line">private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</div><div class="line">&lt;br&gt;....</div><div class="line">public void addBitmapToCache(String path) &#123;</div><div class="line"> </div><div class="line">    // 强引用的Bitmap对象</div><div class="line"></div><div class="line">    Bitmap bitmap = BitmapFactory.decodeFile(path);</div><div class="line"></div><div class="line">    // 软引用的Bitmap对象</div><div class="line"></div><div class="line">    SoftReference&lt;Bitmap&gt; softBitmap = new SoftReference&lt;Bitmap&gt;(bitmap);</div><div class="line"></div><div class="line">    // 添加该对象到Map中使其缓存</div><div class="line"></div><div class="line">    imageCache.put(path, softBitmap);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public Bitmap getBitmapByPath(String path) &#123;</div><div class="line"></div><div class="line">    // 从缓存中取软引用的Bitmap对象</div><div class="line"></div><div class="line">    SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path);</div><div class="line"></div><div class="line">    // 判断是否存在软引用</div><div class="line"></div><div class="line">    if (softBitmap == null) &#123;</div><div class="line"></div><div class="line">        return null;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空</div><div class="line"></div><div class="line">    Bitmap bitmap = softBitmap.get();</div><div class="line"></div><div class="line">    return bitmap;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然这里我们把缓存替换策略交给了JVM去执行，这是一种比较简单的处理方法。复杂一点的缓存，我们可以自己单独设计一个类，这里面就涉及到缓存策略的问题了，具体可以参考之前的一篇博文：《缓存算法（页面置换算法）-FIFO、LFU、LRU》</p>
<p><strong>参考资料：</strong></p>
<p>　　《深入理解JVM虚拟机》</p>
<p>　　<a href="http://blog.csdn.net/arui319/article/details/8489451" target="_blank" rel="external">http://blog.csdn.net/arui319/article/details/8489451</a></p>
<p>　　<a href="http://blog.csdn.net/zsuguangh/article/details/6429592" target="_blank" rel="external">http://blog.csdn.net/zsuguangh/article/details/6429592</a></p>
<p>　　<a href="http://mobile.51cto.com/abased-406998.htm" target="_blank" rel="external">http://mobile.51cto.com/abased-406998.htm</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;海子：&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3784171.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java 如何有效地避免OOM：善于利用软引用和弱引用&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;想必很多朋友对OOM（OutOfMemory）这个错误不会陌生，而当遇到这种错误如何有效地解决这个问题呢？今天我们就来说一下如何利用软引用和弱引用来有效地解决程序中出现的OOM问题。&lt;/p&gt;
&lt;h1 id=&quot;了解-强引用、软引用、弱引用、虚引用的概念&quot;&gt;&lt;a href=&quot;#了解-强引用、软引用、弱引用、虚引用的概念&quot; class=&quot;headerlink&quot; title=&quot;了解 强引用、软引用、弱引用、虚引用的概念&quot;&gt;&lt;/a&gt;了解 强引用、软引用、弱引用、虚引用的概念&lt;/h1&gt;&lt;p&gt;在Java中，虽然不需要程序员手动去管理对象的生命周期，但是如果希望某些对象具备一定的生命周期的话（比如内存不足时JVM就会自动回收某些对象从而避免OutOfMemory的错误）就需要用到软引用和弱引用了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程：深入剖析ThreadLocal</title>
    <link href="http://www.jiyongguang.xin/threadlocal.html"/>
    <id>http://www.jiyongguang.xin/threadlocal.html</id>
    <published>2018-06-07T07:04:54.000Z</published>
    <updated>2018-06-07T07:08:55.435Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：</p>
<p>海子：<a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="external">Java并发编程：深入剖析ThreadLocal</a></p>
<p>在原作者的内容上自己又从别处copy了一些揉成的一篇文章。</p>
<h1 id="对ThreadLocal的理解"><a href="#对ThreadLocal的理解" class="headerlink" title="对ThreadLocal的理解"></a>对ThreadLocal的理解</h1><p>　　ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<p>　　这句话从字面上看起来很容易理解，但是真正理解并不是那么容易。</p>
<a id="more"></a>
<p>　　我们还是先来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class ConnectionManager &#123;</div><div class="line">     </div><div class="line">    private static Connection connect = null;</div><div class="line">     </div><div class="line">    public static Connection openConnection() &#123;</div><div class="line">        if(connect == null)&#123;</div><div class="line">            connect = DriverManager.getConnection();</div><div class="line">        &#125;</div><div class="line">        return connect;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void closeConnection() &#123;</div><div class="line">        if(connect!=null)</div><div class="line">            connect.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 　　假设有这样一个数据库链接管理类，这段代码在单线程中使用是没有任何问题的，但是如果在多线程中使用呢？很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。</p>
<p>　　所以出于线程安全的考虑，必须将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理。</p>
<p>　　这样将会大大影响程序执行效率，因为一个线程在使用connect进行数据库操作的时候，其他线程只有等待。</p>
<p>　　那么大家来仔细分析一下这个问题，这地方到底需不需要将connect变量进行共享？事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。</p>
<p>　　到这里，可能会有朋友想到，既然不需要在线程之间共享这个变量，可以直接这样处理，在每个需要使用数据库连接的方法中具体使用时才创建数据库链接，然后在方法调用完毕再释放这个连接。比如下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class ConnectionManager &#123;</div><div class="line">     </div><div class="line">    private  Connection connect = null;</div><div class="line">     </div><div class="line">    public Connection openConnection() &#123;</div><div class="line">        if(connect == null)&#123;</div><div class="line">            connect = DriverManager.getConnection();</div><div class="line">        &#125;</div><div class="line">        return connect;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public void closeConnection() &#123;</div><div class="line">        if(connect!=null)</div><div class="line">            connect.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">class Dao&#123;</div><div class="line">    public void insert() &#123;</div><div class="line">        ConnectionManager connectionManager = new ConnectionManager();</div><div class="line">        Connection connection = connectionManager.openConnection();</div><div class="line">         </div><div class="line">        //使用connection进行操作</div><div class="line">         </div><div class="line">        connectionManager.closeConnection();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 　　这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不尽严重影响程序执行效率，还可能导致服务器压力巨大。</p>
<p>　　那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。</p>
<p>　　但是要注意，虽然ThreadLocal能够解决上面说的问题，但是<strong>由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</strong></p>
<h1 id="深入解析ThreadLocal类"><a href="#深入解析ThreadLocal类" class="headerlink" title="深入解析ThreadLocal类"></a>深入解析ThreadLocal类</h1><p>　　在上面谈到了对ThreadLocal的一些理解，那我们下面来看一下具体ThreadLocal是如何实现的。</p>
<p>　　先了解一下ThreadLocal类提供的几个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public T get() &#123; &#125;</div><div class="line">public void set(T value) &#123; &#125;</div><div class="line">public void remove() &#123; &#125;</div><div class="line">protected T initialValue() &#123; &#125;</div></pre></td></tr></table></figure></p>
<p> 　　get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法，下面会详细说明。</p>
<p>　　首先我们来看一下ThreadLocal类是如何为每个线程创建一个变量的副本的。</p>
<p>　　先看下get方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public T get() &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">        if (e != null) &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            T result = (T)e.value;</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 　　第一句是取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到<code>&lt;key,value&gt;</code>键值对，<strong>注意这里获取键值对传进去的是  this，而不是当前线程t。</strong></p>
<p>　　如果获取成功，则返回value值。</p>
<p>　　如果map为空，则调用setInitialValue方法返回value。</p>
<p>　　我们上面的每一句来仔细分析：</p>
<p>　　首先看一下getMap方法中做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ThreadLocalMap getMap(Thread t) &#123;</div><div class="line">    return t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　可能大家没有想到的是，在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。</p>
<p>　　那么我们继续取Thread类中取看一下成员变量threadLocals是什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</div><div class="line">     * by the ThreadLocal class. */</div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</div></pre></td></tr></table></figure></p>
<hr>
<p>　　实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们继续取看ThreadLocalMap的实现：<br>　　<br>关于弱引用WeakReference的学习可参考：<a href="https://www.cnblogs.com/absfree/p/5555687.html" target="_blank" rel="external">理解Java中的弱引用（Weak Reference）</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static class ThreadLocalMap &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The entries in this hash map extend WeakReference, using</div><div class="line">     * its main ref field as the key (which is always a</div><div class="line">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</div><div class="line">     * == null) mean that the key is no longer referenced, so the</div><div class="line">     * entry can be expunged from table.  Such entries are referred to</div><div class="line">     * as &quot;stale entries&quot; in the code that follows.</div><div class="line">     */</div><div class="line">    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</div><div class="line">        /** The value associated with this ThreadLocal. */</div><div class="line">        Object value;</div><div class="line"></div><div class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">            super(k);</div><div class="line">            value = v;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ····</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到ThreadLocalMap的Entry继承了弱引用WeakReference，而WeakReference的泛型也指向了Entry中的键值ThreadLocal。也就是说<strong>ThreadLocalMap是使用ThreadLocal的弱引用作为key的</strong>，它这么设计的原因也是为了方便它的键值ThreadLocal在外部没有强引用引用的情况下进行内存的释放。</p>
<p>下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：</p>
<p><img src="https://pic1.zhimg.com/80/9671b789e1da4f760483456c03e4f4b6_hd.jpg" alt=""></p>
<p>然后网上就传言，ThreadLocal会引发内存泄露，他们的理由是这样的：</p>
<p>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，<strong>如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，</strong> 这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p>
<p>ThreadLocal Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p>
<p>永远无法回收，造成内存泄露。</p>
<p>我们来看看到底会不会出现这种情况。 其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</div><div class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</div><div class="line">    Entry e = table[i]; // Entry 继承 WeakReference</div><div class="line">    if (e != null &amp;&amp; e.get() == key) // e.get()拿出的是WeakReferencere的referent</div><div class="line">        return e;// 如果桶有元素且元素刚好是此ThreadLocal</div><div class="line">    else</div><div class="line">        return getEntryAfterMiss(key, i, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getEntryAfterMiss函数的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line"></div><div class="line">    while (e != null) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        if (k == key)</div><div class="line">            return e;</div><div class="line">        if (k == null) // 如果从桶中取出的Entry的key==null</div><div class="line">            expungeStaleEntry(i);</div><div class="line">        else</div><div class="line">            i = nextIndex(i, len); // 类似HsahMap中取桶中的链表的下一元素</div><div class="line">        e = tab[i];</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>expungeStaleEntry函数的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> private int expungeStaleEntry(int staleSlot) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line"></div><div class="line">    // expunge entry at staleSlot</div><div class="line">    tab[staleSlot].value = null;</div><div class="line">    tab[staleSlot] = null;</div><div class="line">    size--;</div><div class="line"></div><div class="line">    // Rehash until we encounter null</div><div class="line">    Entry e;</div><div class="line">    int i;</div><div class="line">    for (i = nextIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != null;</div><div class="line">         i = nextIndex(i, len)) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        if (k == null) &#123;</div><div class="line">            e.value = null;</div><div class="line">            tab[i] = null;</div><div class="line">            size--;</div><div class="line">        &#125; else &#123;</div><div class="line">            int h = k.threadLocalHashCode &amp; (len - 1);</div><div class="line">            if (h != i) &#123;</div><div class="line">                tab[i] = null;</div><div class="line"></div><div class="line">                // Unlike Knuth 6.4 Algorithm R, we must scan until</div><div class="line">                // null because multiple entries could have been stale.</div><div class="line">                while (tab[h] != null)</div><div class="line">                    h = nextIndex(h, len);</div><div class="line">                tab[h] = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整理一下ThreadLocalMap的getEntry函数的流程：</p>
<ol>
<li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；</li>
<li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询</li>
</ol>
<p><strong>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。</strong> 仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。</p>
<p><strong>需要注意的是：</strong></p>
<p>虽然ThreadLocalMap内部有对这样的Key为null的Entry的处理机制，但是光这样还是不够的，<strong>上面的设计思路依赖一个前提条件：要调用ThreadLocalMap的genEntry函数或者set函数。</strong> 这当然是不可能任何情况都成立的，<strong>所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。</strong> 所以JDK建议将ThreadLocal变量定义成<code>private static</code>的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露(针对Value)。</p>
<p><strong>参考</strong>：<a href="https://www.zhihu.com/question/23089780/answer/62097840" target="_blank" rel="external">ThreadLocal和synchronized的区别?</a></p>
<hr>
<p>然后再继续看setInitialValue方法的具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private T setInitialValue() &#123;</div><div class="line">    T value = initialValue();</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value);</div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">    return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　很容易了解，就是如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void createMap(Thread t, T firstValue) &#123;</div><div class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　至此，可能大部分朋友已经明白了ThreadLocal是如何为每个线程创建变量的副本的：</p>
<p>　　首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p>
<p>　　初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p>
<p>　　然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
<p>　　下面通过一个例子来证明通过ThreadLocal能达到在每个线程中创建变量副本的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;();</div><div class="line">    ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;();</div><div class="line"> </div><div class="line">     </div><div class="line">    public void set() &#123;</div><div class="line">        longLocal.set(Thread.currentThread().getId());</div><div class="line">        stringLocal.set(Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public long getLong() &#123;</div><div class="line">        return longLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public String getString() &#123;</div><div class="line">        return stringLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        final Test test = new Test();</div><div class="line">         </div><div class="line">         </div><div class="line">        test.set();</div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">     </div><div class="line">         </div><div class="line">        Thread thread1 = new Thread()&#123;</div><div class="line">            public void run() &#123;</div><div class="line">                test.set();</div><div class="line">                System.out.println(test.getLong());</div><div class="line">                System.out.println(test.getString());</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">        thread1.start();</div><div class="line">        thread1.join();</div><div class="line">         </div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码的输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">main</div><div class="line">8</div><div class="line">Thread-0</div><div class="line">1</div><div class="line">main</div></pre></td></tr></table></figure></p>
<p>　　从这段代码的输出结果可以看出，在main线程中和thread1线程中，longLocal保存的副本值和stringLocal保存的副本值都不一样。最后一次在main线程再次打印副本值是为了证明在main线程中和thread1线程中的副本值确实是不同的。</p>
<h2 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h2><ol>
<li>实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；</li>
<li>为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；</li>
<li>在进行get之前，必须先set，否则通过ThreadLoca的get函数取出的值为null(默认<code>initValue()</code>函数的结果)。<ul>
<li>如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。因为在上面的代码分析过程中，我们发现如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public T get() &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">        if (e != null) &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            T result = (T)e.value;</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return setInitialValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private T setInitialValue() &#123;</div><div class="line">    T value = initialValue();</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value);</div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">    return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;();</div><div class="line">    ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;();</div><div class="line">    </div><div class="line">    public void set() &#123;</div><div class="line">        longLocal.set(Thread.currentThread().getId());</div><div class="line">        stringLocal.set(Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public long getLong() &#123;</div><div class="line">        return longLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public String getString() &#123;</div><div class="line">        return stringLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        final Test test = new Test();</div><div class="line">         </div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">    </div><div class="line">        Thread thread1 = new Thread()&#123;</div><div class="line">            public void run() &#123;</div><div class="line">                test.set();</div><div class="line">                System.out.println(test.getLong());</div><div class="line">                System.out.println(test.getString());</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">        thread1.start();</div><div class="line">        thread1.join();</div><div class="line">         </div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">    &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在main线程中，没有先set，直接get的话，运行时会报空指针异常。</p>
<p>　　但是如果改成下面这段代码，即重写了initialValue方法：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;()&#123;</div><div class="line">        protected Long initialValue() &#123;</div><div class="line">            return Thread.currentThread().getId();</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;()&#123;;</div><div class="line">        protected String initialValue() &#123;</div><div class="line">            return Thread.currentThread().getName();</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">     </div><div class="line">    public void set() &#123;</div><div class="line">        longLocal.set(Thread.currentThread().getId());</div><div class="line">        stringLocal.set(Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public long getLong() &#123;</div><div class="line">        return longLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public String getString() &#123;</div><div class="line">        return stringLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        final Test test = new Test();</div><div class="line"> </div><div class="line">        test.set();</div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">     </div><div class="line">         </div><div class="line">        Thread thread1 = new Thread()&#123;</div><div class="line">            public void run() &#123;</div><div class="line">                test.set();</div><div class="line">                System.out.println(test.getLong());</div><div class="line">                System.out.println(test.getString());</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">        thread1.start();</div><div class="line">        thread1.join();</div><div class="line">         </div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　就可以直接不用先set而直接调用get了。<br>　<br>　# 三.ThreadLocal的应用场景</p>
<p>　　最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。<br>　　<br>　　如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() &#123;</div><div class="line">    public Connection initialValue() &#123;</div><div class="line">        return DriverManager.getConnection(DB_URL);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">public static Connection getConnection() &#123;</div><div class="line">    return connectionHolder.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　下面这段代码摘自：</p>
<p>　　<a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">正确理解ThreadLocal</a><br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private static final ThreadLocal threadSession = new ThreadLocal();</div><div class="line"> </div><div class="line">public static Session getSession() throws InfrastructureException &#123;</div><div class="line">    Session s = (Session) threadSession.get();</div><div class="line">    try &#123;</div><div class="line">        if (s == null) &#123;</div><div class="line">            s = getSessionFactory().openSession();</div><div class="line">            threadSession.set(s);</div><div class="line">        &#125;</div><div class="line">    &#125; catch (HibernateException ex) &#123;</div><div class="line">        throw new InfrastructureException(ex);</div><div class="line">    &#125;</div><div class="line">    return s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出每个线程操控属于自己的一个Session。</p>
<h1 id="关于ThreadLocal在exchange中的用法"><a href="#关于ThreadLocal在exchange中的用法" class="headerlink" title="关于ThreadLocal在exchange中的用法"></a>关于ThreadLocal在exchange中的用法</h1><p>当某个线程被程序分配到执行某个用户的请求时，由于对于每次来请求的用户的身份未知，所以为了该线程所处理的函数间用户身份信息的传递确认，会用ThreadLocal来存储用户信息。这里ThreadLocal的作用也就是相当于<strong>方便函数间参数传递的工具</strong> exchange项目的代码中做的处理就是每个请求过来先走PassportInterceptor来确认用户身份并且绑定到Hostholder中 这样无论程序分配的是哪个线程来处理用户的请求 函数间传递的都是该身份的用户不会出错。并且由于每个请求都走该拦截器，所以用户每次过来当前线程的ThreadLocal对应的对象都是当前用户会替换掉之前存储在其中的用户。</p>
<h1 id="ThreadLocal与Synchonized的对照"><a href="#ThreadLocal与Synchonized的对照" class="headerlink" title="ThreadLocal与Synchonized的对照"></a>ThreadLocal与Synchonized的对照</h1><p>ThreadLocal和Synchonized都用于解决多线程并发訪问。可是ThreadLocal与synchronized有本质的差别。synchronized是利用锁的机制，使变量或代码块在某一时该仅仅能被一个线程訪问。而ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时可以获得数据共享。</p>
<p>Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。</p>
<h1 id="学习时必看的另两篇文章"><a href="#学习时必看的另两篇文章" class="headerlink" title="学习时必看的另两篇文章"></a>学习时必看的另两篇文章</h1><ul>
<li><a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">正确理解ThreadLocal</a></li>
<li><a href="https://www.cnblogs.com/yxysuanfa/p/7125761.html" target="_blank" rel="external">java ThreadLocal(应用场景及使用方式及原理)</a></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>参考资料：</p>
<ul>
<li>《深入理解Java虚拟机》</li>
<li>《Java编程思想》</li>
<li><a href="http://ifeve.com/thread-management-10/" target="_blank" rel="external">http://ifeve.com/thread-management-10/</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-threads/index3.html" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-threads/index3.html</a></li>
<li><a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">http://www.iteye.com/topic/103804</a></li>
<li><a href="http://www.iteye.com/topic/777716" target="_blank" rel="external">http://www.iteye.com/topic/777716</a></li>
<li><a href="http://www.iteye.com/topic/757478" target="_blank" rel="external">http://www.iteye.com/topic/757478</a></li>
<li><a href="http://blog.csdn.net/ghsau/article/details/15732053" target="_blank" rel="external">http://blog.csdn.net/ghsau/article/details/15732053</a></li>
<li><a href="http://ispring.iteye.com/blog/162982" target="_blank" rel="external">http://ispring.iteye.com/blog/162982</a></li>
<li><a href="http://blog.csdn.net/imzoer/article/details/8262101" target="_blank" rel="external">http://blog.csdn.net/imzoer/article/details/8262101</a></li>
<li><a href="http://www.blogjava.net/wumi9527/archive/2010/09/10/331654.html" target="_blank" rel="external">http://www.blogjava.net/wumi9527/archive/2010/09/10/331654.html</a></li>
<li><a href="http://bbs.csdn.net/topics/380049261" target="_blank" rel="external">http://bbs.csdn.net/topics/380049261</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;/p&gt;
&lt;p&gt;海子：&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3920407.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java并发编程：深入剖析ThreadLocal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在原作者的内容上自己又从别处copy了一些揉成的一篇文章。&lt;/p&gt;
&lt;h1 id=&quot;对ThreadLocal的理解&quot;&gt;&lt;a href=&quot;#对ThreadLocal的理解&quot; class=&quot;headerlink&quot; title=&quot;对ThreadLocal的理解&quot;&gt;&lt;/a&gt;对ThreadLocal的理解&lt;/h1&gt;&lt;p&gt;　　ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。&lt;/p&gt;
&lt;p&gt;　　这句话从字面上看起来很容易理解，但是真正理解并不是那么容易。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="并发" scheme="http://www.jiyongguang.xin/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java集合考点总结</title>
    <link href="http://www.jiyongguang.xin/collection-summary.html"/>
    <id>http://www.jiyongguang.xin/collection-summary.html</id>
    <published>2018-06-02T13:46:10.000Z</published>
    <updated>2018-06-04T10:41:46.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、ArrayList和Vector的区别"><a href="#一、ArrayList和Vector的区别" class="headerlink" title="一、ArrayList和Vector的区别"></a>一、ArrayList和Vector的区别</h1><p>共同点：</p>
<ul>
<li>都实现了List接口继承了AbstractList接口</li>
<li>底层实现都是数组。所以说都是存储有序的集合</li>
<li>允许存储null</li>
</ul>
<p>不同点：</p>
<ul>
<li>ArrayList是线程不安全的，Vector则是线程安全的，即便我们需要线程安全的数组容器也是会选择ArrayList，只是在初始化的时候通过<code>Collections</code>集合类的工具类来进行包装一下。因为这种同步实现更科学</li>
<li>扩容时ArrayList扩容系数为1.5，Vector则是2</li>
</ul>
<a id="more"></a>
<h1 id="二、HashMap和Hashtable的区别"><a href="#二、HashMap和Hashtable的区别" class="headerlink" title="二、HashMap和Hashtable的区别"></a>二、HashMap和Hashtable的区别</h1><p>总的来说HashTable的存在和Vector是一个意思。都是早期的实现，并且盲目的保证了集合的线程安全。却在一些不必要的操作上影响了集合的性能，并且早期函数的命名并不科学简洁严谨。</p>
<p>共同点：</p>
<ul>
<li>实现了Map接口</li>
</ul>
<p>不同点：</p>
<ul>
<li>HashMap非同步，HashTable同步。当我们需要同步的映射容器的时候Java也提供了<code>ConcurrentHashMap</code>这个类。</li>
<li>HashMap允许null键和null值，HashTable不允许null键或者null值。</li>
<li>HashMap没有保留HashTable的contains函数，而且和HashTable一样添加了<code>containsValue</code>和<code>containsKey</code>函数。并选用containsKey函数来替代contains的功能。</li>
<li>两者继承不同。HashTable继承自Dictionary父类而HashMap继承自AbstractMap父类。</li>
</ul>
<h1 id="三、List和Map的区别"><a href="#三、List和Map的区别" class="headerlink" title="三、List和Map的区别"></a>三、List和Map的区别</h1><p>存储结构不同</p>
<ul>
<li>List是单列存储，Map是key-value键值存储</li>
<li>List允许存重复元素,Map则key值不能重复</li>
<li>List存储有序，Map映射存储无序。</li>
</ul>
<h1 id="四、Set集合定义存储在其中的元素是不能重复的，元素的重复与否是如何判断的？是用-还是equals"><a href="#四、Set集合定义存储在其中的元素是不能重复的，元素的重复与否是如何判断的？是用-还是equals" class="headerlink" title="四、Set集合定义存储在其中的元素是不能重复的，元素的重复与否是如何判断的？是用==还是equals()?"></a>四、Set集合定义存储在其中的元素是不能重复的，元素的重复与否是如何判断的？是用==还是equals()?</h1><p>首先需要清楚Set集合的常见实现类的底层实现用的都是Map映射的子类。</p>
<p>拿HashSet来举例，它的底层是现金就是HashMap。而我们知道HashSet的存储方式是把存入的元素对应的存到了HashMap的key中，而value则是固定的Object对象的常量。</p>
<p>所以问题就落到了HashMap是如何处理存入相同key的情况的呢？</p>
<p>HashMap源码的632-635行是这样判断的，如果key值散列到的桶的头元素与该key的hash值相等。并且key值相<code>==</code>或者key值equals的话，那么就认为该key值已经存在在了HashMap中。那么就跳出判断循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Node&lt;K,V&gt; e; K k;</div><div class="line">    if (p.hash == hash &amp;&amp;</div><div class="line">        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">        e = p;</div><div class="line">        </div><div class="line">=============</div><div class="line"></div><div class="line">if (e != null) &#123; // existing mapping for key</div><div class="line">    V oldValue = e.value;</div><div class="line">    if (!onlyIfAbsent || oldValue == null)</div><div class="line">        e.value = value;</div><div class="line">    afterNodeAccess(e);</div><div class="line">    return oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HashMap源码652行做了如上处理，即拿出旧值并返回，对应的节点的value替换上新值。</p>
<p><strong>解答：</strong></p>
<p>所以针对上述问题，对于Set来说，当插入重复元素的时候，就代表这HashMap要插入具有重复key值得节点。那么由于插入到Set集合的节点的value均是相同的无意义的Object常量对象。所以底层HashMap相当于只是在频繁的修改无疑的value。</p>
<p>从源码可以看出来<code>==</code>和<code>equals</code>两者都用了。</p>
<h1 id="五、Collection和Collections的区别"><a href="#五、Collection和Collections的区别" class="headerlink" title="五、Collection和Collections的区别"></a>五、Collection和Collections的区别</h1><ul>
<li>Collection是集合类的顶级接口，实现它的有Set接口和=，List接口，Queue接口。</li>
<li>Collections是集合的工具类。提供了一系列的静态函数来对集合进行搜索，查找，以及同步的一些操作等。</li>
</ul>
<h1 id="六、说出ArrayList-LinkedList的存储性能和特性"><a href="#六、说出ArrayList-LinkedList的存储性能和特性" class="headerlink" title="六、说出ArrayList,LinkedList的存储性能和特性"></a>六、说出ArrayList,LinkedList的存储性能和特性</h1><p>ArrayList底层是数组实现，存储有序。LinkedList底层是双向链表实现的，存储无序。</p>
<p>由于ArrayList底层实现是动态数组，所以对于ArrayList来说访问其元素可以根据角标的方式访问，非常快。而LinkedList要访问元素的时候只能通过遍历来找到要找的元素。所以ArrayList比LinkedList的访问速度要快，性能要好。</p>
<p>同样的由于是数组的原因也就导致它在进行增删操作的时候是不方便的比较缓慢的(移动数组元素，扩容复制数组)。LinkedList只需要修改对应节点next指针即可。消耗很小，所以LinkedList比ArrayList的增删速度要快，性能要好。</p>
<p> <strong>注意：</strong></p>
<p>但同时我们需要细想一个删除操作具体体现的不仅仅是删除这一个操作。对于不同的数据结构而言，找到要删除的元素也是一个性能差异很大的点。</p>
<p>比如对于LinkedList的删除操作而言，删除节点本身是很简易的，但是慢就慢在它需要对所有元素去迭代一遍来找这个元素。而对于ArrayList来说删除操作是不易的，因为它要面临着被删除位置后的数组元素前移的操作。而找元素这个操作对数组来说却是速度很快的一个操作。所以整体上来说两者增删操作的性能差异就不是那么的确定了。比较时考虑的点还是比较的多</p>
<h2 id="HashTable，SynchronizedMap，ConcurrentHashMap区别"><a href="#HashTable，SynchronizedMap，ConcurrentHashMap区别" class="headerlink" title="HashTable，SynchronizedMap，ConcurrentHashMap区别"></a>HashTable，SynchronizedMap，ConcurrentHashMap区别</h2><p><strong>HashTable</strong></p>
<p>相比于HashMap，HashTable与其最大的区别就是所有函数都实现了同步。并且HashTable由于是最早设计的容器框架，有许多设计上的不足，并且后续并没有改进。最典型的元素插入时的put函数，元素的散列位置是通过<code>%</code>来计算的，而非像HashMap中<code>(table.length-1)&amp;hash(key)</code></p>
<p><strong>synchronizedMap</strong></p>
<p>synchronizedMap可以作用于任何Map实现类上，但是相比于HashTable最大的区别则是它并不是盲目的对所有的函数都实现了同步。一定程度上性能要高于HashTable不少。但是两者都是对象锁。所以当并发情况下有一个线程在执行被锁函数那么并发情况下的其它线程必然都是等待状态。synchronizedMap相比于HashTable保证的只是非同步方法在多线程情况下的并行运行。</p>
<p>潜在问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Java代码</div><div class="line"></div><div class="line">// shm是SynchronizedMap的一个实例</div><div class="line">if(shm.containsKey(&apos;key&apos;))&#123;</div><div class="line">        shm.remove(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码用于从map中删除一个元素之前判断是否存在这个元素。这里的 containsKey和reomve方法都是同步的，但是整段代码却不是。考虑这么一个使用场景：线程A执行了containsKey方法返回 true，准备执行remove操作；这时另一个线程B开始执行，同样执行了containsKey方法返回true，并接着执行了remove操作；然 后线程A接着执行remove操作时发现此时已经没有这个元素了。要保证这段代码按我们的意愿工作，一个办法就是对这段代码进行同步控制，但是这么做付出 的代价太大。</p>
<p><strong>同样还有：</strong> 并发情况下的迭代及修改。可能我们在迭代的时候某个线程对该Map正在执行并发修改的操作。此时就会报出并发修改的异常</p>
<p>参考：<a href="https://www.cnblogs.com/grefr/p/6094888.html" target="_blank" rel="external">SynchronizedMap和ConcurrentHashMap 区别</a></p>
<p><strong>ConcurrentHashMap</strong></p>
<p>ConcurrentHashMap相比于前两者不但汲取了synchronizedMap的优点并没有对一些必要的函数实现同步。并且非同步的函数和HashMap的函数处理逻辑基本一致。而对于需要同步的函数，其内部采用的也是“桶锁”，它不会对整个Map映射上锁。这从一定程度上大大提升了性能，使其可以在多线程并发的情况下函数间并行执行，而不会影响执行结果和效率。</p>
<h2 id="ArrayList和LinkedList增删分析"><a href="#ArrayList和LinkedList增删分析" class="headerlink" title="ArrayList和LinkedList增删分析"></a>ArrayList和LinkedList增删分析</h2><p><strong>ArrayList插入分析：</strong></p>
<p>ArrayList的<code>add(E e)</code>函数默认是尾插。 我们如果采用该方法插入大量元素的话。不会存在元素移位的情况。这种插入方式和LinkedList的插入方式一样高效，复杂度都是O(1)。不存在元素移位的情况，而如果采用<code>add(int index, E element)</code>函数来对某个索引处的元素前插入大量元素的话，每插入一次元素都会 使数组索引后续元素都进行一次元素移动的操作，复杂度是O(n)。<strong>关键区别看你插入大量元素时想插到哪里</strong></p>
<p><strong>LinkedList插入分析：</strong></p>
<p>LinkedList的<code>add(E e)</code>函数默认插入方式是尾插法。由于它是双向链表并且纪录了头尾两个节点。所以用这个方式插入大量元素的时间复杂度是0(1)。addFirst和addLast同样的道理由于纪录了头尾两节点的原因。</p>
<p><strong>ArrayList删除分析：</strong><br>而ArrayList提供的remove函数在删除大量元素的时候，就必然会进行数组元素的移位操作。它的耗时操作也就在此处。</p>
<p><strong>LinkedList删除分析：</strong></p>
<p>LinkedList由于是双向链表，所以头删尾删都有性能上的优势，复杂度均是O(1)。只需要考虑查找元素的复杂度即可。而且LinkedList中进行了折半查找，先对元素的索引和总元素数size进行比较来确认从头迭代的找还是尾迭代的找。元素总规模先<code>&gt;&gt;</code>后才进行的迭代。</p>
<h2 id="扩展：ArrayList和LinkedList增删性能比较"><a href="#扩展：ArrayList和LinkedList增删性能比较" class="headerlink" title="扩展：ArrayList和LinkedList增删性能比较"></a>扩展：ArrayList和LinkedList增删性能比较</h2><p>ArrayList的增删未必就是比LinkedList要慢。</p>
<p>如果增删都是在末尾来操作【每次调用的都是remove()和add()】，此时ArrayList就不需要移动数组元素了(增加元素的时候还是有可能触发扩容操作可能会扩容并复制数组)。如果数据量有百万级的时，ArrayList的速度是会比LinkedList要快的。(我测试过)</p>
<p>如果删除操作的位置是在中间。由于LinkedList的消耗主要是在遍历上，ArrayList的消耗主要是在数组元素的移动上(底层调用的是arraycopy()方法，是native方法)。<br>LinkedList的遍历速度是要慢于ArrayList的数组元素移动的速度的<br>如果数据量有百万级的时，还是ArrayList要快。(我测试过)</p>
<p>删末尾元素 ArrayList 删掉最后一个元素， LinkedList删掉最后一个元素。指针的变化，相对复杂一些</p>
<p>删中间元素，ArrayList需要做的是移动数组后续元素。而arraycopy是native函数，在JVM运行时有性能优势<br>而且本身进行的也是赋值操作，简单速度快</p>
<p>LinkedList需要做的是遍历元素，内存中指针的移动相对速度慢于赋值操作一些。<br>所以LinkedList的遍历速度要慢于ArrayList的移动速度。</p>
<p>所以可以认为百万级别的增删，如果是在容器中间或中间以后的元素操作基本都是ArrayList快</p>
<h1 id="七、Set集合的各实现类"><a href="#七、Set集合的各实现类" class="headerlink" title="七、Set集合的各实现类"></a>七、Set集合的各实现类</h1><p>首先有3个，HashSet，TreeSet，LinkedHashSet</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>常用的应该是HashSet，底层实现是HashMap(<strong>由于LinkedHashSet继承自HashSet，所以底层实现也提供了一种LinkedHashMap的构造函数</strong>)，无论存储还是查询都具有很好性能。都可以根据元素的hash值快速的散列到所在桶的位置，然后进行相应的操作。同时由于HashMap在jdk1.8的时候把HashMap底层的实现换成了散列表+红黑树的方式。导致即便碰巧大量元素散列到一个桶上也不会出现链表特别长，遍历性能不好的情况。当链表数量超过8个时会自动将链表哦转化成红黑树(元素数大于64)，遍历时性能非常好。由于底层是HashMap实现，所以我们在迭代的时候调用iterator方法返回的其实是HashMap迭代时调用的keySet函数返回的Set集合的Iterator对象来进行迭代。HashMap底层会对所有的Key用一个Set集合来进行存储(不重)。对所有value用一个Collection来进行存储。</p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>TreeSet底层实现是TreeMap，即根据插入元素的自然排序或者自定义比较方式来比较插入元素的大小来决定其插入位置。进而形成一个有序的红黑树。TreeSet和TreeMap一样，插入的元素会有序的存储在一个红黑树上。根据我们制定的规则，或者元素的自然排序顺序。一般Tree系列的数据结构，我们用来保证一种有序性的数据结构才会用，存入到其中的元素必须实现Comparable或者Comparator接口来保证元素的可比较性。我们一般都是重写compareTo或者compare方法来制定自己的比较规则，让后续存到数据结构中的元素满足我们想要的顺序。</p>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>LinkedHashSet继承自HashSet，底层实现是LinkedHashMap即散列表和双向链表。HashSet也为LinkedHashSet提供了一个构造LinkedHashMap的构造函数，但需要注意的是，HashSet只为LinkedHashSet提供了一种只有<code>initialCapacity</code>和<code>loadFactor</code>的构造函数，也就意味着LinkedHashSet的元素无法像LinkedHashMap那样具有两种迭代顺序，又由于默认LinkedHashMap的迭代顺序是元素的插入顺序，所以它一般的作用就是用来保证元素的存储顺序和我们插入元素的顺序一致。这样我们在迭代获取元素的时候有一个预估值和期望值。</p>
<p>HashSet各方面性能好，不用排序一般用它，也是因为HashMap的优势。TreeSet一般用在比较根据元素进行排序的时候，LinkedHashSet则是用到我们要元素的插入顺序的时候。</p>
<h1 id="八、Map集合及实现类"><a href="#八、Map集合及实现类" class="headerlink" title="八、Map集合及实现类"></a>八、Map集合及实现类</h1><p>首先有3个，HashMap，TreeMap，LinkedHashMap。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>最常用的一般是HashMap，底层实现是散列表+单链表+红黑树。从性能上来讲，无论增删还是查都可以根据传入的key值快速定位到元素所在的桶。并且桶的数据结构也对大量hash碰撞的特殊情况做了优化，单链表元素数超过8采用红黑树存储。允许使用null做键值。迭代的时候有三种方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1.</div><div class="line">for (Entry&lt;String, String&gt; entry : map.entrySet())</div><div class="line"></div><div class="line">2.</div><div class="line">for (String keys : map.keySet())</div><div class="line"></div><div class="line">3.</div><div class="line">Iterator&lt;String&gt; keys = map.keySet().iterator();</div><div class="line">while (keys.hasNext())&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第一种调用的是<code>HashIterator</code>。根据散列表的数组下标来进行迭代。</li>
<li>第二种和第三种其实是一样的。<code>keySet()</code>返回的KeySet类继承自<code>AbstractSet</code>，在<code>foreach</code>迭代的时候会自动调用该类的<code>iterator()</code>方法，返回<code>KeyIterator</code>类，而这个类又继承自<code>HashIterator</code>类。只是实现了<code>next()</code>方法，但函数内也还是调用了<code>HashIterator</code>类的<code>nextNode()</code>方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final class KeyIterator extends HashIterator</div><div class="line">    implements Iterator&lt;K&gt; &#123;</div><div class="line">    public final K next() &#123; return nextNode().key; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap是TreeSet的底层实现。底层数据结构式红黑树，实现了SortedMap接口，该映射是根据其键的自然顺序进行排序的，或者根据在构建TreeMap时传入的Comparator来进行排序。<strong>需要注意</strong>，存入的元素必须实现了Comparable接口或者其类型被指定的Comparator所接受。而且比较的对象参数不能为null。在使用这种数据结构的时候我们要注的除了是元素需要具有可比性，同时我们还需要注意元素具体的比较规则，即元素的类重写的compare方法和compareTo方法的比较逻辑。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap是LinkedHashSet的底层实现，继承自HashMap，底层数据结构是散列表+单链表+红黑树+双向链表。所以和HashMap一样无论增删还是查找元素都具有极高的性能。不同的是迭代元素的方式。HashMap是通过迭代每一个“桶”来进行的迭代，迭代时获取的Entry都是未知的。而LinkedHashMap则默认是通过节点的插入顺序来进行迭代，或者通过节点的最近最少来进行迭代。之所以可以如此，是因为LinkedHashMap扩展了HashMap的<code>Node</code>节点。LinkedHashMap的Entry节点比其多维护两个指针变量。分别指向该节点的前驱和后继节点，所以比HashMap可以多维护一个双向链表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * HashMap.Node subclass for normal LinkedHashMap entries.</div><div class="line"> */</div><div class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</div><div class="line">    Entry&lt;K,V&gt; before, after;</div><div class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        super(hash, key, value, next);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LinkedHashMap默认是按key的插入顺序来排序，也可以通过在构造时通过指定accessOrder为true来使其按元素的LRU顺序来排序，在其迭代的时候可以看出它的元素排列顺序。</p>
<p>LinkedHashMap不允许存储的元素的key值为null。两种比较方式都不支持。元素在插入到红黑树的时候肯定会与其他树中的节点进行比较，此时会报错。</p>
<p>参考：<a href="https://www.cnblogs.com/acm-bingzi/p/javaMap.html" target="_blank" rel="external">HashMap,LinkedHashMap,TreeMap的区别</a></p>
<h1 id="九、Enumeration和Iterator接口的区别"><a href="#九、Enumeration和Iterator接口的区别" class="headerlink" title="九、Enumeration和Iterator接口的区别"></a>九、Enumeration和Iterator接口的区别</h1><p>Enumeration最早出来主要是针对当时所有的集合类的如Vector和HashTable的。但是由于原本Vector与Hashtable设计上的问题，以及Enumeration在设计上的一些缺陷到之后来出现了Iterator替代了它。</p>
<p>并且Iterator支持所有集合类。并对Enumeration进行了扩展，<strong>1. 添加了一个可选择的删除操作</strong>。并且在<strong>2. 函数命名上也更加科学，简洁了</strong>。同时Iterator也在并发操作的时候针对其实现类在并发情况下可能出现的<strong>3.并发修改问题利用<code>fail-fast</code>机制进行补足</strong>。Enumeration由于本身针对的就是并发情况下同步的类Vector和HashTable所以不存在并发上的问题。 </p>
<h1 id="十、ListIterator的特点"><a href="#十、ListIterator的特点" class="headerlink" title="十、ListIterator的特点"></a>十、ListIterator的特点</h1><p>我们前面说到Enumeration最早吹来是服务于Vector和HashTable来进行遍历的。后来Iterator的出现替代了它，但是对应不同的集合类迭代方式也不尽相同。所以ListIterator继承自Iterator，看类名就知道他是负责List集合的迭代的。</p>
<ul>
<li>继承自Iterator接口，用于遍历List集合的元素。</li>
<li>可以实现双向遍历。添加元素。设置元素</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-93032cdbb49e083c?imageMogr2/auto-orient/strip%7CimageView2/2/w/552" alt=""></p>
<h1 id="十一、Java中HashMap的key值要是为类对象则该类需要满足什么条件？"><a href="#十一、Java中HashMap的key值要是为类对象则该类需要满足什么条件？" class="headerlink" title="十一、Java中HashMap的key值要是为类对象则该类需要满足什么条件？"></a>十一、Java中HashMap的key值要是为类对象则该类需要满足什么条件？</h1><p><strong>需要同时重写该类的hashCode()方法和它的equals()方法。</strong></p>
<p>因为HashMap在插入元素的时候在<code>put</code>函数中就会向调用的<code>putVal</code>函数传递key的hash值。然后<code>putVal</code>函数再对key的哈希值进行散列，找到对应的桶。既然这样，那和重写对象到的hashcode有什么关系呢？</p>
<p>那是因为我们的对象做为key来存到hashMap中的话，我们最后肯定是根据key来获取到对应的value。而这个entry又存储在桶中，我们要想找到对应的桶，对于HashMap函数来说只能通过对象的hashcode值来进行散列，散列到对应的桶上。但是我们存储和取出的时候其实用的是两个对象(两次都会new新的对象)。但是两个对象具有相同的属性值。</p>
<p>如果我们不重写对象的hashcode的函数的话，去更改他hash值的生成策略的话是无法散列到对应的桶的(根据对象地址生成的hash值)。也就无法取出我们存进去的值。所以我们需要重写它的hashcode函数让它生成是只需要根据对象的属性进行生成即可，这样下次我们无论穿进去这个类的哪个对象，只要它保证我们指定的生成hashcode参考的属性相等即可。equals函数就更不用说了，Object类的equals默认比较的是两个对象的地址。而对我们开发来说这样的意义并不大。一般来说我们认为只要两个对象的成员变量的值是相等的，那么我们就认为这两个对象是相等的！</p>
<p>显然hashcode相比于equals函数具偶然性。在hashmap元素的比较中也是把hash值得比较前置了。因为hashcode可能在一些情况下出现hash碰撞相等的情况。所以我们重写equals函数前必须先重写hashcode函数，这样既保证了正确性，也在性能上得到了提升。</p>
<h1 id="十二、与Java集合框架相关的有哪些最好的实践"><a href="#十二、与Java集合框架相关的有哪些最好的实践" class="headerlink" title="十二、与Java集合框架相关的有哪些最好的实践"></a>十二、与Java集合框架相关的有哪些最好的实践</h1><ol>
<li>根据需要确定集合的类型。如果是单列的集合，我们考虑用Collection下的子接口ArrayList和Set。如果是映射，我们就考虑使用Map</li>
<li>确定完我们的集合类型，我们接下来确定使用该集合类型下的哪个子类~我认为可以简单分成几个步骤：</li>
</ol>
<ul>
<li><p>是否需要同步</p>
<ul>
<li>找线程安全的集合类使用</li>
</ul>
</li>
<li><p>迭代时是否需要有序(插入顺序有序)</p>
<ul>
<li>找Linked双向列表结构的</li>
</ul>
</li>
<li>是否需要排序(自然顺序或者手动排序)<ul>
<li>找Tree红黑树类型的(JDK1.8)</li>
</ul>
</li>
</ul>
<ol>
<li>估算存放集合的数据量有多大，无论是List还是Map，它们实现动态增长，都是有性能消耗的。在初始集合的时候给出一个合理的容量会减少动态增长时的消耗</li>
<li>使用泛型，避免在运行时出现ClassCastException</li>
<li>尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的工具函数。它提供了我们常用的针对List集合的功能函数，具有很高的重用性，以及更好的稳定性和可维护性。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、ArrayList和Vector的区别&quot;&gt;&lt;a href=&quot;#一、ArrayList和Vector的区别&quot; class=&quot;headerlink&quot; title=&quot;一、ArrayList和Vector的区别&quot;&gt;&lt;/a&gt;一、ArrayList和Vector的区别&lt;/h1&gt;&lt;p&gt;共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;都实现了List接口继承了AbstractList接口&lt;/li&gt;
&lt;li&gt;底层实现都是数组。所以说都是存储有序的集合&lt;/li&gt;
&lt;li&gt;允许存储null&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ArrayList是线程不安全的，Vector则是线程安全的，即便我们需要线程安全的数组容器也是会选择ArrayList，只是在初始化的时候通过&lt;code&gt;Collections&lt;/code&gt;集合类的工具类来进行包装一下。因为这种同步实现更科学&lt;/li&gt;
&lt;li&gt;扩容时ArrayList扩容系数为1.5，Vector则是2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
