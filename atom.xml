<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Illusion&#39;s Notes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.jiyongguang.xin/"/>
  <updated>2018-06-25T09:45:04.028Z</updated>
  <id>http://www.jiyongguang.xin/</id>
  
  <author>
    <name>Illusion</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java编程的逻辑 -- 并发章 -- 线程的中断</title>
    <link href="http://www.jiyongguang.xin/java-concurrentProgramming-readingNotes-15-4.html"/>
    <id>http://www.jiyongguang.xin/java-concurrentProgramming-readingNotes-15-4.html</id>
    <published>2018-06-25T09:43:58.000Z</published>
    <updated>2018-06-25T09:45:04.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h1><p>在Java中，停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，<strong>它是一种协作机制</strong>，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出。本节我们主要就是来理解Java的中断机制</p>
<p>线程中断的三个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean isInterrupted()</div><div class="line">public void interrupt()</div><div class="line">public static boolean interrupted()</div></pre></td></tr></table></figure></p>
<ul>
<li>isInterrupted返回当前线程是否被中断。true/false</li>
<li>interrupted不但具有isInterrupted的共同，同时每次调用还会清空该中断标志位。即某一个线程被中断了第一次调用为true第二次一般就为false。需要注意的是该方法是静态方法，<strong>中断的是正在执行的线程。</strong> 而其他两个方法则是中断this对象指定的线程。</li>
<li>interrupt中断对应线程。</li>
</ul>
<a id="more"></a>
<h1 id="线程不同状态对中断的反应"><a href="#线程不同状态对中断的反应" class="headerlink" title="线程不同状态对中断的反应"></a>线程不同状态对中断的反应</h1><p>interrupt ()对线程的影响与线程的状态和在进行的IO操作有关。我们主要考虑线程的状态，I/O操作的影响和具I/O以及操作系统有关，我们就不讨论了。</p>
<p>线程状态有：</p>
<ul>
<li><strong>RUNNABLE</strong>:线程在运行或具备运行条件只是在等待操作系统调度。</li>
<li><strong>WAITING/TIMED_WAITING</strong>:线程在等待某个条件或超时。</li>
<li><strong>BLOCKED</strong>:线程在等待锁，试图进入同步块。</li>
<li><strong>NEWATERMINATED</strong>:线程还未启动或已结束。</li>
</ul>
<h2 id="1-RUNNABLE"><a href="#1-RUNNABLE" class="headerlink" title="1.RUNNABLE"></a>1.RUNNABLE</h2><p><strong>如果线程在运行中，且没行执行I/O操作</strong>，interrupt()只是会设置线程的中断标忐位，没行任何其他作用。线程应该在运行过程中合适的位置检查中断标志位，比如，<strong>如果主体代码是一个循环，可以在循环开始处进行检查</strong>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class InterruptRunnableDemo extends Thread &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        while(!Thread.currentThread().isInterrupted()) &#123;</div><div class="line">            //…单词循环代码</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;done &quot;);</div><div class="line">    &#125;</div><div class="line">    //其他代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2-WAITING-TIMED-WAITING"><a href="#2-WAITING-TIMED-WAITING" class="headerlink" title="2.WAITING/TIMED_WAITING"></a>2.WAITING/TIMED_WAITING</h2><p>线程调用join/wait/sleep方法会进入<code>WAITING</code>或<code>TIMED_WAITING</code>状态。在对线程对象调用interrupt()后，当线程处于中断状态时，如果再由wait、sleep以及jion三个方法引起的阻塞，那么JVM会将线程的<strong>中断标志重新设置为false</strong>，并抛出一个InterruptedException异常。比如，执行如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Thread t = new Thread ()&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(1000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            System.out.println(isInterrupted());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">t.start();</div><div class="line">try &#123;</div><div class="line">    Thread.sleep(100);// 确保该线程 睡开了</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">&#125;</div><div class="line">t.interrupt();</div></pre></td></tr></table></figure></p>
<p>程序的输出为false。</p>
<p>IntemiptedException是一个受检异常，线程必须进行处理。我们在异常处理中介绍过，处理异常的基本思路是：如果知道怎么处理，就进行处理，如果不知道，就应该向上传递，通常情况下不应该捕获异常然后忽略。</p>
<p>捕获到InterruptedException,通常表示<strong>希望结朿该线程</strong>，线程大致有两种处理方式：</p>
<ol>
<li>向上传递该异常，这使得该方法也变成一个可中断的方法(相当于封装了一下)，需要调用者记性处理。</li>
<li>有些情况，不能向上传递异常，比如 <strong>Thread的run方法，它的声明是固定的，不能 ++<em>抛出</em>++ 任何受检异应该捕获异常，</strong>  进行合适的清理操作，<strong>清理后，一般应该调用Thread的interrupt方法设置中断标志位，使得其他代码有办法知道它发生了中断。</strong></li>
</ol>
<p>第一种示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">对Thread类的sleep方法进行了封装而不是直接在run方法中调用就可以保证interruptedException可以在run方法调用该interruptibleMethod方法时被抛出了。</div><div class="line">public void interruptibleMethod() throws InterruptedException&#123;</div><div class="line">    //…这里可以是wait, join 或者 sleep 方法</div><div class="line">    Thread.sleep(1000);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二种示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class InterruptWaitingDemo extends Thread &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        while(!Thread.currentThread().isInterrupted()) &#123;</div><div class="line">            try &#123;</div><div class="line">                //模拟任务代码</div><div class="line">                Thread.sleep(2000);</div><div class="line">            &#125; catch(InterruptedException e) &#123;</div><div class="line">                //…清理操作</div><div class="line">                //重新设置中断标志位 方便其他代码知道该线程发生了中断</div><div class="line">                Thread.currentThread().interrupt();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(isInterrupted());</div><div class="line">    &#125;</div><div class="line">    //其他代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-BLOCKED"><a href="#3-BLOCKED" class="headerlink" title="3.BLOCKED"></a>3.BLOCKED</h2><p>当线程处于BLOCKED状态等待CPU调度时。调用线程的<strong>interrupt()方法并不能使一个正在等待的线程真正中断。</strong></p>
<h2 id="4-NEW-TERMINATE"><a href="#4-NEW-TERMINATE" class="headerlink" title="4.NEW/TERMINATE"></a>4.NEW/TERMINATE</h2><p>如果线程尚未启动(NEW)，或者已经结束(TERMINATE)，则调用interrupt()方法对其没有任何效果。并且线程的中断标志位也不会被设置。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节主要讲的是如何取消以及关闭线程，主要采用的是中断技术。他是一种协作机制，并不会强制中断线程。并且介绍了线程在不同状态下对于中断操作的反应。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程中断&quot;&gt;&lt;a href=&quot;#线程中断&quot; class=&quot;headerlink&quot; title=&quot;线程中断&quot;&gt;&lt;/a&gt;线程中断&lt;/h1&gt;&lt;p&gt;在Java中，停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，&lt;strong&gt;它是一种协作机制&lt;/strong&gt;，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出。本节我们主要就是来理解Java的中断机制&lt;/p&gt;
&lt;p&gt;线程中断的三个方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;public boolean isInterrupted()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public void interrupt()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public static boolean interrupted()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;isInterrupted返回当前线程是否被中断。true/false&lt;/li&gt;
&lt;li&gt;interrupted不但具有isInterrupted的共同，同时每次调用还会清空该中断标志位。即某一个线程被中断了第一次调用为true第二次一般就为false。需要注意的是该方法是静态方法，&lt;strong&gt;中断的是正在执行的线程。&lt;/strong&gt; 而其他两个方法则是中断this对象指定的线程。&lt;/li&gt;
&lt;li&gt;interrupt中断对应线程。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="并发" scheme="http://www.jiyongguang.xin/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java编程的逻辑 -- 并发章 -- 线程的基本协作机制</title>
    <link href="http://www.jiyongguang.xin/java-concurrentProgramming-readingNotes-15-3.html"/>
    <id>http://www.jiyongguang.xin/java-concurrentProgramming-readingNotes-15-3.html</id>
    <published>2018-06-22T12:20:06.000Z</published>
    <updated>2018-06-22T12:21:13.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的基本协作"><a href="#线程的基本协作" class="headerlink" title="线程的基本协作"></a>线程的基本协作</h1><p>多线程间除了竞争访问同一资源外，也经常需要相互协作的去执行一些任务。而对于协作的基本机制用的最多的无疑是wait/notify。</p>
<h2 id="协作的场景"><a href="#协作的场景" class="headerlink" title="协作的场景"></a>协作的场景</h2><ul>
<li>生产者消费者模式：共享队列，一个负责放一个负责取。如果队列长度有限且满了之后则等待。</li>
<li>同时开始：类似运动员比赛，多个线程同时开始执行。</li>
<li>等待结束：主线程分发给各个子任务去执行任务，主任务开始执行前需要等待各个子任务执行完毕。</li>
<li>异步结果：</li>
<li>集合点</li>
</ul>
<a id="more"></a>
<h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h2><p>wait和notify方法都是Object类提供给所有子类进行线程协作的一种实现机制。</p>
<p>wait:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public final void wait() throws InterruptedException</div><div class="line">public final native void wait(long timeout) throws InterruptedException;</div></pre></td></tr></table></figure></p>
<p>一个带时间参数，表示最多等待这么长时间。<br>一个不带，默认为0，表示无限期等待。</p>
<p>如果在wait的过程中线程被中断，则会抛出InterruptedException。我们在之前关于Thread类的的博文中也提到过这个。</p>
<p><strong>wait在等什么？</strong></p>
<p>我们之前说过的<strong>每个对象都有一把锁和一个等待队列</strong>，一个线程在进入synchronized代码块时，会尝试获取锁，如果获取不到则会把当前线程加入等待队列中，其实，除了对于锁的等待队列，<strong>每个对象还有另一个等待队列，即条件队列，该队列用于线程间的协作</strong>。调用<br>wait就会把当前线程放到条件队列上并阻塞，表示当前线程执行不下去了，它需要等待一个条件，<strong>这个条件它自己改变不了</strong>，需要其他线程改变。当其他线程改变了条件后，应该调用Object(<strong>等待哪个对象就用哪个对象</strong>)的notify方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public final native void notify();</div><div class="line">public final native void notifyAll();</div></pre></td></tr></table></figure></p>
<p>notify做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒，notifyAll和notify的区別是，它会移除条件队列中所有的线程并全部唤醒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class WaitThread extends Thread &#123;</div><div class="line">    private volatile boolean fire = false;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                while(!fire) &#123;</div><div class="line">                    wait();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;fired&quot;);</div><div class="line">        &#125; catch(InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public synchronized void fire() &#123;</div><div class="line">        this.fire = true;</div><div class="line">        notify();</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        WaitThread waitThread = new WaitThread();</div><div class="line">        waitThread.start();</div><div class="line">        Thread.sleep(1000);</div><div class="line">        System.out.println(&quot;fire&quot;);</div><div class="line">        waitThread.fire();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码中的协作的条件变量式fire，两个线程都要访问该fire变量，容易出现竞态条件所以相关代码都被synchronized保护了。</p>
<p><strong>需要特别注意的是：</strong> wait和notify方法的调用只能再synchronized代码块中。如果在调用wait/notify方法时，当前线程没有对象锁的话，那么会抛出<code>java.lang.IllegalMonitor-StateException</code>。</p>
<p><strong>wait的具体过程：</strong></p>
<ol>
<li>把当前线程放入<strong>条件等待队列</strong>，<strong>++释放对象锁++</strong>，阻塞等待，线程状态变为<code>WAITING</code>或<br><code>TIMED_WAITING</code></li>
<li>等待时间到或被其他线程调用notify/notifyAll从条件队列中移除，这时，要重新竞争对象锁<ul>
<li>如果能够获得锁，线程状态变为<code>RUNNABLE</code>，并从wait调用中返回。</li>
<li>否则，该线程加入<strong>对象锁等待队列</strong>，线程状态变为<code>BLOCKED</code>，只有在获得锁后才会从wait调用返回。</li>
</ul>
</li>
</ol>
<p>这里我们一定要区别好两个等待队列，一个是<strong>线程没有分配到cpu时间片进入到的对象锁等待队列</strong>。另一个则是<strong>线程执行遇到条件不满足的情况进入条件等待队列</strong>。</p>
<p>当线程从条件队列中返回不代表其等待的条件就满足了，也有可能是wait方法限定的时间到达了。我们在使用wait方法的时候当其跳出后还应该再判断一次。一般我们通过while循环的方式来做到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">synchronized (obj) &#123;</div><div class="line">    while(条件不成立)</div><div class="line">        obj.wait();</div><div class="line">        </div><div class="line">    …//执行条件满足后的操作</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用notify会把在条件队列中等侍的线程唤醍并从队列中移除，但<strong>它不会释放对象锁</strong>，也就是说，<strong>只有在包含notify的synchronized代码块(被synchronized修饰过了)执行完后，等待的线程才会从wait调用中返回</strong>。这一点需要铭记</p>
<p>我们在使用wait时最难的是搞清楚<strong>wait到底等的是什么？</strong>，而<strong>notify通知的又是什么？</strong> 我们需要知道，它们被不同的线程调用，并共亨相同的锁和条件等待队列（相同对象的<br>synchronized代码块内），它们围绕一个共享的条件变量进行协作，这个条件变量是程序自己维护的，当条件不成立时，线程调用wait进入条件等待队列，另一个线程修改条件后调用notify,调用wait的线程被唤醒后需要重新检查条件变量。从多线程的角度看，它们围绕共享变量进行协作，从调用wait的线程角度看，它阻塞等待一个条件的成立。<strong>我们在设立多线程协作时，需要想清楚协作的<em>++共享变量++</em>和<em>++条件++</em>是什么，这是协作的核心。</strong></p>
<h1 id="线程的基本协作示例"><a href="#线程的基本协作示例" class="headerlink" title="线程的基本协作示例"></a>线程的基本协作示例</h1><p>我们前面说了线程基本协作的场景，这里书上给出了对于这几种场景的代码示例：</p>
<ul>
<li>生产者消费者模式</li>
<li>同时开始</li>
<li>等待结束</li>
<li>异步结果</li>
<li>集合点</li>
</ul>
<h2 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者/消费者模式"></a>生产者/消费者模式</h2><p>队列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static class MyBlockingQueue&lt;E&gt; &#123;</div><div class="line">    private Queue&lt;E&gt; queue = null;</div><div class="line">    private int limit;</div><div class="line">    public MyBlockingQueue(int limit) &#123;</div><div class="line">        this.limit = limit;</div><div class="line">        queue = new ArrayDeque&lt;&gt;(limit);</div><div class="line">    &#125;</div><div class="line">    public synchronized void put(E e) throws InterruptedException &#123;</div><div class="line">        while(queue.size() == limit) &#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">        queue.add(e);</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    public synchronized E take() throws InterruptedException &#123;</div><div class="line">        while(queue.isEmpty()) &#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">        E e = queue.poll();</div><div class="line">        notifyAll();</div><div class="line">        return e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生产者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static class Producer extends Thread &#123;</div><div class="line">    MyBlockingQueue&lt;String&gt; queue;</div><div class="line">    public Producer(MyBlockingQueue&lt;String&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        int num = 0;</div><div class="line">        try &#123;</div><div class="line">            while(true) &#123;</div><div class="line">                String task = String.valueOf(num);</div><div class="line">                queue.put(task);</div><div class="line">                System.out.println(&quot;produce task &quot; + task);</div><div class="line">                num++;</div><div class="line">                Thread.sleep((int) (Math.random() * 100));</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>消费者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">static class Consumer extends Thread &#123;</div><div class="line">    MyBlockingQueue&lt;String&gt; queue;</div><div class="line">    public Consumer(MyBlockingQueue&lt;String&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            while(true) &#123;</div><div class="line">                String task = queue.take();</div><div class="line">                System.out.println(&quot;handle task &quot; + task);</div><div class="line">                Thread.sleep((int)(Math.random()*100));</div><div class="line">            &#125;</div><div class="line">        &#125; catch(InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    MyBlockingQueue&lt;String&gt; queue = new MyBlockingQueue&lt;&gt;(10);</div><div class="line">    new Producer(queue).start();</div><div class="line">    new Consumer(queue).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在生产者消费者模式中，put等待的是队满而take等待的却是队空。但他们都会进入相同的对象的条件等待队列中。由于等待的条件不同，但两者的共享变量却都是该队列，所以此处不能使用notify，因为notify只能唤醒一个线程，而由于线程调度的机制。唤醒的如果是同类线程的话则起不到协调的作用，<strong>所以在共用同一个条件队列而等待的条件却相反时应该使用notifyAll。</strong></p>
<p>Java提供了专门的阻塞队列，包括：</p>
<ul>
<li>接口 BlockingQueue和BlockingDeque</li>
<li>基于数组的实现类 ArrayBlockingQueue</li>
<li>基于链表的实现类 LinkedBlockingQueue和LinkedBlockingDeque</li>
<li>基于堆的实现类 PriorityBlockingQueue</li>
</ul>
<p><strong>在实际场景中，应该优先使用这些实现类。</strong></p>
<h2 id="同时开始"><a href="#同时开始" class="headerlink" title="同时开始"></a>同时开始</h2><p>同时开始的按例好比运动员比赛，一个主线程(裁判)决定着各个子线程(运动员)何时开始。</p>
<p>协作对象fired：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static class FireFlag &#123;</div><div class="line">    private volatile boolean fired = false;</div><div class="line">    public synchronized void waitForFire() throws InterruptedException &#123;</div><div class="line">        while(!fired) &#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public synchronized void fire() &#123;</div><div class="line">        this.fired = true;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运动员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static class Racer extends Thread &#123;</div><div class="line">    FireFlag fireFlag;</div><div class="line">    public Racer(FireFlag fireFlag) &#123;</div><div class="line">        this.fireFlag = fireFlag;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            this.fireFlag.waitForFire();</div><div class="line">            System.out.println(&quot;start run &quot;</div><div class="line">                    + Thread.currentThread().getName());</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>裁判：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    int num = 10;</div><div class="line">    FireFlag fireFlag = new FireFlag();</div><div class="line">    Thread[] racers = new Thread[num];</div><div class="line">    for(int i = 0; i &lt; num; i++) &#123;</div><div class="line">        racers[i] = new Racer(fireFlag);</div><div class="line">        racers[i].start();</div><div class="line">    &#125;</div><div class="line">    Thread.sleep(1000);</div><div class="line">    fireFlag.fire();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="等待结束"><a href="#等待结束" class="headerlink" title="等待结束"></a>等待结束</h2><p>Thread类的join方法的实现其实就是借助于wait方法。其主要代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (isAlive()) &#123;</div><div class="line">    wait(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该代码意义是：只要该等待线程活着就会一直等待，join的结束依赖与线程运行结束的时候Java系统调用notifyAll来通知该等待线程。</p>
<p>使用join有时比较麻烦需要等待各个子线程结束。这里书上给出的例子采用了另一种写法，主线程与子线程协作的是一个数，这个数表示未完成的线程的个数，初始值为子线程个数，主线程需要等待该值变为0，每个子线程结束后需要将该值减一，当为0时调用notifyAll。</p>
<p>协作对象MyLatch：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class MyLatch &#123;</div><div class="line">    private int count;</div><div class="line">    public MyLatch(int count) &#123;</div><div class="line">        this.count = count;</div><div class="line">    &#125;</div><div class="line">    public synchronized void await() throws InterruptedException &#123;</div><div class="line">        while(count &gt; 0) &#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public synchronized void countDown() &#123;</div><div class="line">        count--;</div><div class="line">        if(count &lt;= 0) &#123;</div><div class="line">            notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>子线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static class Worker extends Thread &#123;</div><div class="line">    MyLatch latch;</div><div class="line">    public Worker(MyLatch latch) &#123;</div><div class="line">        this.latch = latch;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            //simulate working on task</div><div class="line">            Thread.sleep((int) (Math.random() * 1000));</div><div class="line">            this.latch.countDown();</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    int workerNum = 100;</div><div class="line">    MyLatch latch = new MyLatch(workerNum);</div><div class="line">    Worker[] workers = new Worker[workerNum];</div><div class="line">    for(int i = 0; i &lt; workerNum; i++) &#123;</div><div class="line">        workers[i] = new Worker(latch);</div><div class="line">        workers[i].start();</div><div class="line">    &#125;</div><div class="line">    latch.await();</div><div class="line">    System.out.println(&quot;collect worker results&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>MyLatch也可以应用在“同时开始”的场景，初始值设为1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class RacerWithLatchDemo &#123;</div><div class="line">    static class Racer extends Thread &#123;</div><div class="line">        MyLatch latch;</div><div class="line">        public Racer(MyLatch latch) &#123;</div><div class="line">            this.latch = latch;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                this.latch.await();</div><div class="line">                System.out.println(&quot;start run &quot;</div><div class="line">                        + Thread.currentThread().getName());</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        int num = 10;</div><div class="line">        MyLatch latch = new MyLatch(1);</div><div class="line">        Thread[] racers = new Thread[num];</div><div class="line">        for(int i = 0; i &lt; num; i++) &#123;</div><div class="line">            racers[i] = new Racer(latch);</div><div class="line">            racers[i].start();</div><div class="line">        &#125;</div><div class="line">        Thread.sleep(1000);</div><div class="line">        latch.countDown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java中提供了一个专门的<strong>同步类CountDownLatch</strong>，在实际开发中应该使用它。</p>
<h2 id="异步结果"><a href="#异步结果" class="headerlink" title="异步结果"></a>异步结果</h2><p>在主从模式中，手工创建线程比较麻烦。一种常见的模式是异步调用，异步调用一般返回一个名为Future的对象，通过它可以获得最终的结果。在Java中表示子任务的接口是Callable。如下是书上例子：</p>
<p>子任务：<strong>Callable</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Callable&lt;V&gt; &#123;</div><div class="line">    V call() throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>异步调用的结果：<strong>Future</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface MyFuture &lt;V&gt; &#123;</div><div class="line">    V get() throws Exception ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过该接口的get方法返回真正的结果。如果结果还没有计算完成，get方法会阻寒直到计算完成，如果调用过程发生异常，则get方法抛出调用过程中的异常。</p>
<p>方便主线程调用子任务的类 <strong>MyExecutor</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public &lt;V&gt; MyFuture&lt;V&gt; execute(final Callable&lt;V&gt; task)</div></pre></td></tr></table></figure></p>
<p>通过该方法<strong>主线程就不需要在创建并管理子线程</strong>了。可以方便的获取到异步调用的结果。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    MyExecutor executor = new MyExecutor();</div><div class="line">    // 子任务</div><div class="line">    Callable&lt;Integer&gt; subTask = new Callable&lt;Integer&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public Integer call() throws Exception &#123;</div><div class="line">            //…执行异步任务</div><div class="line">            int millis = (int) (Math.random() * 1000);</div><div class="line">            Thread.sleep(millis);</div><div class="line">            return millis;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    //异步调用子任务，返回一个MyFuture对象</div><div class="line">    MyFuture&lt;Integer&gt; future = executor.execute(subTask);//内部创了个子线程去执行</div><div class="line">    //…执行其他操作</div><div class="line">    try &#123;</div><div class="line">        //获取异步调用的结果</div><div class="line">        Integer result = future.get();</div><div class="line">        System.out.println(result);</div><div class="line">    &#125; catch(Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以重点是，MyExecutor类的execute方法是怎么实现的呢 <strong>？它封装了创建子线程，同步获取结果的过程，它会创建一个执行子线程。</strong></p>
<p>MyFuture类的execute具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public &lt;V&gt; MyFuture&lt;V&gt; execute(final Callable&lt;V&gt; task) &#123;</div><div class="line">    final Object lock = new Object();</div><div class="line">    final ExecuteThread&lt;V&gt; thread = new ExecuteThread&lt;&gt;(task, lock);</div><div class="line">    thread.start();</div><div class="line">    MyFuture&lt;V&gt; future = new MyFuture&lt;V&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public V get() throws Exception &#123;</div><div class="line">            synchronized (lock) &#123;</div><div class="line">                while(!thread.isDone()) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        lock.wait();</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if(thread.getException() != null) &#123;</div><div class="line">                    throw thread.getException();</div><div class="line">                &#125;</div><div class="line">                return thread.getResult();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    return future;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>execute方法启动一个执行子线程，并返回携带执行结果的MyFuture对象。MyFuture的方法会阻塞等待知道子线程运行结束返回结果。</p>
<p>执行子线程 <strong>ExecuteThread</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">static class ExecuteThread&lt;V&gt; extends Thread &#123;</div><div class="line">    private V result = null;</div><div class="line">    private Exception exception = null;</div><div class="line">    private boolean done = false;</div><div class="line">    private Callable&lt;V&gt; task;</div><div class="line">    private Object lock;</div><div class="line">    public ExecuteThread(Callable&lt;V&gt; task, Object lock) &#123;</div><div class="line">        this.task = task;</div><div class="line">        this.lock = lock;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            result = task.call();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            exception = e;</div><div class="line">        &#125; finally &#123;</div><div class="line">            synchronized (lock) &#123;</div><div class="line">                done = true;</div><div class="line">                lock.notifyAll();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public V getResult() &#123;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">    public boolean isDone() &#123;</div><div class="line">        return done;</div><div class="line">    &#125;</div><div class="line">    public Exception getException() &#123;</div><div class="line">        return exception;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java中也已经包含了一套完善的方案，有：</p>
<ul>
<li>表示<strong>异步结果</strong>的接口Future和实现类FutureTask。</li>
<li>用于<strong>执行异步任务</strong>的接口Executor，以及有更多功能的子接口ExecutorService。<ul>
<li>用于创建Executor和ExecutorService的工厂方法类Executors。  </li>
</ul>
</li>
</ul>
<h2 id="集合点"><a href="#集合点" class="headerlink" title="集合点"></a>集合点</h2><p>和之前等待结束和同时开始案例相似。各线程分开行动，各自到大一个集合点，在集合点需要集齐所有线程，交换数据然后再进行下一步动作。协作的共享变量n，初始值为线程总数，当有一个线程到达集合点n减一。直到变为0即最后一个也到达，通过notifyAll来唤醒所有条件等待线程。</p>
<p>协作对象：<strong>AssemblePoint</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">协作对象public class AssemblePoint &#123;</div><div class="line">    private int n;</div><div class="line">    public AssemblePoint(int n) &#123;</div><div class="line">        this.n = n;</div><div class="line">    &#125;</div><div class="line">    public synchronized void await() throws InterruptedException &#123;</div><div class="line">        if(n &gt; 0) &#123;</div><div class="line">            n--;</div><div class="line">            if(n == 0) &#123;</div><div class="line">                notifyAll();</div><div class="line">            &#125; else &#123;</div><div class="line">                while(n != 0) &#123;</div><div class="line">                    wait();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主线程：<strong>AssemblePointDemo</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class AssemblePointDemo &#123;</div><div class="line">    static class Tourist extends Thread &#123;</div><div class="line">        AssemblePoint ap;</div><div class="line">        public Tourist(AssemblePoint ap) &#123;</div><div class="line">            this.ap = ap;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                //模拟先各自独立运行</div><div class="line">                Thread.sleep((int) (Math.random() * 1000));</div><div class="line">                //㼿㼿</div><div class="line">                ap.await();</div><div class="line">                System.out.println(&quot;arrived&quot;);</div><div class="line">                //…㼿㼿㼿㼿㼿㼿㼿㼿㼿</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final int num = 10;</div><div class="line">        Tourist[] threads = new Tourist[num];</div><div class="line">        AssemblePoint ap = new AssemblePoint(num);</div><div class="line">        for(int i = 0; i &lt; num; i++) &#123;</div><div class="line">            threads[i] = new Tourist(ap);</div><div class="line">            threads[i].start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java中有一个专门的同步工具类CyclicBarrier可以替代该AssemblePoint类。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该节主要介绍了Java中线程间协作的基本机制wait/notify，协作关键要想淸楚协作的共享变贵和条件是什么。Java中有专门为协作而建的阻塞队列、同步工具类，以及Executors框架。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程的基本协作&quot;&gt;&lt;a href=&quot;#线程的基本协作&quot; class=&quot;headerlink&quot; title=&quot;线程的基本协作&quot;&gt;&lt;/a&gt;线程的基本协作&lt;/h1&gt;&lt;p&gt;多线程间除了竞争访问同一资源外，也经常需要相互协作的去执行一些任务。而对于协作的基本机制用的最多的无疑是wait/notify。&lt;/p&gt;
&lt;h2 id=&quot;协作的场景&quot;&gt;&lt;a href=&quot;#协作的场景&quot; class=&quot;headerlink&quot; title=&quot;协作的场景&quot;&gt;&lt;/a&gt;协作的场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;生产者消费者模式：共享队列，一个负责放一个负责取。如果队列长度有限且满了之后则等待。&lt;/li&gt;
&lt;li&gt;同时开始：类似运动员比赛，多个线程同时开始执行。&lt;/li&gt;
&lt;li&gt;等待结束：主线程分发给各个子任务去执行任务，主任务开始执行前需要等待各个子任务执行完毕。&lt;/li&gt;
&lt;li&gt;异步结果：&lt;/li&gt;
&lt;li&gt;集合点&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="并发" scheme="http://www.jiyongguang.xin/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java编程的逻辑 -- 并发章 -- Synchronized</title>
    <link href="http://www.jiyongguang.xin/java-concurrentProgramming-readingNotes-15.2.html"/>
    <id>http://www.jiyongguang.xin/java-concurrentProgramming-readingNotes-15.2.html</id>
    <published>2018-06-22T00:26:46.000Z</published>
    <updated>2018-06-22T00:29:20.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><p>共享内存有两个重要问题，一个是<strong>竞态条件</strong>，一个是<strong>内存可见性</strong>。其实一种解决方案则是Synchronized</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们首先来看一段synchronized修饰方法和代码块的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line">	//修饰方法</div><div class="line">    public synchronized void test1()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">	</div><div class="line">    public void test2()&#123;</div><div class="line">		// 修饰代码块</div><div class="line">        synchronized (this)&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来反编译看一下：<br><img src="https://img-blog.csdn.net/20170205213401778?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnNzeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从上面可以看出，<strong>同步代码块</strong>是使用monitorenter和monitorexit指令实现的，<strong>同步方法</strong>（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。 </p>
<p><strong>同步代码块</strong>：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁。synchronized底层是通过monitor对象，对象有自己的对象头，存储了很多信息，其中一个信息标示是被哪个线程持有。</p>
<p><strong>同步方法</strong>：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。(摘自：<a href="http://www.cnblogs.com/javaminer/p/3889023.html" target="_blank" rel="external">http://www.cnblogs.com/javaminer/p/3889023.html</a>)</p>
<p>具体可参考：</p>
<ul>
<li><a href="https://blog.csdn.net/chenssy/article/details/54883355" target="_blank" rel="external">https://blog.csdn.net/chenssy/article/details/54883355</a></li>
<li><a href="https://blog.csdn.net/u012465296/article/details/53022317" target="_blank" rel="external">https://blog.csdn.net/u012465296/article/details/53022317</a></li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="1-实例方法"><a href="#1-实例方法" class="headerlink" title="1. 实例方法"></a>1. 实例方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Counter &#123;</div><div class="line">    private int count;</div><div class="line">    public synchronized void incr()&#123;</div><div class="line">        count ++;</div><div class="line">    &#125;</div><div class="line">    public synchronized int getCount() &#123;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Synchronized可以用来修饰实例方法，静态方法，(静态或实例)代码块。</p>
<p>多个线程可以同时执行一个Synchronized方法，只要他们访问的不是同一个实例对象即可。</p>
<p><strong>Synchronized实际上保护的是当前实例对象</strong>，而不是它仅描述的那个方法。此时this对象有一个锁和一个等待队列，<strong>锁只能被一个线程持有，</strong> 其他试图获得同样锁的线程需要等待。当前线程不能获得锁的时候，它会加入等待队列，线程的状态会变为<strong>BLOCKED</strong>。</p>
<hr>
<p>Thread有一个与其状态对应的枚举类。Thread.State枚举类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public enum State &#123;</div><div class="line">  NEW,</div><div class="line">  RUNNABLE,</div><div class="line">  BLOCKED,</div><div class="line">  WAITING,</div><div class="line">  TIMED_WAITING,</div><div class="line">  TERMINATED;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于这些状态.我们简单解释下：<br>1) <strong>NEW</strong>:没有调用start的线程状态为NEW。<br>2) <strong>TERMINATED</strong>:线程运行结朿后状态为TERMINATED。<br>3) <strong>RUNNABLE</strong>:调用start后线程在执行run方法且没有阻寒时状态为RUNNABLE,不过，<br>RUNNABLE不代表CPU—定在执行该线程的代码，可能正在执行也可能在等待操作系统分配时间片，只<br>是它没有在等待其他条件。</p>
<h2 id="4-BLOCKED、WAITING、TIMED-WAmNG-都表示线程被阻塞了，在等待一些条件。其中BLOCKED表示当前线程在等待的是CPU的时间片而WAITING、TIMED-WAmNG则等待的是外部条件。"><a href="#4-BLOCKED、WAITING、TIMED-WAmNG-都表示线程被阻塞了，在等待一些条件。其中BLOCKED表示当前线程在等待的是CPU的时间片而WAITING、TIMED-WAmNG则等待的是外部条件。" class="headerlink" title="4) BLOCKED、WAITING、TIMED_WAmNG:都表示线程被阻塞了，在等待一些条件。其中BLOCKED表示当前线程在等待的是CPU的时间片而WAITING、TIMED_WAmNG则等待的是外部条件。"></a>4) <strong>BLOCKED、WAITING、TIMED_WAmNG</strong>:都表示线程被阻塞了，在等待一些条件。其中BLOCKED表示当前线程在等待的是CPU的时间片而WAITING、TIMED_WAmNG则等待的是外部条件。</h2><p><strong>Synchronized保护的是对象而非方法块</strong>，只要访问的是同一个对象的synchronized方法，即使是不同的方法块，也会被同步顺序访问。比如，对于Counter类中的两个同步实例方法get和incr，对同一个Counter对象，一个线程执行get，另一个执行incr,它们是不能同时执行的，会被synchronized同步顺序执行。</p>
<p>此外，需要说明的是，<strong><strong>synchronized方法不能防止非synchronized方法被同时执行</strong></strong>。比如，如果给Counler类增加一个非synchronized方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void decr()&#123;</div><div class="line">    count --;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>则该方法可以和synchronized的incr方法同时执行，这通常会出现非期望的结果，所以，<strong>一般在保护变量时，需要在所有访问该变量的方法前加shsynchronizcd(不一定)</strong>。</p>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a>2. 静态方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class StaticCounter &#123;</div><div class="line">    private static int count = 0;</div><div class="line">    public static synchronized void incr() &#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">    public static synchronized int getCount() &#123;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对实例方法，synchronized保护的是当前实例对象this,<strong>对静态方法，保护的是类对象</strong>，这里是StaticCounter.class。实际上，每个对象都有一个锁和一个等待队列，Class类对象也不例外。</p>
<p>synchronized静态方法和synchronized实例方法保护的是不同的对象，不同的两个线程，可以一个执行synchronized静态方法，另一个执行synchronized实例方法。所以他们可以同时运行</p>
<h3 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3. 代码块"></a>3. 代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Counter &#123;</div><div class="line">    private int count;</div><div class="line">    public void incr()&#123;</div><div class="line">    </div><div class="line">        synchronized(this)&#123;</div><div class="line">            count ++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    public int getCount() &#123;</div><div class="line">        synchronized(this)&#123;</div><div class="line">            return count;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>synchronized括号里即保护的对象，对于实例方法而言则是<strong>this</strong>，<code>{}</code>是执行同步的代码。对于上例中的StaticCounter类，等价的代码则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class StaticCounter &#123;</div><div class="line">    private static int count = 0;</div><div class="line">    public static void incr() &#123;</div><div class="line">        synchronized(StaticCounter.class)&#123;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static int getCount() &#123;</div><div class="line">        synchronized(StaticCounter.class)&#123;</div><div class="line">            return count;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>synchronized同步的对象可以是任意对象，任意对象都有一个锁和等待队列，或者说，任何对象都可以作为锁对象。如下的类成员lock。所以在如下这种情况中，所有的线程中所跑的涉及域lock的方法都会在一个等待队列中排队执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Counter &#123;</div><div class="line">    private int count;</div><div class="line">    private Object lock = new Object();</div><div class="line">    public void incr()&#123;</div><div class="line">        synchronized(lock)&#123;</div><div class="line">            count ++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public int getCount() &#123;</div><div class="line">        synchronized(lock)&#123;</div><div class="line">            return count;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>可重入性</li>
<li>内存可见性</li>
<li>死锁</li>
</ul>
<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>Synchronized是一种可重入锁。</p>
<p><strong>可重入锁是通过记录锁的持有线程和持有数来实现的</strong>，当调用被synchronized保护的代码时，检查对象是否已被锁，如果是，再检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁<br>定，才加入等待队列，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。</p>
<h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>Synchronized除了可以保证原子性，同时还可以保证内存可见性。在释放锁时，所有的写入都会从寄存器或缓存(工作内存)写回内存，而获得锁后都会从内存中获得最新数据。</p>
<p>但如果只是为了保证内存可见性，使用synchronized关键字的成本则要高于volatile修饰符的使用。</p>
<p>如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Switcher &#123;</div><div class="line">    private boolean on;</div><div class="line">    public boolean isOn() &#123;</div><div class="line">        return on;</div><div class="line">    &#125;</div><div class="line">    public void setOn(boolean on) &#123;</div><div class="line">        this.on = on;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该代码在并发执行的时候不涉及非原子操作，仅修改变量on的状态，是一个原子操作。所以这里完全不必要用synchronized修饰符来附加在setOn方法上来锁住整个对象。它并不面临原子性问题，而是面临的内存可见性问题，只需要对on变量用volatile来修饰即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Switcher &#123;</div><div class="line">    private volatile boolean on;</div><div class="line">    public boolean isOn() &#123;</div><div class="line">        return on;</div><div class="line">    &#125;</div><div class="line">    public void setOn(boolean on) &#123;</div><div class="line">        this.on = on;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>经典示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class DeadLockDemo &#123;</div><div class="line">    private static Object lockA = new Object();</div><div class="line">    private static Object lockB = new Object();</div><div class="line">    private static void startThreadA() &#123;</div><div class="line">        Thread aThread = new Thread() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (lockA) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(1000);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                    &#125;</div><div class="line">                    synchronized (lockB) &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        aThread.start();</div><div class="line">    &#125;</div><div class="line">    private static void startThreadB() &#123;</div><div class="line">        Thread bThread = new Thread() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (lockB) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(1000);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                    &#125;</div><div class="line">                    synchronized (lockA) &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        bThread.start();</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        startThreadA();</div><div class="line">        startThreadB();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行后aThread和bThread陷入了相互等待。怎么解决呢？首先，座该尽量避免在持有一个锁的同时去中请另一个锁，如果确实需要多个锁，所有代码都砹该按照相同的顺序去申请锁。比如，对于上面的例子，可以约定都先申请lockA，再申请lockB，而不是像代码中那样分开申请。</p>
<p>不过，在复杂的项目代码中，这种约定可能难以做到。还有一种方法是显示锁接口Lock，它支持尝试获取锁（tryLock)和带时间限制的获取锁方法，使用这些方法可以在获取不到锁的时候释放已经持有的锁，然后再次尝试获取锁或干脆放弃，以避免死锁。<br>如采还是出现了死锁，Java不会主动处理，不过借助一些工貝，我们可以发现运行中的死锁，比如，Java自带的<strong>jsiadc命令</strong>会报告发现的死锁。</p>
<h2 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h2><p>类Collections中提供了一些方法，返回线程安全的同步容器。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-21/46493932.jpg" alt=""></p>
<p>它们是給所有容器方法都加上synchronized来实现线程安全的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt; &#123;</div><div class="line">    final Collection&lt;E&gt; c;  //Backing Collection</div><div class="line">    final Object mutex;     //Object on which to synchronize</div><div class="line">    SynchronizedCollection(Collection&lt;E&gt; c) &#123;</div><div class="line">        if(c==null)</div><div class="line">            throw new NullPointerException();</div><div class="line">        this.c = c;</div><div class="line">        mutex = this;</div><div class="line">    &#125;</div><div class="line">    public int size() &#123;</div><div class="line">        synchronized (mutex) &#123;return c.size();&#125;</div><div class="line">    &#125;</div><div class="line">    public boolean add(E e) &#123;</div><div class="line">        synchronized (mutex) &#123;return c.add(e);&#125;</div><div class="line">    &#125;</div><div class="line">    public boolean remove(Object o) &#123;</div><div class="line">        synchronized (mutex) &#123;return c.remove(o);&#125;</div><div class="line">    &#125;</div><div class="line">   //…</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的线程安全指的是容器对象，即当多个线程并发访问同一个容器对象时不需要额外的同步操作，也不会出现错误的结果。</p>
<p>加了synchronized之后所有操作都变成了原子操作，但并不意味着客户端在调用的时候就绝对安全了。以下情况还需注意：</p>
<ul>
<li>复合操作，比如先检查后更新</li>
<li>伪同步</li>
<li>迭代</li>
</ul>
<h3 id="1-复合操作"><a href="#1-复合操作" class="headerlink" title="1. 复合操作"></a>1. 复合操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class EnhancedMap &lt;K, V&gt; &#123;</div><div class="line">    Map&lt;K, V&gt; map;</div><div class="line">    public EnhancedMap(Map&lt;K,V&gt; map)&#123;</div><div class="line">        this.map = Collections.synchronizedMap(map);</div><div class="line">    &#125;</div><div class="line">    public V putIfAbsent(K key, V value)&#123;</div><div class="line">         V old = map.get(key);</div><div class="line">         if(old!=null)&#123;</div><div class="line">             return old;</div><div class="line">         &#125;</div><div class="line">         return map.put(key, value);</div><div class="line">     &#125;</div><div class="line">    public V put(K key, V value)&#123;</div><div class="line">        return map.put(key, value);</div><div class="line">    &#125;</div><div class="line">    //…</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码中的putIfAbsent方法在多线程下显然是不安全的。如果多个线程都执行这一步则必然会出现竞态条件。</p>
<h3 id="2-伪同步"><a href="#2-伪同步" class="headerlink" title="2. 伪同步"></a>2. 伪同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public synchronized V putIfAbsent(K key, V value)&#123;</div><div class="line">    V old = map.get(key);</div><div class="line">    if(old!=null)&#123;</div><div class="line">        return old;</div><div class="line">    &#125;</div><div class="line">    return map.put(key, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上代码即便加上synchronized关键字修饰也任然是不安全的。因为我们<strong>同步错了对象</strong>，putlfAbsent同步使用的是EnhancedMap对象，而其他方法(如代码中的put方法）使用的是Collections.synchronizedMap返回的对象map、两者是不同的对象。要解决这个问题，<strong>所有方法必须使用相同的锁</strong>，可以使用EnhancedMap的对象锁，也可以使用map对象锁。使用EnhancedMap对象作为锁，则Enhanced-Map中的所有方法都需耍加上synchronized。使用map作为锁，putlfAbsent方法可以改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public V putIfAbsent(K key, V value)&#123;</div><div class="line">    synchronized(map)&#123;</div><div class="line">         V old = map.get(key);</div><div class="line">         if(old!=null)&#123;</div><div class="line">             return old;</div><div class="line">         &#125;</div><div class="line">         return map.put(key, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-迭代"><a href="#3-迭代" class="headerlink" title="3. 迭代"></a>3. 迭代</h3><p>对于同步容器虽然单个操作是安全的，但是迭代却不是。如下代码截取自Collections.SynchronizedList类。可以看到函数并不是同步实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ListIterator&lt;E&gt; listIterator() &#123;</div><div class="line">    return list.listIterator(); // Must be manually synched by user</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ListIterator&lt;E&gt; listIterator(int index) &#123;</div><div class="line">    return list.listIterator(index); // Must be manually synched by user</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们通过两个线程来并发的修改和迭代该同步容器则会出现List迭代时规定的并发修改异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">private static void startModifyThread(final List&lt;String&gt; list) &#123;</div><div class="line">    Thread modifyThread = new Thread(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for(int i = 0; i &lt; 100; i++) &#123;</div><div class="line">                list.add(&quot;item &quot; + i);</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep((int) (Math.random() * 10));</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    modifyThread.start();</div><div class="line">&#125;</div><div class="line">private static void startIteratorThread(final List&lt;String&gt; list) &#123;</div><div class="line">    Thread iteratorThread = new Thread(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            while (true) &#123;</div><div class="line">                for(String str : list) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    iteratorThread.start();</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    final List&lt;String&gt; list = Collections</div><div class="line">            .synchronizedList(new ArrayList&lt;String&gt;());</div><div class="line">    startIteratorThread(list);</div><div class="line">    startModifyThread(list);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;Thread-0&quot; java.util.ConcurrentModificationException</div><div class="line">    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:859)</div><div class="line">    at java.util.ArrayList$Itr.next(ArrayList.java:831)</div></pre></td></tr></table></figure></p>
<p>我们知道对于遍历操作而言，如果迭代时容器发生了结构性变化。就会抛出该异常。很显然同步容器并没有解决这个问题，要想避免这个问题则需要在<strong>遍历的时候给整个容器对象加锁。</strong> 即谁无法保证线程安全，方法体中的代码块就锁谁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private static void startIteratorThread(final List&lt;String&gt; list) &#123;</div><div class="line">    Thread iteratorThread = new Thread(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            while(true) &#123;</div><div class="line">                synchronized(list)&#123;</div><div class="line">                    for(String str : list) &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-并发容器"><a href="#4-并发容器" class="headerlink" title="4. 并发容器"></a>4. 并发容器</h3><p>在使用synchronized的时候除了需要注意以上注意事项，同时同步容器的性能也是比较低的，当并发访问量比较大的时候性能比较差。但Java还为我们提供了很多专为并发设计的容器类。比如：</p>
<ul>
<li>CopyOnWriteArrayList</li>
<li>ConcurrentHashMap</li>
<li>ConcurrentLinkedQueue</li>
<li>ConcurrentSkipListSet</li>
</ul>
<p>这些容器类都是线程安全的，仍但都没有使用synchronized，没存迭代问题，直接支持一些复合操作，<br>性能也搞得多。</p>
<h2 id="释放锁的时机"><a href="#释放锁的时机" class="headerlink" title="释放锁的时机"></a>释放锁的时机</h2><ul>
<li>当方法(代码块)执行完毕后会自动释放锁，不需要做任何的操作。</li>
<li>当一个线程执行的代码出现异常时，其所持有的锁会自动释放。</li>
</ul>
<p>不会由于异常导致出现死锁现象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Synchronized&quot;&gt;&lt;a href=&quot;#Synchronized&quot; class=&quot;headerlink&quot; title=&quot;Synchronized&quot;&gt;&lt;/a&gt;Synchronized&lt;/h1&gt;&lt;p&gt;共享内存有两个重要问题，一个是&lt;strong&gt;竞态条件&lt;/s
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>并发编程实战读书笔记</title>
    <link href="http://www.jiyongguang.xin/java-concurrent-shizhan.html"/>
    <id>http://www.jiyongguang.xin/java-concurrent-shizhan.html</id>
    <published>2018-06-15T09:06:41.000Z</published>
    <updated>2018-06-22T00:28:34.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从今天开始读并发编程实战，</p>
<p>这边文章仅简单记录自己学习时遇到的琐碎知识点</p>
<h1 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="第一章 简介"></a>第一章 简介</h1><p>操作系统保证了系统可以运行多个程序，它为多个不同的进程分配各种资源，包括内存，文件句柄，以及安全证书等。如果需要，不同进程间还可以通过一些粗粒度的通信机制来交换数据，包括：套接字，信号处理器，共享内存，信号量及文件。</p>
<p><strong>同一个程序中的多个线程也可以被同时调度到多个CPU上运行。</strong></p>
<a id="more"></a>
<p>如果在程序中只有一个线程，那么它最多同时只能在一个处理器上运行。在有十个处理器的的系统上，单线程的程序只能使用1/10的CPU资源。另一方面多线程程序可以同时在多个处理器上工作，进而提高处理器的利用率来提升系统吞吐率。</p>
<p>使用多个线程还有助于在单处理器系统上获得更高的吞吐率。如果程序是单线程的，那么当程序等待某个同步 I/O 操作(<strong>CPU置空</strong>)完成时，处理器将处于空闲状态。而在多线程程序中，如果一个、线程在等待 I/O 操作完成，另一个线程可以继续运行，使程序能够在 I/O 阻塞期间继续运行。（这就好比在等待水烧开的同时看报纸，而不是等到水烧开之后再开始看报纸）。</p>
<p>非线程安全的数值序列生成器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@NotThreadSafe</div><div class="line">public class UnsafeSequence &#123;</div><div class="line"></div><div class="line">    private int value;</div><div class="line"></div><div class="line">    /* 返回一个唯一的数值 */</div><div class="line">    public int getValue() &#123;</div><div class="line">        return value++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并发情况下程序可能的执行流程：<br>A：线程A，B：线程B<br><img src="http://otsgsfu16.bkt.clouddn.com/18-6-12/95933787.jpg" alt=""></p>
<p>由于JVM中存在指令重排序的可能，因此实际情况可能更糟。</p>
<p>在多线程的环境下，只要我们<strong>不使用成员变量(线程间共享数据)</strong>,那么就不会出现线程安全的问题了。</p>
<p><strong>活跃性问题</strong>：当某个操作无法继续执行下去时，就会发生活跃性问题。形式单线程中之一就是程序无意中造成的无限循环，多线程情况下的死锁问题。</p>
<p><strong>性能问题</strong>：在多线程程序中，当线程调度器临时挂起活跃线程并转而运行另一个线程时，就<strong>会频繁地出现上下文</strong>切换操作，这种操作将带来极大的开销：保存和恢复执行上下文，丢失局部性，并且<strong>CPU时间将更多地花在线程调度而不是线程运行上。</strong> 当线程共享数据时，必须使用同步机制，而这些机制往往<strong>会抑制某些编译器优化</strong>，使内存缓存区(工作内存)中的数据无效，以及增加共享内存总线的同步流量。</p>
<h1 id="第二章-线程安全性"><a href="#第二章-线程安全性" class="headerlink" title="第二章 线程安全性"></a>第二章 线程安全性</h1><p>Java 中的主要同步机制是关键字 synchronized ，它提供了一种独占的加锁方式，但“同步”．这个术语还包括 volatile 类型的变量，显式锁（ ExPllcit Lock ）以及原子变量。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-14/94017935.jpg" alt=""></p>
<p>有时候，面向对象中的抽象和封装会降低程序的性能（尽管很少有开发人员相信），但在编写并发应用程序时，一种正确的编程方法就是：<strong>首先使代码正确运行，然后再提高代码的速度。</strong> 即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能提升时，才进行优化。 </p>
<p>需要明白的是，<strong>完全由线程安全类构成的程序并不一定就是线程安全的，</strong> 而在线程安全的类中也可以包含非线程安全的类。</p>
<p>一个类是无状态的意味着该类不包含任何属于本类的域(<strong>成员变量</strong>)，也不包含任何其他类中域的引用(其他类属性)。<strong>无状态对象一定是线程安全的。</strong></p>
<ul>
<li>竞态条件：当某个计算的正确性需要<strong>依赖多线程交替执行</strong>时。如下代码块：<ul>
<li>避免：要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。</li>
</ul>
</li>
</ul>
<p>延迟初始化示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@NotThreadSafe</div><div class="line">public class Singleton &#123;</div><div class="line"></div><div class="line">    private Singleton singleton = null;</div><div class="line"></div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">       </div><div class="line">        if (singleton == null) &#123;// 竞态条件</div><div class="line">            singleton = new Singleton();</div><div class="line">        &#125;</div><div class="line">        return singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了确保线程安全性，“先检查后执行”（例如延迟初始化）和“读取一修改一写入” （例如递增运算）等<strong>操作必须是原子的</strong>。我们将“先检查后执行”以及“读取一修改一写入”等操作统称为复合操作：包含了一组必须以原子方式执行的操作以确保线程安全性。</p>
<p>改进写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@ThreadSafe</div><div class="line">public class Singleton &#123;</div><div class="line"></div><div class="line">    private static volatile Singleton singleton = null;</div><div class="line">    /* 这里使用volatile修饰的目的是可以提升程序的性能，</div><div class="line">    对于没有进入if代码块的线程关于singleton变量的修改可以第一时间被通知到，</div><div class="line">    这样就不会有过多的线程由于没有拿到已被初始化的singleton了</div><div class="line">    ，而出的大量的涌入到同步代码块中去争锁的情况。*/</div><div class="line"></div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        if (singleton == null) &#123;</div><div class="line">            synchronized (Singleton.class) &#123;// 通过synchronized关键字来对代码块上锁</div><div class="line">                if (singleton == null) &#123;</div><div class="line">                    singleton = new Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>延迟初始化示例中我们通过synchronized独占锁来保证了“先检查后执行”操作的原子性。</p>
<p>在没有synchronized关键字做出保证的情况下，只有volatile关键字修饰的变量，在不能保证运算操作的原子性问题上我们可以借助Java提供的concurrent包下的atomic包中的原子类来保证。</p>
<ul>
<li>数据竞争：多线程情况下<strong>数据不同步</strong>导致带来的并发修改等问题，(volatile关键字做的事情就是在其修饰的变量保证不涉及非原子性的操作的基础上，来保证多线程间共享变量的同步的)</li>
</ul>
<p>在一般实际开发过程中的多线程环境下，应尽可能的使用现有的线程安全对象(例如AtomicLong)来管理类的状态。即类中的成员属性应该尽可能的都由线程安全的对象来修饰，进而保证如果以后这类成员变量遇到修改操作等 可以直接拿来使用，扩展性更高。(当某个成员变量已经可以通过其他同步方式保证那么不建议这么做)</p>
<p>要保证多线程中状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。</p>
<p>以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以 Class 对象作为锁。</p>
<p>synchronized关键字的锁是一种排它锁，通过其修饰的内容可以保证了多线程间的安全问题，但紧接着就会出现的是性能问题。</p>
<p>我们在书写同步代码块的时候，应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去。</p>
<p>如果一种同步机制已经可以在安全上带来保证，那么应该杜绝多种同步机制的联合使用。比如对于一个并发计数操作，我们一个基本类型的int变量在同步代码块中已经保证了他的并发修改的安全性，你还要把这个int类型的变量用AtomicInteger来取代。那么无论从性能上还是安全上来考虑都是极不合理的。</p>
<p>要判断同步代码块的合理大小，个铃求必须得到满足）、需要在各种设计需求之间进行权衡，简单性和性能。有时候．包括安全性(这个需求必须得到满足)，简单性和性能。有时候，在简单性与性能之间会发生冲突，在二者之间通常能找到某种合理的平衡。当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性(这可能会破坏安全性)。</p>
<p>当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论是执行计算密集的操作，还是在执行某个可能阻塞的操作．如果持有锁的时间过长，那么都会带来活跃性或性能问题。当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。</p>
<h1 id="第三章-对象的共享"><a href="#第三章-对象的共享" class="headerlink" title="第三章 对象的共享"></a>第三章 对象的共享</h1><h1 id="第四章-对象的组合"><a href="#第四章-对象的组合" class="headerlink" title="第四章 对象的组合"></a>第四章 对象的组合</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从今天开始读并发编程实战，&lt;/p&gt;
&lt;p&gt;这边文章仅简单记录自己学习时遇到的琐碎知识点&lt;/p&gt;
&lt;h1 id=&quot;第一章-简介&quot;&gt;&lt;a href=&quot;#第一章-简介&quot; class=&quot;headerlink&quot; title=&quot;第一章 简介&quot;&gt;&lt;/a&gt;第一章 简介&lt;/h1&gt;&lt;p&gt;操作系统保证了系统可以运行多个程序，它为多个不同的进程分配各种资源，包括内存，文件句柄，以及安全证书等。如果需要，不同进程间还可以通过一些粗粒度的通信机制来交换数据，包括：套接字，信号处理器，共享内存，信号量及文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同一个程序中的多个线程也可以被同时调度到多个CPU上运行。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="并发" scheme="http://www.jiyongguang.xin/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Thread类源码剖析</title>
    <link href="http://www.jiyongguang.xin/java-thread.html"/>
    <id>http://www.jiyongguang.xin/java-thread.html</id>
    <published>2018-06-11T03:10:18.000Z</published>
    <updated>2018-06-11T03:12:26.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thread-类-常见Api剖析"><a href="#Thread-类-常见Api剖析" class="headerlink" title="Thread 类 常见Api剖析"></a>Thread 类 常见Api剖析</h1><h2 id="Thread类构造函数"><a href="#Thread类构造函数" class="headerlink" title="Thread类构造函数"></a>Thread类构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public Thread() &#123;</div><div class="line">    init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Thread(Runnable target) &#123;</div><div class="line">    init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Thread(Runnable target, String name) &#123;</div><div class="line">    init(null, target, name, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Thread(String name) &#123;</div><div class="line">    init(null, null, name, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>虽然4个构造函数的函数签名不同，但是低层调用的init方法却是一致的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Initializes a Thread with the current AccessControlContext.</div><div class="line"> * @see #init(ThreadGroup,Runnable,String,long,AccessControlContext)</div><div class="line"> */</div><div class="line">private void init(ThreadGroup g, Runnable target, String name,</div><div class="line">                  long stackSize) &#123;</div><div class="line">    init(g, target, name, stackSize, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该初始化方法负责构造当前线程所在的线程组ThreadGroup，真实运行的线程对象target，线程名name，线程栈的大小stackSize，访问控制的上下文null。</p>
<h2 id="getName"><a href="#getName" class="headerlink" title="getName"></a>getName</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Returns this thread&apos;s name.</div><div class="line"> */</div><div class="line">private volatile String name; // 线程名，volatile修饰保证了并发修改情况下的可见性</div><div class="line"></div><div class="line">public final String getName() &#123;</div><div class="line">    return name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="setName"><a href="#setName" class="headerlink" title="setName"></a>setName</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/* Java thread status for tools,</div><div class="line"> * initialized to indicate thread &apos;not yet started&apos;</div><div class="line"> */</div><div class="line"></div><div class="line">private volatile int threadStatus = 0;// 线程状态 初始为0，表示已被创建</div><div class="line"></div><div class="line">/**</div><div class="line"> * Changes the name of this thread to be equal to the argument</div><div class="line"> * &lt;code&gt;name&lt;/code&gt;.</div><div class="line"> */</div><div class="line">public final synchronized void setName(String name) &#123;</div><div class="line">    checkAccess();// 查看当前线程是否为null 以及是否具有修改权限</div><div class="line">    if (name == null) &#123;</div><div class="line">        throw new NullPointerException(&quot;name cannot be null&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    this.name = name;</div><div class="line">    if (threadStatus != 0) &#123;</div><div class="line">        setNativeName(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="checkAccess"><a href="#checkAccess" class="headerlink" title="checkAccess"></a>checkAccess</h2><p>该checkAccess方法可以确定当前正在运行的线程是否有权修改此线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Determines if the currently running thread has permission to</div><div class="line"> * modify this thread.</div><div class="line"> */</div><div class="line">public final void checkAccess() &#123;</div><div class="line">    SecurityManager security = System.getSecurityManager();</div><div class="line">    if (security != null) &#123;</div><div class="line">        security.checkAccess(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void checkAccess(Thread t) &#123;</div><div class="line">    if (t == null) &#123;</div><div class="line">        throw new NullPointerException(&quot;thread can&apos;t be null&quot;);</div><div class="line">    &#125;</div><div class="line">    if (t.getThreadGroup() == rootGroup) &#123;</div><div class="line">        checkPermission(SecurityConstants.MODIFY_THREAD_PERMISSION);</div><div class="line">    &#125; else &#123;</div><div class="line">        // just return</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>守护线程是为其他线程服务的</p>
<ul>
<li>垃圾回收线程就是守护线程</li>
</ul>
<p>守护线程有一个特点：</p>
<ul>
<li>当别的用户线程执行完了，虚拟机就会退出，守护线程也就会被停止掉了。</li>
<li>也就是说：守护线程作为一个<strong>服务线程</strong>，没有服务对象就没有必要继续运行了。</li>
</ul>
<p><strong>使用线程的时候要注意的地方</strong></p>
<ol>
<li><strong>在线程启动前</strong>设置为守护线程，方法是<code>setDaemon(boolean on)</code></li>
<li>使用守护线程<strong>不要访问共享资源</strong>(数据库、文件等)，因为它可能会在任何时候就挂掉了。</li>
<li>守护线程中产生的新线程也是守护线程</li>
</ol>
<h2 id="setDaemon"><a href="#setDaemon" class="headerlink" title="setDaemon"></a>setDaemon</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Marks this thread as either a &#123;@linkplain #isDaemon daemon&#125; thread</div><div class="line"> * or a user thread. The Java Virtual Machine exits when the only</div><div class="line"> * threads running are all daemon threads.</div><div class="line"> */</div><div class="line">public final void setDaemon(boolean on) &#123;</div><div class="line">    checkAccess();</div><div class="line">    if (isAlive()) &#123;// 如果当前线程活着</div><div class="line">        throw new IllegalThreadStateException();</div><div class="line">    &#125;</div><div class="line">    daemon = on;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过注释可以看出，当运行的唯一线程也为守护线程的时候JVM退出。</li>
<li>通过代码中if语句的判断也可以看出，我们需要在线程启动之前即调用start函数之前设置其是否为守护线程。否则会跑出异常</li>
</ul>
<h1 id="优先级线程"><a href="#优先级线程" class="headerlink" title="优先级线程"></a>优先级线程</h1><p>线程优先级高仅仅表示线程获取的CPU时间片的几率高，但这不是一个确定的因素！</p>
<p><strong>线程的优先级是高度依赖于操作系统的</strong>，Windows和Linux就有所区别(Linux下优先级可能就被忽略了)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * The minimum priority that a thread can have.</div><div class="line"> */</div><div class="line">public final static int MIN_PRIORITY = 1;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The default priority that is assigned to a thread.</div><div class="line"> */</div><div class="line">public final static int NORM_PRIORITY = 5;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The maximum priority that a thread can have.</div><div class="line"> */</div><div class="line">public final static int MAX_PRIORITY = 10;</div></pre></td></tr></table></figure>
<h2 id="setPriority"><a href="#setPriority" class="headerlink" title="setPriority"></a>setPriority</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Changes the priority of this thread.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * ···</div><div class="line"> * ···</div><div class="line"> * Otherwise, the priority of this thread is set to the smaller of</div><div class="line"> * the specified &lt;code&gt;newPriority&lt;/code&gt; and the maximum permitted</div><div class="line"> * priority of the thread&apos;s thread group.</div><div class="line"> */</div><div class="line">public final void setPriority(int newPriority) &#123;</div><div class="line">    ThreadGroup g;</div><div class="line">    checkAccess();</div><div class="line">    if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</div><div class="line">        throw new IllegalArgumentException();</div><div class="line">    &#125;</div><div class="line">    if((g = getThreadGroup()) != null) &#123;</div><div class="line">        if (newPriority &gt; g.getMaxPriority()) &#123;// newProiority控制在当前线程组的最大值中。</div><div class="line">            newPriority = g.getMaxPriority();</div><div class="line">        &#125;</div><div class="line">        setPriority0(priority = newPriority);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private native void setPriority0(int newPriority);</div></pre></td></tr></table></figure>
<p>头注释也交代的很清楚，如果该传入的参数<code>newPriority</code>大于当前线程所在线程组的最大优先值得话就让该<code>newPriority</code>等于线程组的最大优先值。</p>
<h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><p>线程有3个基本状态：执行、就绪、阻塞</p>
<p>Thread上很多的方法都是用来切换线程的状态的，这一部分是重点！</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-8/94955655.jpg" alt=""></p>
<p>其实上面这个图是不够完整的，省略掉了一些东西。后面在讲解的线程状态的时候我会重新画一个。</p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Causes the currently executing thread to sleep (temporarily cease</div><div class="line"> * execution) for the specified number of milliseconds, subject to</div><div class="line"> * the precision and accuracy of system timers and schedulers. The thread</div><div class="line"> * does not lose ownership of any monitors.</div><div class="line"> */</div><div class="line">public static native void sleep(long millis) throws InterruptedException;</div></pre></td></tr></table></figure>
<p>如头注释所说在指定的毫秒数内让当前正在执行的线程休眠（阻塞状态）。且该线程不丢失任何监视器的所属权。</p>
<p>需要注意的是，等时间到了，<strong>进入的是就绪状态而并非是运行状态。</strong> 如图所示：</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-9/84736935.jpg" alt=""></p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A hint to the scheduler that the current thread is willing to yield</div><div class="line"> * its current use of a processor. The scheduler is free to ignore this</div><div class="line"> * hint</div><div class="line"> */</div><div class="line">public static native void yield();</div></pre></td></tr></table></figure>
<p>如头注释所述yield方法会向调度程序提示当前线程愿意让出正在使用的CPU，但是这个调度程序可以自由的忽略这个提示。<br>言外之意当前线程调用yield方法会先让别的线程执行，但是不不确保真正的让出了CPU，最终还是要看调度器是什么行为。该方法很少被使用，因为他并不是一个确定的行为。</p>
<ul>
<li>我有空，可以的话(CPU决定)，让你们先执行</li>
</ul>
<p>此时刚才的图就能补充成这样：<br><img src="http://otsgsfu16.bkt.clouddn.com/18-6-9/90517865.jpg" alt=""></p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>调用join方法，会等待该线程执行完毕后(死亡)才执行别的线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Waits for this thread to die.</div><div class="line"> */</div><div class="line">public final void join() throws InterruptedException &#123;</div><div class="line">    join(0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Waits at most &#123;@code millis&#125; milliseconds for this thread to</div><div class="line"> * die. A timeout of &#123;@code 0&#125; means to wait forever.</div><div class="line"> *</div><div class="line"> * &lt;p&gt; This implementation uses a loop of &#123;@code this.wait&#125; calls</div><div class="line"> * conditioned on &#123;@code this.isAlive&#125;. As a thread terminates the</div><div class="line"> * &#123;@code this.notifyAll&#125; method is invoked. It is recommended that</div><div class="line"> * applications not use &#123;@code wait&#125;, &#123;@code notify&#125;, or</div><div class="line"> * &#123;@code notifyAll&#125; on &#123;@code Thread&#125; instances.</div><div class="line"> */</div><div class="line">public final synchronized void join(long millis)</div><div class="line">    throws InterruptedException &#123;</div><div class="line">    long base = System.currentTimeMillis();// 记录当前系统时间 毫秒单位</div><div class="line">    long now = 0;</div><div class="line"></div><div class="line">    if (millis &lt; 0) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (millis == 0) &#123;</div><div class="line">        while (isAlive()) &#123;// millis == 0时，在当前线程活动状态下无线等待</div><div class="line">            wait(0);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        while (isAlive()) &#123;// millis非0有限定时间 一段时间内该线程没有死亡就不等了</div><div class="line">            long delay = millis - now;</div><div class="line">            if (delay &lt;= 0) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            wait(delay);</div><div class="line">            now = System.currentTimeMillis() - base;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>join(long millis)</code>方法头注释所述：</p>
<ul>
<li>等待该线程终止的时间最长为<code>millis</code>毫秒。如果<code>millis</code>为0意味着要一直等下去。</li>
<li>依赖isAlive()判断条件判断当前线程所处的状态，如果为活动状态那么循环调用wait方法直到其死亡。<ul>
<li>当线程终止时，调用notifyAll方法来唤醒。建议应用程序不要在Thread实例上使用wait，notify或notifyAll方法(像join方法所示类中直接调用)。</li>
</ul>
</li>
</ul>
<h3 id="join-方法参考资料"><a href="#join-方法参考资料" class="headerlink" title="join 方法参考资料"></a>join 方法参考资料</h3><ul>
<li><a href="https://www.zhihu.com/question/27485990/answer/36824828" target="_blank" rel="external">https://www.zhihu.com/question/27485990/answer/36824828</a></li>
</ul>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>wait方法是在Object上定义的，它是native本地方法。函数意图：在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final native void wait(long timeout) throws InterruptedException;</div></pre></td></tr></table></figure></p>
<p>wait方法实际上它也是<strong>计时等待(如果带时间参数)</strong> 的一种！，于是我们的图就可以补充为：</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-9/80274308.jpg" alt=""><br>等待处，即我们调用join方法来使当前线程在一段时间内等待其死亡，如果死亡了那么他就结束了。如果没有那就进入就绪态等待获取执行权继续执行。</p>
<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p>线程中断在之前的版本有stop方法，但是被设置过时了。现在已经<strong>没有强制线程终止的方法了</strong>！</p>
<p>由于stop方法可以让一个线程A终止掉另一个线程B</p>
<ul>
<li>被终止的线程B会<strong>立即释放锁</strong>，这可能会让<strong>对象处于不一致的状态。</strong></li>
<li><strong>线程A也不知道线程B什么时候能够被终止掉，</strong> 如果线程B还处于运行计算阶段，线程A调用stop方法将线程B终止，那么进度就丢失了。</li>
</ul>
<p>总而言之，Stop方法看起来设计的就很不合理，不安全而且太暴力，所以被设置过时了。</p>
<p>在终止线程上我们一般使用的是interrupt方法来<strong>请求终止线程。</strong></p>
<ul>
<li>要注意的是：<strong>interrupt不会真正停止一个线程</strong>，它仅仅是给这个线程发了一个信号告诉它，它应该要结束了(明白这一点非常重要！)</li>
<li>也就是说：Java设计者实际上是想<strong>线程自己来终止</strong>，通过上面的信号，就可以判断处理什么业务了。</li>
<li>具体到底中断还是继续运行，应该由<strong>被通知的线程自己处理</strong></li>
</ul>
<p>也就是我们不会杀死当前线程，只是给它标记了一个标志位告诉他他该中断了。但是具体是否要中断由它自己。</p>
<p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Thread t1 = <span class="keyword">new</span> Thread( <span class="keyword">new</span> Runnable()&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 若未发生中断，就正常执行任务</span></div><div class="line">        <span class="keyword">while</span>(!Thread.currentThread.isInterrupted())&#123;</div><div class="line">            <span class="comment">// 正常任务代码……</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 中断的处理代码……</span></div><div class="line">        doSomething();</div><div class="line">    &#125;</div><div class="line">&#125; ).start();</div></pre></td></tr></table></figure></p>
<p>再次说明：调用interrupt()<strong>并不是要真正终止掉当前线程</strong>，仅仅是设置了一个<strong>中断标志</strong>。这个中断标志可以给我们用来判断什么时候该干什么活！什么时候中断由我们自己来决定，这样就可以<strong>安全地终止线程了</strong>！</p>
<p>来看一下源码是如何叙述的：<br><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d8e16e2e908f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<ul>
<li>只有当前线程自己可以调用interrupt中断方法。否则会抛出SecurityException。</li>
<li>如果当前线程在调用Object的<code>wait()</code>，<code>wait(long)</code>或<code>wait(long, int)</code>方法，或者该类的 <code>join(),</code>、<code>join(long)</code>,<code>join(long, int)</code>,<code>sleep(long)</code>或 <code>sleep(long, int)</code>方法时被调用interrupt方法而中断了的话。由于那些方法本身已经使线程中断，所以interrupt方法在这里所做的功能就是解除线程中断的左右。所以该线程的中断状态将被解除，JVM会将线程的中断标志重新设置为false(interrupt方法有这个功能)，并且还将收到一个 InterruptedException。这些调用时会抛出InterruptedException的方法是支持线程中断的方法(就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常)。</li>
<li>被阻塞的类调用中断状态是没有意义的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void interrupt() &#123;</div><div class="line">    if (this != Thread.currentThread())// 判断是否是当前线程本身调用的</div><div class="line">        checkAccess();</div><div class="line"></div><div class="line">    synchronized (blockerLock) &#123;</div><div class="line">        Interruptible b = blocker;</div><div class="line">        if (b != null) &#123;// 判断线程是否被阻塞了</div><div class="line">            interrupt0();           // interrupt status将清除 </div><div class="line">            b.interrupt(this); // 打断线程并抛出InterruptedException</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    interrupt0();// 如果没有被阻塞那么直接修改线程中断标记位即可。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看看刚才说抛出的异常是什么东东吧：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d8e16e562fe4f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>所以说：<strong>interrupt方法压根是不会对线程的状态造成影响的，它仅仅设置一个标志位罢了</strong></p>
<p>interrupt线程中断还有另外<strong>两个方法(检查该线程是否被中断)</strong>：</p>
<ul>
<li>静态方法interrupted()–&gt;会清除中断标志位</li>
<li>实例方法isInterrupted()–&gt;不会清除中断标志位</li>
</ul>
<p><strong>interrupted()</strong></p>
<p>测试当前线程是否已经中断。如果已经中断那么调用该方法会清除线程的中断标志位，如果没有中断则返回false。函数功能相当于<strong>解除线程中断标志的功能</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static boolean interrupted() &#123;</div><div class="line">    return currentThread().isInterrupted(true);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>isInterrupted</strong></p>
<p>测试线程是否已经中断。线程的中断状态不受该方法的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean isInterrupted() &#123;</div><div class="line">    return isInterrupted(false);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面还提到了，如果阻塞线程调用了interrupt()方法，那么会抛出异常，设置标志位为false，同时该线程会退出阻塞的。我们来测试一波：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Main main = new Main();</div><div class="line"></div><div class="line">        // 创建线程并启动</div><div class="line">        Thread t = new Thread(main.runnable);</div><div class="line">        System.out.println(&quot;This is main &quot;);</div><div class="line">        t.start();</div><div class="line"></div><div class="line">        try &#123;</div><div class="line"></div><div class="line">            // 在 main线程睡个3秒钟</div><div class="line">            Thread.sleep(3000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            System.out.println(&quot;In main&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 设置中断</div><div class="line">        t.interrupt();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Runnable runnable = () -&gt; &#123;</div><div class="line">        int i = 0;</div><div class="line">        try &#123;</div><div class="line">            while (i &lt; 1000) &#123;</div><div class="line"></div><div class="line">                // 睡个半秒钟我们再执行</div><div class="line">                Thread.sleep(500);</div><div class="line"></div><div class="line">                System.out.println(i++);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line"></div><div class="line"></div><div class="line">            // 判断该阻塞线程是否还在</div><div class="line">            System.out.println(Thread.currentThread().isAlive());</div><div class="line"></div><div class="line">            // 判断该线程的中断标志位状态</div><div class="line">            System.out.println(Thread.currentThread().isInterrupted());</div><div class="line"></div><div class="line">            System.out.println(&quot;In Runnable&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d8e175c87cfbb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>接下来我们分析它的执行流程是怎么样的：<br><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d8e1786e316a1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>其实中心思想也就是我们新开的线程任在sleep的时候main线程中调用了t.interrupt方法让新线程中断。但是我们前面说过如下异常：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d8e16e562fe4f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>我们新线程正在调用sleep或者wait方法的时候会短暂的让该线程处于阻塞状态，阻塞状态下让该线程中断则是不合理的。那么就会设置其中断位为false并且跑出异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void interrupt() &#123;</div><div class="line">    if (this != Thread.currentThread())</div><div class="line">        checkAccess();</div><div class="line"></div><div class="line">    synchronized (blockerLock) &#123;</div><div class="line">        Interruptible b = blocker;</div><div class="line">        if (b != null) &#123;</div><div class="line">            interrupt0();           // Just to set the interrupt flag</div><div class="line">            b.interrupt(this);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    interrupt0();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次结合源码的处理逻辑来思考。</p>
<h3 id="interrupt-方法参考资料"><a href="#interrupt-方法参考资料" class="headerlink" title="interrupt 方法参考资料"></a>interrupt 方法参考资料</h3><ul>
<li>www.cnblogs.com/w-wfy/p/641…</li>
<li>www.cnblogs.com/carmanlonel…</li>
<li>www.zhihu.com/question/41…</li>
<li>www.zhihu.com/question/41…</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Thread-类-常见Api剖析&quot;&gt;&lt;a href=&quot;#Thread-类-常见Api剖析&quot; class=&quot;headerlink&quot; title=&quot;Thread 类 常见Api剖析&quot;&gt;&lt;/a&gt;Thread 类 常见Api剖析&lt;/h1&gt;&lt;h2 id=&quot;Thread类构造函数&quot;&gt;&lt;a href=&quot;#Thread类构造函数&quot; class=&quot;headerlink&quot; title=&quot;Thread类构造函数&quot;&gt;&lt;/a&gt;Thread类构造函数&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;public Thread() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    init(null, null, &amp;quot;Thread-&amp;quot; + nextThreadNum(), 0);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public Thread(Runnable target) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    init(null, target, &amp;quot;Thread-&amp;quot; + nextThreadNum(), 0);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public Thread(Runnable target, String name) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    init(null, target, name, 0);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public Thread(String name) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    init(null, null, name, 0);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="并发" scheme="http://www.jiyongguang.xin/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>thymeleaf渲染视图失败</title>
    <link href="http://www.jiyongguang.xin/templateEngine-thymeleaf.html"/>
    <id>http://www.jiyongguang.xin/templateEngine-thymeleaf.html</id>
    <published>2018-06-08T12:58:52.000Z</published>
    <updated>2018-06-08T13:03:09.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在最近做课设的时候，由于前台视图需要用到模板引擎来进行渲染，所以选用了thymeleaf这个模板引擎。但是在解析视图的时候却报了如下错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">org.thymeleaf.exceptions.TemplateProcessingException: Could not parse as expression: &quot;</div><div class="line">&#123;checkbox: true, fixed: true&#125;</div><div class="line">, &#123;field: &apos;originalFileName&apos;, title: &apos;文件名&apos;, width: 400, sort: true&#125;</div><div class="line">, &#123;field: &apos;fileType&apos;, title: &apos;文件类型&apos;, width: 100&#125;</div><div class="line">, &#123;field: &apos;fileSize&apos;, title: &apos;文件大小&apos;, width: 110, sort: true&#125;</div><div class="line">, &#123;field: &apos;createTime&apos;, title: &apos;上传时间&apos;, width: 170, sort: true&#125;</div><div class="line">, &#123;field: &apos;dpStatus&apos;, title: &apos;数据处理状态&apos;, width: 122, templet: &apos;#statusTpl&apos;, sort: true&#125;</div><div class="line">, &#123;field: &apos;updateTime&apos;, title: &apos;数据处理完成时间&apos;, width: 170, templet: &apos;#updateTimeTpl&apos;, sort: true&#125;</div><div class="line">, &#123;fixed: &apos;right&apos;, title: &apos;操作&apos;, align: &apos;center&apos;, width: 300, toolbar: &apos;#operating&apos;&#125;</div><div class="line">&quot; (template: &quot;textManagement&quot; - line 125, col 22)</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>即意为无法解析。这是因为<code>[[…]]</code>之间的表达式在thymeleaf被认为是内联表达式,所以渲染错误。</p>
<p>我们需要把其中所有的<code>[[ ]]</code>都改成如下这种写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line"></div><div class="line">    [</div><div class="line"></div><div class="line">    ]</div><div class="line"></div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>但由于我所用的视图文件是框架自动生成的，每个有2万+的代码，所以出现这种异常的地方也是数不胜数。后来我果断采取了另一种解决方式，换了另一种模板引擎。采用了Freemaker</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>解决方式也很简单，只需要<code>pom</code>文件把thymeleaf的依赖改成<code>freemaker</code>的依赖即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!--&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;--&gt;</div><div class="line"></div><div class="line">&lt;!-- 由于 thymeleaf 语法中[[…]]是它的内联表达式,不支持 echarts 生成的模板中的[[]]排版，所以会渲染错误，所以弃用 --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/rjkkaikai/article/details/80452128" target="_blank" rel="external"><br>thymeleaf+layui渲染错误</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在最近做课设的时候，由于前台视图需要用到模板引擎来进行渲染，所以选用了thymeleaf这个模板引擎。但是在解析视图的时候却报了如下错误:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;org.thymeleaf.exceptions.TemplateProcessingException: Could not parse as expression: &amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;checkbox: true, fixed: true&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;field: &amp;apos;originalFileName&amp;apos;, title: &amp;apos;文件名&amp;apos;, width: 400, sort: true&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;field: &amp;apos;fileType&amp;apos;, title: &amp;apos;文件类型&amp;apos;, width: 100&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;field: &amp;apos;fileSize&amp;apos;, title: &amp;apos;文件大小&amp;apos;, width: 110, sort: true&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;field: &amp;apos;createTime&amp;apos;, title: &amp;apos;上传时间&amp;apos;, width: 170, sort: true&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;field: &amp;apos;dpStatus&amp;apos;, title: &amp;apos;数据处理状态&amp;apos;, width: 122, templet: &amp;apos;#statusTpl&amp;apos;, sort: true&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;field: &amp;apos;updateTime&amp;apos;, title: &amp;apos;数据处理完成时间&amp;apos;, width: 170, templet: &amp;apos;#updateTimeTpl&amp;apos;, sort: true&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;, &amp;#123;fixed: &amp;apos;right&amp;apos;, title: &amp;apos;操作&amp;apos;, align: &amp;apos;center&amp;apos;, width: 300, toolbar: &amp;apos;#operating&amp;apos;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot; (template: &amp;quot;textManagement&amp;quot; - line 125, col 22)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.jiyongguang.xin/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="模板引擎" scheme="http://www.jiyongguang.xin/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 对resources-templates目录下的View视图文件访问404问题</title>
    <link href="http://www.jiyongguang.xin/springboot-thymeleaf-404.html"/>
    <id>http://www.jiyongguang.xin/springboot-thymeleaf-404.html</id>
    <published>2018-06-08T12:57:28.000Z</published>
    <updated>2018-06-08T13:03:09.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在做课设的时候Controller层原本要映射<code>resources</code>目录下的<code>templates</code>目录下html页面。但是不知道什么原因总是出现404的情况。无论访问任何<code>templates</code>下的视图都会出现这种情况。即静态资源无法映射，这让自己有点儿不解，对于SpringBoot而言，<code>resources</code>目录不是它默认的视图资源映射路径吗。应该是不走<code>DispatcherServlet</code>进行分发的啊，它是Vip通道啊，可为什么会出现这种情况呢？</p>
<p><img src="https://images2018.cnblogs.com/blog/1319881/201805/1319881-20180529005409093-778602346.png" alt=""></p>
<a id="more"></a>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>思考之后只有一种猜想有可能，<strong>默认映射肯定出问题了</strong>。说明SpringBoot的默认的静态资源的访问规则没有起作用。但是为什么会出现这种问题呢，网上查阅后说是启用了<code>@EnableWebMvc</code>这个注解。这个注解意思是你想完全地进行web配置，那么Spring就会忽略默认的配置信息，去寻找相应的你的设置文件。如果你没有设置，就会出现上面这个问题了。</p>
<p>可是我非常明确的是我并没有启用它，但不知道为什么还是莫名其妙的出现了这个问题。所以我就尝试着根据这个问题来进行解决它。只要配置我们默认的资源映射路径即可</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>由于原本的<code>WebMvcConfigurerAdapter</code>在Spring最新版本已经过时了。所以我们应该选用<code>WebMvcConfigurationSupport</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span></span>&#123;</div><div class="line">        registry.addResourceHandler(<span class="string">"/**"</span>)</div><div class="line">                .addResourceLocations(<span class="string">"classpath:/templates/"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就这样问题就解决了。</p>
<p>参考：<a href="https://www.cnblogs.com/wangnig/p/9103144.html" target="_blank" rel="external">SpringBoot添加对静态文件css/html/jpg等的直接访问的支持</a></p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>在找解决办法的时候在SegmentFault上看到的别人遇到的问题，虽然和我遇到的问题情况一样，但是问题却是不同的。但这个问题看上去也很难处理，所以这里简单记录一下，以防以后自己用到。</p>
<p>它也是正常配置，没有启用<code>@EnableWebMvc</code>这个注解。所以也没有自己配置<code>@Configuration</code>中静态资源的路径。而是jar包的问题，他清除了maven 的m2目录，然后打开项目让maven重新下载之后就解决了。</p>
<p>参考：<a href="https://segmentfault.com/q/1010000010541125" target="_blank" rel="external">Spring Boot项目访问template模板文件页面返回404</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在做课设的时候Controller层原本要映射&lt;code&gt;resources&lt;/code&gt;目录下的&lt;code&gt;templates&lt;/code&gt;目录下html页面。但是不知道什么原因总是出现404的情况。无论访问任何&lt;code&gt;templates&lt;/code&gt;下的视图都会出现这种情况。即静态资源无法映射，这让自己有点儿不解，对于SpringBoot而言，&lt;code&gt;resources&lt;/code&gt;目录不是它默认的视图资源映射路径吗。应该是不走&lt;code&gt;DispatcherServlet&lt;/code&gt;进行分发的啊，它是Vip通道啊，可为什么会出现这种情况呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1319881/201805/1319881-20180529005409093-778602346.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.jiyongguang.xin/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://www.jiyongguang.xin/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>net--error</title>
    <link href="http://www.jiyongguang.xin/net-error.html"/>
    <id>http://www.jiyongguang.xin/net-error.html</id>
    <published>2018-06-08T12:55:54.000Z</published>
    <updated>2018-06-08T13:03:09.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在做课设的时候自己找了几个不错的html想做视图，但是奈何映射的时候一直没有效果。后来网上查阅资料说是视图找不到依赖的资源文件所导致的。如下</p>
<p><img src="https://img-blog.csdn.net/20180410114028318?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUwODkz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<a id="more"></a>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>后来才发现自己确实资源文件的请求路径错了。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-1/29704824.jpg" alt=""></p>
<p>比如<code>navigat.ftl</code>视图需要引入static目录下的<code>style.css</code>文件。</p>
<p><strong>我之前的写法</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;../static/css/style.css&quot;/&gt;</div></pre></td></tr></table></figure>
<p>但是却忘记了对于SpringBoot而言static目录也是它默认的静态资源映射路径。所以相当于<code>templates</code>和<code>static</code>目录下的资源文件是在同一个文件目录下的。所以其实我们就不需要再在目录间切来切去的了 </p>
<p><strong>改正后的写法</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;/&gt;</div></pre></td></tr></table></figure>
<p>就这样问题解决啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在做课设的时候自己找了几个不错的html想做视图，但是奈何映射的时候一直没有效果。后来网上查阅资料说是视图找不到依赖的资源文件所导致的。如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180410114028318?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUwODkz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前台" scheme="http://www.jiyongguang.xin/categories/%E5%89%8D%E5%8F%B0/"/>
    
    
      <category term="前台" scheme="http://www.jiyongguang.xin/tags/%E5%89%8D%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java中的static关键字解析</title>
    <link href="http://www.jiyongguang.xin/java-keyword-static.html"/>
    <id>http://www.jiyongguang.xin/java-keyword-static.html</id>
    <published>2018-06-08T12:51:52.000Z</published>
    <updated>2018-06-08T13:03:09.352Z</updated>
    
    <content type="html"><![CDATA[<p>static关键字是很多朋友在编写代码和阅读代码时碰到的比较难以理解的一个关键字，也是各大公司的面试官喜欢在面试时问到的知识点之一。下面就先讲述一下static关键字的用法和平常容易误解的地方，最后列举了一些面试笔试中常见的关于static的考题。</p>
<p>转载自：海子：<a href="http://www.cnblogs.com/dolphin0520/p/3799052.html" target="_blank" rel="external">Java中的static关键字解析</a></p>
<h1 id="一、static关键字的用途"><a href="#一、static关键字的用途" class="headerlink" title="一、static关键字的用途"></a>一、static关键字的用途</h1><p>　　在《Java编程思想》P86页有这样一段话：</p>
<p>　　“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”</p>
<a id="more"></a>
<p>　　这段话虽然只是说明了static方法的特殊之处，但是可以看出static关键字的基本作用，简而言之，一句话来描述就是：</p>
<p>　　方便在没有创建对象的情况下来进行调用（方法/变量）。</p>
<p>　　很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。</p>
<p>　　static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。</p>
<h2 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h2><p>　　static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。
　　</p>
<p><strong>但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。</strong> 举个简单的例子：</p>
<p>在上面的代码中，由于print2方法是独立于对象存在的，可以直接用过类名调用。假如说可以在静态方法中访问非静态方法/变量的话，那么如果在main方法中有下面一条语句：</p>
<p>　　MyObject.print2();</p>
<p>　　此时对象都没有，str2根本就不存在，所以就会产生矛盾了。同样对于方法也是一样，由于你无法预知在print1方法中是否访问了非静态成员变量，所以也禁止在静态成员方法中访问非静态成员方法。</p>
<p>　　而对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的。</p>
<p>　　因此，如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。我们最常见的static方法就是main方法，至于为什么main方法必须是static的，现在就很清楚了。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。</p>
<p>　　另外记住，关于构造器是否是static方法可参考：<a href="http://blog.csdn.net/qq_17864929/article/details/48006835" target="_blank" rel="external">http://blog.csdn.net/qq_17864929/article/details/48006835</a></p>
<h2 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h2><p>　　static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p>
<p>　　static成员变量的初始化顺序按照定义的顺序进行初始化。</p>
<h2 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h2><p><strong>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。</strong> static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p>
<p>　　为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。下面看个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Person&#123;</div><div class="line">    private Date birthDate;</div><div class="line">     </div><div class="line">    public Person(Date birthDate) &#123;</div><div class="line">        this.birthDate = birthDate;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    boolean isBornBoomer() &#123;</div><div class="line">        Date startDate = Date.valueOf(&quot;1946&quot;);</div><div class="line">        Date endDate = Date.valueOf(&quot;1964&quot;);</div><div class="line">        return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　isBornBoomer是用来这个人是否是1946-1964年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Person&#123;</div><div class="line">    private Date birthDate;</div><div class="line">    private static Date startDate,endDate;</div><div class="line">    static&#123;</div><div class="line">        startDate = Date.valueOf(&quot;1946&quot;);</div><div class="line">        endDate = Date.valueOf(&quot;1964&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public Person(Date birthDate) &#123;</div><div class="line">        this.birthDate = birthDate;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    boolean isBornBoomer() &#123;</div><div class="line">        return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p>
<h1 id="二、static关键字的误区"><a href="#二、static关键字的误区" class="headerlink" title="二、static关键字的误区"></a>二、static关键字的误区</h1><h2 id="static关键字会改变类中成员的访问权限吗？"><a href="#static关键字会改变类中成员的访问权限吗？" class="headerlink" title="static关键字会改变类中成员的访问权限吗？"></a>static关键字会改变类中成员的访问权限吗？</h2><p>　　有些初学的朋友会将java中的static与C/C++中的static关键字的功能混淆了。在这里只需要记住一点：与C/C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。看下面的例子就明白了：</p>
<p>　　提示错误”Person.age 不可视”，这说明static关键字并不会改变变量和方法的访问权限。</p>
<h2 id="能通过this访问静态成员变量吗？"><a href="#能通过this访问静态成员变量吗？" class="headerlink" title="能通过this访问静态成员变量吗？"></a>能通过this访问静态成员变量吗？</h2><p>　　虽然对于静态方法来说没有this，那么在非静态方法中能够通过this访问静态成员变量吗？先看下面的一个例子，这段代码输出的结果是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;　　</div><div class="line">    static int value = 33;</div><div class="line"> </div><div class="line">    public static void main(String[] args) throws Exception&#123;</div><div class="line">        new Main().printValue();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    private void printValue()&#123;</div><div class="line">        int value = 3;</div><div class="line">        System.out.println(this.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　这里面主要考察队this和static的理解。this代表什么？this代表当前对象，那么通过new Main()来调用printValue的话，当前对象就是通过new Main()生成的对象。而static变量是被对象所享有的，因此在printValue中的this.value的值毫无疑问是33。在printValue方法内部的value是局部变量，根本不可能与this关联，所以输出结果是33。在这里永远要记住一点：<strong>静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。</strong></p>
<h2 id="static能作用于局部变量么？"><a href="#static能作用于局部变量么？" class="headerlink" title="static能作用于局部变量么？"></a>static能作用于局部变量么？</h2><p>　　在C/C++中static是可以作用域局部变量的，但是在Java中切记：<strong>static是不允许用来修饰局部变量。</strong>，这是Java语法的规定。</p>
<p>　　具体原因可以参考这篇博文的讨论：<a href="http://www.debugease.com/j2se/178932.html" target="_blank" rel="external">Java static关键字为什么不能应用于局部变量？</a></p>
<h1 id="三、常见的笔试面试题"><a href="#三、常见的笔试面试题" class="headerlink" title="三、常见的笔试面试题"></a>三、常见的笔试面试题</h1><p>　　下面列举一些面试笔试中经常遇到的关于static关键字的题目，仅供参考，如有补充欢迎下方留言。</p>
<p><strong>1.下面这段代码的输出结果是什么？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Test extends Base&#123;</div><div class="line"> </div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;test static&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public Test()&#123;</div><div class="line">        System.out.println(&quot;test constructor&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new Test();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Base&#123;</div><div class="line">     </div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;base static&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public Base()&#123;</div><div class="line">        System.out.println(&quot;base constructor&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　至于为什么是这个结果，我们先不讨论，先来想一下这段代码具体的执行过程，在执行开始，先要寻找到main方法，因为main方法是程序的入口，<strong>但是在执行main方法之前，必须先加载Test类(加载Test类是执行Main方法的前驱事件，必须先把其所在类进行加载 )，</strong> 而在加载Test类的时候发现Test类继承自Base类，因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现Test类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行new Test()的时候会先调用父类的构造器，然后再调用自身的构造器。因此，便出现了上面的输出结果。</p>
<p><strong>2.这段代码的输出结果是什么？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    Person person = new Person(&quot;Test&quot;);</div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;test static&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public Test() &#123;</div><div class="line">        System.out.println(&quot;test constructor&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new MyClass();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Person&#123;</div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;person static&quot;);</div><div class="line">    &#125;</div><div class="line">    public Person(String str) &#123;</div><div class="line">        System.out.println(&quot;person &quot;+str);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">class MyClass extends Test &#123;</div><div class="line">    Person person = new Person(&quot;MyClass&quot;);</div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;myclass static&quot;);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public MyClass() &#123;</div><div class="line">        System.out.println(&quot;myclass constructor&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　类似地，我们还是来想一下这段代码的具体执行过程。首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。<strong>而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，</strong> 而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。</p>
<p><strong>3.这段代码的输出结果是什么？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">     </div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;test static 1&quot;);</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;test static 2&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　虽然在main方法中没有任何语句，但是还是会输出，原因上面已经讲述过了。另外，static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的。</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>　　<a href="http://lavasoft.blog.51cto.com/62575/18771/" target="_blank" rel="external">http://lavasoft.blog.51cto.com/62575/18771/</a></p>
<p>　　<a href="http://www.51cto.com/specbook/24/35011.htm" target="_blank" rel="external">http://www.51cto.com/specbook/24/35011.htm</a></p>
<p>　　<a href="http://blog.csdn.net/zhu_apollo/article/details/1888219" target="_blank" rel="external">http://blog.csdn.net/zhu_apollo/article/details/1888219</a></p>
<p>　　<a href="http://blog.sina.com.cn/s/blog_70b845780100n9zz.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_70b845780100n9zz.html</a></p>
<p>　　<a href="http://hi.baidu.com/yuiezt/item/b71ff5fbfe9c385cc8f3370d" target="_blank" rel="external">http://hi.baidu.com/yuiezt/item/b71ff5fbfe9c385cc8f3370d</a></p>
<p>　　<a href="http://bbs.csdn.net/topics/330251070" target="_blank" rel="external">http://bbs.csdn.net/topics/330251070</a></p>
<p>　　<a href="http://yezixingchen.iteye.com/blog/1597186" target="_blank" rel="external">http://yezixingchen.iteye.com/blog/1597186</a></p>
<p>　　《Java编程思想》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;static关键字是很多朋友在编写代码和阅读代码时碰到的比较难以理解的一个关键字，也是各大公司的面试官喜欢在面试时问到的知识点之一。下面就先讲述一下static关键字的用法和平常容易误解的地方，最后列举了一些面试笔试中常见的关于static的考题。&lt;/p&gt;
&lt;p&gt;转载自：海子：&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3799052.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java中的static关键字解析&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、static关键字的用途&quot;&gt;&lt;a href=&quot;#一、static关键字的用途&quot; class=&quot;headerlink&quot; title=&quot;一、static关键字的用途&quot;&gt;&lt;/a&gt;一、static关键字的用途&lt;/h1&gt;&lt;p&gt;　　在《Java编程思想》P86页有这样一段话：&lt;/p&gt;
&lt;p&gt;　　“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多线程简单了解一下</title>
    <link href="http://www.jiyongguang.xin/multi-threading.html"/>
    <id>http://www.jiyongguang.xin/multi-threading.html</id>
    <published>2018-06-08T12:25:07.000Z</published>
    <updated>2018-06-08T12:26:43.501Z</updated>
    
    <content type="html"><![CDATA[<p>参考自：<br>Fysddsw_lc：<a href="https://juejin.im/post/5acf05515188255c6163625d" target="_blank" rel="external">java 多线程</a></p>
<h1 id="进程，线程"><a href="#进程，线程" class="headerlink" title="进程，线程"></a>进程，线程</h1><p><strong>进程：</strong></p>
<p>进程是程序或者任务的执行过程，<strong>进程是系统进行资源分配和调度的独立单位。</strong> 每一个进程都有它自己的内存空间和系统资源。他是内存和线程的载体。</p>
<ul>
<li>每个进程在执行的时候都会被分配内存</li>
<li>其中的线程就比如QQ在聊天的线程和接受文件的线程等，处理同一个进程(程序)不同任务的执行。</li>
</ul>
<p><strong>进程已经是可以进行资源分配和调度了，为什么还要线程呢？</strong></p>
<a id="more"></a>
<p>多任务处理被所有的现代操作系统所支持。然而，多任务处理有两种截然不同的类型：基于进程的和基于线程的。</p>
<p>基于进程的多任务处理是更熟悉的形式。进程（process）本质上是一个执行的程序。因此基于进程的多任务处理的特点是允许你的计算机同时运行两个或更多的程序。</p>
<p>比如，基于进程的多任务处理是你在编辑文本的时候可以同时运行Java编译器。</p>
<p>为使程序能并发执行，系统必须进行以下的一系列操作：</p>
<ol>
<li>创建进程，系统在创建一个进程时，必须为它分配其所必需的、除处理机以外的所有资源，如内存空间、I/O设备，以及建立相应的PCB；</li>
<li>撤消进程，系统在撤消进程时，又必须先对其所占有的资源执行回收操作，然后再撤消PCB；</li>
<li>进程切换，对进程进行上下文切换时，需要保留当前进程的CPU环境，设置新选中进程的CPU环境，因而须花费不少的处理机时间。</li>
</ol>
<p>如图所示：<br><img src="https://upload-images.jianshu.io/upload_images/5291509-7efab3cb7f00d193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>可以看到进程实现多处理机环境下的进程调度，分派，切换时，<strong>都需要花费较大的时间和空间开销</strong></p>
<p>而在基于线程（thread-based）的多任务处理环境中，线程是最小的执行单位。这意味着一个程序可以同时执行两个或者多个任务的功能。</p>
<p>比如，一个文本编辑器可以在打印的同时格式化文本。</p>
<p>而线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以线程的切换负担比进程切换的负担要小。引入线程主要是<strong>为了提高系统的执行效率，减少处理机的空转时间和调度切换的时间，以及便于系统管理。</strong> 使OS具有更好的并发性</p>
<p>简单来说：进程实现多处理非常耗费CPU的资源，而我们引入线程是作为调度和分派的基本单位（取代进程的部分基本功能【调度】）。</p>
<p><strong>线程：</strong></p>
<p>线程是系统中最小的执行单元，进程的一个实体，是CPU调度和分派的基本单位。同样的进程中可以有多个线程，而线程共享进程的资源。<strong>多线程编程的目的，就是“最大限度地利用cpu资源”</strong></p>
<p>线程交互方式：</p>
<ul>
<li>互斥：通常表现在多个线程竞争同一资源，所以也就面临着线程等待的问题</li>
<li>同步：同步就是协同步调，按预定的先后次序进行运行。如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行；B依言执行，再将结果给A；A再继续操作。</li>
</ul>
<h2 id="线程-vs-进程"><a href="#线程-vs-进程" class="headerlink" title="线程 vs 进程"></a>线程 vs 进程</h2><ul>
<li>进程作为资源<strong>分配</strong>的基本单位</li>
<li>线程作为资源<strong>调度</strong>的基本单位，是程序的执行单元，执行路径(单线程：一条执行路径，多线程：多条执行路径)。是程序使用CPU的最基本单位。</li>
</ul>
<h2 id="并发，并行"><a href="#并发，并行" class="headerlink" title="并发，并行"></a>并发，并行</h2><p><strong>并行：</strong></p>
<ul>
<li>并行性是指同一时刻内发生两个或多个事件。</li>
<li>并行是在不同实体上的多个事件</li>
</ul>
<p><strong>并发：</strong></p>
<ul>
<li>并发性是指同一时间间隔内发生两个或多个事件。</li>
<li>并发是在同一实体上的多个事件</li>
</ul>
<p>由此可见：并行是针对进程的，并发是针对线程的。</p>
<h1 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h1><p>在Java中通过run方法为线程指明要完成的任务，有两种技术来为线程提供run方法：</p>
<ol>
<li>继承Thread类并重写它的run方法。之后创建这个子类的对象并调用start()方法。</li>
<li>通过定义实现Runnable接口的实现类进而实现run方法。这个类的对象在创建Thread对象的时候会被作为参数而传入，然后调用Thread对象的start()方法。</li>
</ol>
<p>两种方法都需要执行线程Thread的start()方法为线程分配必须的系统资源，调度线程运行并执行线程的run（）方法。</p>
<p><strong>需要注意的是：</strong></p>
<ul>
<li>start（）方法是启动线程的唯一的方法。start()方法首先为线程的执行准备好系统资源，然后再去调用它的run（）方法。一个线程只能启动一次，再次启动就不合法了。</li>
<li>run（）方法中放入了线程的逻辑，即我们要这个线程去做事情。</li>
</ul>
<p>通常我一般是使用第二种方法来实现的，第一种方式会在单继承的规则上制约我们的扩展。即当一个线程已经继承了另一个类时，只能用第二种方法来构造，即实现Runnable接口。</p>
<h2 id="Thread-实现"><a href="#Thread-实现" class="headerlink" title="Thread 实现"></a>Thread 实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">    static class SonOfThread extends Thread &#123;</div><div class="line"></div><div class="line">        private String threadName;</div><div class="line"></div><div class="line">        public SonOfThread(String threadName) &#123;</div><div class="line">            this.threadName = threadName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">                System.out.println(threadName + &quot; : &quot; + i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        SonOfThread sonOfThread = new SonOfThread(&quot;sonOfThread&quot;);</div><div class="line"></div><div class="line">        sonOfThread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当使用第一种方式（继承Thread的方式）来生成线程对象时，我们需要重写run()方法，因为Thread类的run()方法默认是调用构造Thread对象时传入的Runnable接口的实现类对象的run方法。但我们这里并没有打算通过这种方式构建Thread对象，所以这里默认的run函数什么都不会做，我们应该重写它。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* What will be run. */</span></div><div class="line"><span class="keyword">private</span> Runnable target;</div><div class="line">····</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">        target.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Runnable-实现"><a href="#Runnable-实现" class="headerlink" title="Runnable 实现"></a>Runnable 实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">    static class MyThread implements Runnable &#123;</div><div class="line">    </div><div class="line">        private String threadName;</div><div class="line"></div><div class="line">        public MyThread(String threadName) &#123;</div><div class="line">            this.threadName = threadName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line"></div><div class="line">            for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">                System.out.println(threadName + &quot; : &quot; + i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        MyThread myThread = new MyThread(&quot;myThread&quot;);</div><div class="line">        Thread thread = new Thread(myThread);</div><div class="line"></div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实还是很好理解的，我们最终都要执行线程的run方法，而start方法是run方法执行的唯一入口，我们只能通过Thread对象来显示的调用start方法来为线程的执行准备好系统资源，并由start方法来后续调用run方法。</p>
<h2 id="Runnable源码"><a href="#Runnable源码" class="headerlink" title="Runnable源码"></a>Runnable源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.lang;</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>需要注意的是：</strong></p>
<p>当生成一个线程对象时，如果没有为其指定名字，那么线程对象的名字将使用如下形式：<code>Thread-number</code>，该number是自动增加的数字，并被所有的Thread对象所共享，因为它是一个static的成员变量。</p>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程　"></a>停止线程　</h2><p>现在线程的消亡不能通过调用stop()命令，应该让run()方法自然结束。stop()方法是不安全的，已经废弃。</p>
<p>　　停止线程推荐的方式：设定一个标志变量，在run()方法中是一个循环，由该标志变量控制循环是继续执行还是跳出；循环跳出，则线程结束。
　　</p>
<h1 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h1><p><strong>值得注意的是：</strong> 多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率，程序的执行其实都是在抢CPU的资源，CPU的执行权。多个进程是在抢这个资源，而其中的某一个进程如果执行路径比较多，就会有更高的几率抢到CPU的执行权</p>
<p>多线程编程很常见的情况下是希望多个线程共享资源， 通过多个线程同时消费资源来提高效率，但是新手一不小心很容易陷入一个编码误区。</p>
<p>举个例子：</p>
<p>下面的代码，希望通过 3 个线程同时执行 i– ，使得输出i的值为 0，但3次输出的结果都为2。这是因为在main方法中创建的三个线程都独自持有一个i变量，该变量式线程独有的，它并非static变量并不是线程共有的。我们的目的应该是3个线程共享一个i变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class ThreadTest1 extends Thread &#123;</div><div class="line">    private int i = 3;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        i--;</div><div class="line">        System.out.println(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ThreadTest &#123;</div><div class="line">    public static void main(String[] strings) &#123;</div><div class="line">        Thread thread1 = new ThreadTest1();</div><div class="line">        thread1.start();</div><div class="line">        Thread thread2 = new ThreadTest1();</div><div class="line">        thread2.start();</div><div class="line">        Thread thread3 = new ThreadTest1();</div><div class="line">        thread3.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出 // 2 2 2</div></pre></td></tr></table></figure></p>
<p>在这种非共有变量的情况下我们应该这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">应该这么写</div><div class="line"></div><div class="line">public class ThreadTest &#123;</div><div class="line">    public static void main(String[] strings) &#123;</div><div class="line">        Thread thread1 = new ThreadTest1();</div><div class="line">        thread1.start();</div><div class="line">        thread1.start();</div><div class="line">        thread1.start();    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即让该线程的run方法执行3次。每次对i进行<code>--</code>操作。</p>
<h2 id="多个线程执行同样的代码"><a href="#多个线程执行同样的代码" class="headerlink" title="多个线程执行同样的代码"></a>多个线程执行同样的代码</h2><p>在这种情况下，可以使用同一个Runnable对象（看上一篇博客，这是一种创建线程的方式）将需要共享的数据，植入这个Runnable对象里面。例如买票系统，余票是需要共享的，不过在这样做的时候，我想还应该加上synchronized关键字修饰！</p>
<h2 id="多个线程执行的代码不一样"><a href="#多个线程执行的代码不一样" class="headerlink" title="多个线程执行的代码不一样"></a>多个线程执行的代码不一样</h2><p>在这种情况下，就两种思路可以实现（这里参考张孝祥老师的观点）</p>
<p>其一：将共享数据封装再另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。每个线程对共享数据的操作方法也分配到那个对象身上去完成，这样容易实现对改数据进行的各个操作的互斥和通信。</p>
<p>其二：将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方法也分配给外部类，以便实现对共享数据进行的各个操作的互斥和通信，作为内部类的各个Runnable对象调用外部类的这些方法。</p>
<p>组合：将共享数据封装再另外一个对象中，每个线程对共享数据的操作方法也分配到那个对象身上去完成，对象作为这个外部类中的成员变量或方法中的局部变量，每个线程的Runnable对象作为外部类中的成员内部类或局部内部类。（示例代码所使用的方法），总之，要同步互斥的几段代码最好是分别放在几个独立的方法中，这些方法再放在同一个类中，这样比较好容易实现它们之间的同步互斥通信</p>
<h2 id="简单粗暴的方式"><a href="#简单粗暴的方式" class="headerlink" title="简单粗暴的方式"></a>简单粗暴的方式</h2><p>在程序中，定义一个static变量</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>线程的生命周期其实就是一个线程从创建到消亡的过程。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-8/94955655.jpg" alt=""></p>
<p>线程可以有6种状态：</p>
<p>New（新创建），Runnable（可运行），Blocked（被阻塞），Waiting（等待），Timed waiting（计时等待） Terminated(被终止)。</p>
<p>要想确定一个线程的当前状态，可调用getState()方法。</p>
<h2 id="1-创建状态"><a href="#1-创建状态" class="headerlink" title="1.创建状态"></a>1.创建状态</h2><p>当用new操作符创建一个新的线程对象时，如 new Thread(t)，该线程还没有开始运行,该线程处于创建状态，程序还没有开始运行线程中代码。<strong>处于创建状态的线程只是一个空的线程对象，系统不为它分配资源。</strong></p>
<h2 id="2-可运行状态"><a href="#2-可运行状态" class="headerlink" title="2.可运行状态"></a>2.可运行状态</h2><p>一旦调用了start()方法，线程处于<strong>runnable</strong>状态。一个可运行的线程可能正在运行页可能没有运行，<strong>这取决于操作系统给线程提供运行的时间。</strong></p>
<p> 一旦一个线程开始运行，它不必始终保持运行。事实上，运行的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。</p>
<p> 记住，在任何给定时刻，一个可运行的线程可能正在运行页可能没有运行，这就是为什么说成为runnable状态后才能为可运行而不是运行。</p>
<h2 id="3-不可运行状态"><a href="#3-不可运行状态" class="headerlink" title="3.不可运行状态"></a>3.不可运行状态</h2><p>不可运行状态包括被<strong>阻塞或等待</strong>状态，此时线程暂时不活动，不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。</p>
<p>当一个线程试图获取一个内部的对象锁，而该锁被其他线程所持有，则进入阻塞状态。当所有其他线程释放完琐，线程调度器允许该线程持有它的时候，该线程将变成非阻塞状态。</p>
<p>当线程等待另一个线程通知 调度器调度一个条件时，它自己进入等待转态。在thread对象调用wait方法和join方法时，就会出现这种情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final void wait()&#123;&#125;</div><div class="line"></div><div class="line">在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。</div><div class="line"></div><div class="line">public final void join(long millis)&#123;&#125;</div><div class="line"></div><div class="line">等待该线程终止。</div></pre></td></tr></table></figure>
<p>有些方法有一个超时参数，例如，sleep，wait，join。调用他们导致线程进入计时等待状态。这一状态将保持到超时期满或者受到适当通知。</p>
<p><strong>通俗一点：</strong></p>
<p><strong>当发生下列事件时，处于运行状态的线程会转入到不可运行状态：</strong></p>
<ul>
<li>调用了sleep()方法；</li>
<li>线程调用wait()方法等待特定条件的满足；</li>
<li>线程输入/输出阻塞。</li>
</ul>
<p><strong>返回可运行状态：</strong></p>
<ul>
<li><p>处于睡眠状态的线程在指定的时间过去后；</p>
</li>
<li><p>如果线程在等待某一条件，另一个对象必须通过notify()或notifyAll()方法通知等待线程条件的改变；</p>
</li>
<li><p>如果线程是因为输入输出阻塞，等待输入输出完成。</p>
</li>
</ul>
<h2 id="4-被终止状态"><a href="#4-被终止状态" class="headerlink" title="4.被终止状态"></a>4.被终止状态</h2><p>线程因如下两个原因之一而被终止：</p>
<ul>
<li>因为run方法正常退出而自然消亡</li>
<li>因为一个没有捕获的异常终止了run方法而消亡</li>
</ul>
<h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>Java线程有优先级的设定，高优先级的线程比低优先级的线程有更高的几率得到执行。</p>
<ol>
<li>当前线程没有指定优先级时，所有线程都是普通优先级。</li>
<li>优先级从1到10的范围指定。10表示最高优先级，1表示最低优先级，5是普通优先级。</li>
<li>优先级最高的线程在执行时被给予优先。但是<strong>不能保证线程在启动时就进入运行状态。</strong></li>
<li>与在线程池中等待运行机会的线程相比，<strong>正在运行的线程可能总是拥有更高的优先级。</strong></li>
<li>由调度程序决定哪一个线程被执行。</li>
<li><code>t.setPriority()</code>用来设定线程的优先级。</li>
<li><strong>记住在线程开始方法被调用之前，线程的优先级应该被设定。</strong></li>
<li>你可以使用常量，如<code>MIN_PRIORITY,MAX_PRIORITY</code>，<code>NORM_PRIORITY</code>来设定优先级Java线程的优先级是一个整数，其取值范围是1(<code>Thread.MIN_PRIORITY</code>) —— 10(<code>Thread.MAX_PRIORITY</code>)。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static final int MIN_PRIORITY = 1;</div><div class="line">public static final int NORM_PRIORITY = 5;</div><div class="line">public static final int MAX_PRIORITY = 10;</div></pre></td></tr></table></figure>
<p>可以通过setPriority方法（final的，不能被子类重载）更改优先级。优先级不能超过1-10的取值范围，否则抛出IllegalArgumentException。<strong>另外如果该线程已经属于一个线程组（ThreadGroup），该线程的优先级不能超过该线程组的优先级。</strong></p>
<h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><p>通过前面的理论论述我们知道了Java实现多线程是通过Thread类来实现的。所以我们接下来了解一下Thread这个类</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-e1f448bb431cf3e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>可以根据图中标注处来了解Thread类的声明规范。但该图标注处并非我所翻译。所以其实该图是有对源码理解有误的地方的。</p>
<p>可以结合<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="external">jdk中文官方文档</a>来理解。</p>
<p><strong>总的来说：</strong></p>
<ol>
<li>Java 虚拟机允许应用程序并发地运行多个执行线程</li>
<li>每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。</li>
<li>每个线程都可能被标记为一个守护程序。</li>
<li>当某个线程中运行的代码创建一个新 Thread 对象时，该新线程的初始优先级被设定为创建线程的优先级，并且当且仅当创建线程是守护线程时，被创建的新线程才是守护程序。</li>
<li>当 Java 虚拟机启动时，通常都会有一个非守护线程（它通常调用一些指定类的main方法）Java虚拟机将继续执行线程，直到出现以下任一情况。<ul>
<li>调用了 Runtime 类的 exit 方法，并且安全管理器允许退出操作发生。</li>
<li>非守护线程的所有线程都已停止运行，无论是通过从对 run 方法的调用中返回，还是通过抛出一个传播到 run 方法之外的异常。</li>
</ul>
</li>
<li>创建新执行线程有两种方法。<ul>
<li>一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。接下来可以分配并启动该子类的实例。</li>
<li>另一种方法是声明实现 Runnable 接口的实现类。该类要实现Runnable接口的 run 方法。然后再声明一个该类的实例，并在创建 Thread 实例时作为其构造函数的参数来传入并调用其start函数来启动该线程。</li>
</ul>
</li>
<li>每个线程都有一个标识名，多个线程可以同名。如果线程创建时没有指定标识名，就会为其生成一个新名称。</li>
<li>除非函数特别表情，否则将一个为null的参数传递给构造函数或者其他函数都会抛出一个空指针异常。</li>
</ol>
<p>之前我们说过了创建多线程的两种方式，这里测试一下运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">    static class MyThread implements Runnable &#123;</div><div class="line">        private String threadName;</div><div class="line"></div><div class="line">        public MyThread(String threadName) &#123;</div><div class="line">            this.threadName = threadName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line"></div><div class="line">            for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">                System.out.println(threadName + &quot; : &quot; + i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class SonOfThread extends Thread &#123;</div><div class="line"></div><div class="line">        private String threadName;</div><div class="line"></div><div class="line">        public SonOfThread(String threadName) &#123;</div><div class="line">            this.threadName = threadName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">                System.out.println(threadName + &quot; : &quot; + i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        MyThread myThread = new MyThread(&quot;myThread&quot;);</div><div class="line">        Thread thread = new Thread(myThread);</div><div class="line"></div><div class="line">        SonOfThread sonOfThread = new SonOfThread(&quot;sonOfThread&quot;);</div><div class="line"></div><div class="line">        sonOfThread.start();</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-6-8/61675035.jpg" alt=""></p>
<p>最后都会正确输出各自线程的处理结果99。</p>
<h1 id="关于Thread需要注意的点"><a href="#关于Thread需要注意的点" class="headerlink" title="关于Thread需要注意的点"></a>关于Thread需要注意的点</h1><p><strong>run()和start()方法区别：</strong></p>
<ul>
<li>run():仅仅是封装被线程执行的代码，直接调用是普通方法，线程并没有启动，系统资源也就更不会被分配了。</li>
<li>start():首先启动了线程，然后再由jvm去调用该线程的run()方法。</li>
</ul>
<hr>
<p><strong>jvm虚拟机的启动是单线程的还是多线程的?</strong></p>
<p>是多线程的。不仅仅是启动main线程，还至少会启动垃圾回收线程的，不然谁帮你回收不用的内存~</p>
<hr>
<p><strong>两种方式实现多线程，我们使用哪一种？</strong></p>
<p>一般我们使用实现Runnable接口</p>
<ul>
<li>可以避免java中的单继承的限制</li>
<li>应该将并发运行任务和运行机制解耦，因此我们选择实现Runnable接口这种方式！</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考自：&lt;br&gt;Fysddsw_lc：&lt;a href=&quot;https://juejin.im/post/5acf05515188255c6163625d&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;java 多线程&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;进程，线程&quot;&gt;&lt;a href=&quot;#进程，线程&quot; class=&quot;headerlink&quot; title=&quot;进程，线程&quot;&gt;&lt;/a&gt;进程，线程&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;进程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程是程序或者任务的执行过程，&lt;strong&gt;进程是系统进行资源分配和调度的独立单位。&lt;/strong&gt; 每一个进程都有它自己的内存空间和系统资源。他是内存和线程的载体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个进程在执行的时候都会被分配内存&lt;/li&gt;
&lt;li&gt;其中的线程就比如QQ在聊天的线程和接受文件的线程等，处理同一个进程(程序)不同任务的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进程已经是可以进行资源分配和调度了，为什么还要线程呢？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="并发" scheme="http://www.jiyongguang.xin/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 如何有效地避免OOM：善于利用软引用和弱引用</title>
    <link href="http://www.jiyongguang.xin/reference.html"/>
    <id>http://www.jiyongguang.xin/reference.html</id>
    <published>2018-06-07T08:31:35.000Z</published>
    <updated>2018-06-07T08:32:37.278Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p>
<p>海子：<a href="http://www.cnblogs.com/dolphin0520/p/3784171.html" target="_blank" rel="external">Java 如何有效地避免OOM：善于利用软引用和弱引用</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想必很多朋友对OOM（OutOfMemory）这个错误不会陌生，而当遇到这种错误如何有效地解决这个问题呢？今天我们就来说一下如何利用软引用和弱引用来有效地解决程序中出现的OOM问题。</p>
<h1 id="了解-强引用、软引用、弱引用、虚引用的概念"><a href="#了解-强引用、软引用、弱引用、虚引用的概念" class="headerlink" title="了解 强引用、软引用、弱引用、虚引用的概念"></a>了解 强引用、软引用、弱引用、虚引用的概念</h1><p>在Java中，虽然不需要程序员手动去管理对象的生命周期，但是如果希望某些对象具备一定的生命周期的话（比如内存不足时JVM就会自动回收某些对象从而避免OutOfMemory的错误）就需要用到软引用和弱引用了。</p>
<a id="more"></a>
<p>　　从Java SE2开始，就提供了四种类型的引用：强引用、软引用、弱引用和虚引用。Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。下面来阐述一下这四种类型引用的概念：</p>
<h2 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h2><p>　　强引用就是指在程序代码之中普遍存在的，比如下面这段代码中的object和str都是强引用：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object object = new Object();</div><div class="line">String str = &quot;hello&quot;;</div></pre></td></tr></table></figure></p>
<p>只要某个对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。比如下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new Main().fun1();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public void fun1() &#123;</div><div class="line">        Object object = new Object();</div><div class="line">        Object[] objArr = new Object[1000];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当运行至Object[] objArr = new Object[1000];这句时，如果内存不足，JVM会抛出OOM错误也不会回收object指向的对象。不过要注意的是，当fun1运行完之后，object和objArr都已经不存在了，所以它们指向的对象都会被JVM回收。</p>
<p>　　如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。</p>
<p>　　比如Vector类的clear方法中就是通过将引用赋值为null来实现清理工作的：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Removes the element at the specified position in this Vector.</div><div class="line"> * Shifts any subsequent elements to the left (subtracts one from their</div><div class="line"> * indices).  Returns the element that was removed from the Vector.</div><div class="line"> *</div><div class="line"> * @throws ArrayIndexOutOfBoundsException if the index is out of range</div><div class="line"> *         (&#123;@code index &lt; 0 || index &gt;= size()&#125;)</div><div class="line"> * @param index the index of the element to be removed</div><div class="line"> * @return element that was removed</div><div class="line"> * @since 1.2</div><div class="line"> */</div><div class="line">public synchronized E remove(int index) &#123;</div><div class="line">modCount++;</div><div class="line">if (index &gt;= elementCount)</div><div class="line">    throw new ArrayIndexOutOfBoundsException(index);</div><div class="line">Object oldValue = elementData[index];</div><div class="line"></div><div class="line">int numMoved = elementCount - index - 1;</div><div class="line">if (numMoved &gt; 0)</div><div class="line">    System.arraycopy(elementData, index+1, elementData, index,</div><div class="line">             numMoved);</div><div class="line">elementData[--elementCount] = null; // Let gc do its work</div><div class="line"></div><div class="line">return (E)oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h2><p>软引用是用来描述一些有用但并不是必需的对象，在Java中用java.lang.ref.SoftReference类来表示。<strong>对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。</strong> 因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>
<p>　　软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。下面是一个使用示例：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import java.lang.ref.SoftReference;</div><div class="line"> </div><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">         </div><div class="line">        SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String(&quot;hello&quot;));</div><div class="line">        System.out.println(sr.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h2><p>　　弱引用也是用来描述非必需对象的，<strong>当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。</strong> 在java中，用java.lang.ref.WeakReference类来表示。下面是使用示例：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import java.lang.ref.WeakReference;</div><div class="line"> </div><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">     </div><div class="line">        WeakReference&lt;String&gt; sr = new WeakReference&lt;String&gt;(new String(&quot;hello&quot;));</div><div class="line">         </div><div class="line">        System.out.println(sr.get());</div><div class="line">        System.gc();                //通知JVM的gc进行垃圾回收</div><div class="line">        System.out.println(sr.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello</div><div class="line">null</div></pre></td></tr></table></figure>
<p>第二个输出结果是null，这说明只要JVM进行垃圾回收，被弱引用关联的对象必定会被回收掉。不过要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。</p>
<p>　　弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。
　　</p>
<h2 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h2><p>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。<strong>如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</strong></p>
<p>　　要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import java.lang.ref.PhantomReference;</div><div class="line">import java.lang.ref.ReferenceQueue;</div><div class="line"> </div><div class="line"> </div><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;String&gt;();</div><div class="line">        PhantomReference&lt;String&gt; pr = new PhantomReference&lt;String&gt;(new String(&quot;hello&quot;), queue);</div><div class="line">        System.out.println(pr.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="进一步理解软引用和弱引用"><a href="#进一步理解软引用和弱引用" class="headerlink" title="进一步理解软引用和弱引用"></a>进一步理解软引用和弱引用</h1><p>　对于强引用，我们平时在编写代码时经常会用到。而对于其他三种类型的引用，使用得最多的就是软引用和弱引用，这2种既有相似之处又有区别。它们都是用来描述非必需对象的，<strong>但是被软引用关联的对象只有在++内存不足时才会被回收++，而被弱引用关联的对象在++JVM进行垃圾回收时总会被回收++。</strong></p>
<p>　　在SoftReference类中，有三个方法，两个构造方法和一个get方法（WekReference类似）：</p>
<p>　　两个构造方法：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public SoftReference(T referent) &#123;</div><div class="line">    super(referent);</div><div class="line">    this.timestamp = clock;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public SoftReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</div><div class="line">    super(referent, q);</div><div class="line">    this.timestamp = clock;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　get方法用来获取与软引用关联的对象的引用，如果该对象被回收了，则返回null。</p>
<p> 　　在使用软引用和弱引用的时候，我们可以显示地通过System.gc()来通知JVM进行垃圾回收，但是要注意的是，虽然发出了通知，JVM不一定会立刻执行，<strong>也就是说这句是无法确保此时JVM一定会进行垃圾回收的。</strong></p>
<h1 id="如何利用软引用和弱引用解决OOM问题"><a href="#如何利用软引用和弱引用解决OOM问题" class="headerlink" title="如何利用软引用和弱引用解决OOM问题"></a>如何利用软引用和弱引用解决OOM问题</h1><p>　　前面讲了关于软引用和弱引用相关的基础知识，那么到底如何利用它们来优化程序性能，从而避免OOM的问题呢？</p>
<p>　　下面举个例子，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。</p>
<p>　　设计思路是：用一个HashMap来保存图片的路径 和 相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。在Android开发中对于大量图片下载会经常用到。</p>
<p>下面这段代码是摘自博客：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">.....</div><div class="line">private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</div><div class="line">&lt;br&gt;....</div><div class="line">public void addBitmapToCache(String path) &#123;</div><div class="line"> </div><div class="line">    // 强引用的Bitmap对象</div><div class="line"></div><div class="line">    Bitmap bitmap = BitmapFactory.decodeFile(path);</div><div class="line"></div><div class="line">    // 软引用的Bitmap对象</div><div class="line"></div><div class="line">    SoftReference&lt;Bitmap&gt; softBitmap = new SoftReference&lt;Bitmap&gt;(bitmap);</div><div class="line"></div><div class="line">    // 添加该对象到Map中使其缓存</div><div class="line"></div><div class="line">    imageCache.put(path, softBitmap);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public Bitmap getBitmapByPath(String path) &#123;</div><div class="line"></div><div class="line">    // 从缓存中取软引用的Bitmap对象</div><div class="line"></div><div class="line">    SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path);</div><div class="line"></div><div class="line">    // 判断是否存在软引用</div><div class="line"></div><div class="line">    if (softBitmap == null) &#123;</div><div class="line"></div><div class="line">        return null;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空</div><div class="line"></div><div class="line">    Bitmap bitmap = softBitmap.get();</div><div class="line"></div><div class="line">    return bitmap;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然这里我们把缓存替换策略交给了JVM去执行，这是一种比较简单的处理方法。复杂一点的缓存，我们可以自己单独设计一个类，这里面就涉及到缓存策略的问题了，具体可以参考之前的一篇博文：《缓存算法（页面置换算法）-FIFO、LFU、LRU》</p>
<p><strong>参考资料：</strong></p>
<p>　　《深入理解JVM虚拟机》</p>
<p>　　<a href="http://blog.csdn.net/arui319/article/details/8489451" target="_blank" rel="external">http://blog.csdn.net/arui319/article/details/8489451</a></p>
<p>　　<a href="http://blog.csdn.net/zsuguangh/article/details/6429592" target="_blank" rel="external">http://blog.csdn.net/zsuguangh/article/details/6429592</a></p>
<p>　　<a href="http://mobile.51cto.com/abased-406998.htm" target="_blank" rel="external">http://mobile.51cto.com/abased-406998.htm</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;海子：&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3784171.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java 如何有效地避免OOM：善于利用软引用和弱引用&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;想必很多朋友对OOM（OutOfMemory）这个错误不会陌生，而当遇到这种错误如何有效地解决这个问题呢？今天我们就来说一下如何利用软引用和弱引用来有效地解决程序中出现的OOM问题。&lt;/p&gt;
&lt;h1 id=&quot;了解-强引用、软引用、弱引用、虚引用的概念&quot;&gt;&lt;a href=&quot;#了解-强引用、软引用、弱引用、虚引用的概念&quot; class=&quot;headerlink&quot; title=&quot;了解 强引用、软引用、弱引用、虚引用的概念&quot;&gt;&lt;/a&gt;了解 强引用、软引用、弱引用、虚引用的概念&lt;/h1&gt;&lt;p&gt;在Java中，虽然不需要程序员手动去管理对象的生命周期，但是如果希望某些对象具备一定的生命周期的话（比如内存不足时JVM就会自动回收某些对象从而避免OutOfMemory的错误）就需要用到软引用和弱引用了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程：深入剖析ThreadLocal</title>
    <link href="http://www.jiyongguang.xin/threadlocal.html"/>
    <id>http://www.jiyongguang.xin/threadlocal.html</id>
    <published>2018-06-07T07:04:54.000Z</published>
    <updated>2018-06-07T07:08:55.435Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：</p>
<p>海子：<a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="external">Java并发编程：深入剖析ThreadLocal</a></p>
<p>在原作者的内容上自己又从别处copy了一些揉成的一篇文章。</p>
<h1 id="对ThreadLocal的理解"><a href="#对ThreadLocal的理解" class="headerlink" title="对ThreadLocal的理解"></a>对ThreadLocal的理解</h1><p>　　ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<p>　　这句话从字面上看起来很容易理解，但是真正理解并不是那么容易。</p>
<a id="more"></a>
<p>　　我们还是先来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class ConnectionManager &#123;</div><div class="line">     </div><div class="line">    private static Connection connect = null;</div><div class="line">     </div><div class="line">    public static Connection openConnection() &#123;</div><div class="line">        if(connect == null)&#123;</div><div class="line">            connect = DriverManager.getConnection();</div><div class="line">        &#125;</div><div class="line">        return connect;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void closeConnection() &#123;</div><div class="line">        if(connect!=null)</div><div class="line">            connect.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 　　假设有这样一个数据库链接管理类，这段代码在单线程中使用是没有任何问题的，但是如果在多线程中使用呢？很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。</p>
<p>　　所以出于线程安全的考虑，必须将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理。</p>
<p>　　这样将会大大影响程序执行效率，因为一个线程在使用connect进行数据库操作的时候，其他线程只有等待。</p>
<p>　　那么大家来仔细分析一下这个问题，这地方到底需不需要将connect变量进行共享？事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。</p>
<p>　　到这里，可能会有朋友想到，既然不需要在线程之间共享这个变量，可以直接这样处理，在每个需要使用数据库连接的方法中具体使用时才创建数据库链接，然后在方法调用完毕再释放这个连接。比如下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class ConnectionManager &#123;</div><div class="line">     </div><div class="line">    private  Connection connect = null;</div><div class="line">     </div><div class="line">    public Connection openConnection() &#123;</div><div class="line">        if(connect == null)&#123;</div><div class="line">            connect = DriverManager.getConnection();</div><div class="line">        &#125;</div><div class="line">        return connect;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public void closeConnection() &#123;</div><div class="line">        if(connect!=null)</div><div class="line">            connect.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">class Dao&#123;</div><div class="line">    public void insert() &#123;</div><div class="line">        ConnectionManager connectionManager = new ConnectionManager();</div><div class="line">        Connection connection = connectionManager.openConnection();</div><div class="line">         </div><div class="line">        //使用connection进行操作</div><div class="line">         </div><div class="line">        connectionManager.closeConnection();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 　　这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不尽严重影响程序执行效率，还可能导致服务器压力巨大。</p>
<p>　　那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。</p>
<p>　　但是要注意，虽然ThreadLocal能够解决上面说的问题，但是<strong>由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</strong></p>
<h1 id="深入解析ThreadLocal类"><a href="#深入解析ThreadLocal类" class="headerlink" title="深入解析ThreadLocal类"></a>深入解析ThreadLocal类</h1><p>　　在上面谈到了对ThreadLocal的一些理解，那我们下面来看一下具体ThreadLocal是如何实现的。</p>
<p>　　先了解一下ThreadLocal类提供的几个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public T get() &#123; &#125;</div><div class="line">public void set(T value) &#123; &#125;</div><div class="line">public void remove() &#123; &#125;</div><div class="line">protected T initialValue() &#123; &#125;</div></pre></td></tr></table></figure></p>
<p> 　　get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法，下面会详细说明。</p>
<p>　　首先我们来看一下ThreadLocal类是如何为每个线程创建一个变量的副本的。</p>
<p>　　先看下get方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public T get() &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">        if (e != null) &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            T result = (T)e.value;</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 　　第一句是取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到<code>&lt;key,value&gt;</code>键值对，<strong>注意这里获取键值对传进去的是  this，而不是当前线程t。</strong></p>
<p>　　如果获取成功，则返回value值。</p>
<p>　　如果map为空，则调用setInitialValue方法返回value。</p>
<p>　　我们上面的每一句来仔细分析：</p>
<p>　　首先看一下getMap方法中做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ThreadLocalMap getMap(Thread t) &#123;</div><div class="line">    return t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　可能大家没有想到的是，在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。</p>
<p>　　那么我们继续取Thread类中取看一下成员变量threadLocals是什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</div><div class="line">     * by the ThreadLocal class. */</div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</div></pre></td></tr></table></figure></p>
<hr>
<p>　　实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们继续取看ThreadLocalMap的实现：<br>　　<br>关于弱引用WeakReference的学习可参考：<a href="https://www.cnblogs.com/absfree/p/5555687.html" target="_blank" rel="external">理解Java中的弱引用（Weak Reference）</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static class ThreadLocalMap &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The entries in this hash map extend WeakReference, using</div><div class="line">     * its main ref field as the key (which is always a</div><div class="line">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</div><div class="line">     * == null) mean that the key is no longer referenced, so the</div><div class="line">     * entry can be expunged from table.  Such entries are referred to</div><div class="line">     * as &quot;stale entries&quot; in the code that follows.</div><div class="line">     */</div><div class="line">    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</div><div class="line">        /** The value associated with this ThreadLocal. */</div><div class="line">        Object value;</div><div class="line"></div><div class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">            super(k);</div><div class="line">            value = v;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ····</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到ThreadLocalMap的Entry继承了弱引用WeakReference，而WeakReference的泛型也指向了Entry中的键值ThreadLocal。也就是说<strong>ThreadLocalMap是使用ThreadLocal的弱引用作为key的</strong>，它这么设计的原因也是为了方便它的键值ThreadLocal在外部没有强引用引用的情况下进行内存的释放。</p>
<p>下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：</p>
<p><img src="https://pic1.zhimg.com/80/9671b789e1da4f760483456c03e4f4b6_hd.jpg" alt=""></p>
<p>然后网上就传言，ThreadLocal会引发内存泄露，他们的理由是这样的：</p>
<p>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，<strong>如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，</strong> 这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p>
<p>ThreadLocal Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p>
<p>永远无法回收，造成内存泄露。</p>
<p>我们来看看到底会不会出现这种情况。 其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</div><div class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</div><div class="line">    Entry e = table[i]; // Entry 继承 WeakReference</div><div class="line">    if (e != null &amp;&amp; e.get() == key) // e.get()拿出的是WeakReferencere的referent</div><div class="line">        return e;// 如果桶有元素且元素刚好是此ThreadLocal</div><div class="line">    else</div><div class="line">        return getEntryAfterMiss(key, i, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getEntryAfterMiss函数的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line"></div><div class="line">    while (e != null) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        if (k == key)</div><div class="line">            return e;</div><div class="line">        if (k == null) // 如果从桶中取出的Entry的key==null</div><div class="line">            expungeStaleEntry(i);</div><div class="line">        else</div><div class="line">            i = nextIndex(i, len); // 类似HsahMap中取桶中的链表的下一元素</div><div class="line">        e = tab[i];</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>expungeStaleEntry函数的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> private int expungeStaleEntry(int staleSlot) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line"></div><div class="line">    // expunge entry at staleSlot</div><div class="line">    tab[staleSlot].value = null;</div><div class="line">    tab[staleSlot] = null;</div><div class="line">    size--;</div><div class="line"></div><div class="line">    // Rehash until we encounter null</div><div class="line">    Entry e;</div><div class="line">    int i;</div><div class="line">    for (i = nextIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != null;</div><div class="line">         i = nextIndex(i, len)) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        if (k == null) &#123;</div><div class="line">            e.value = null;</div><div class="line">            tab[i] = null;</div><div class="line">            size--;</div><div class="line">        &#125; else &#123;</div><div class="line">            int h = k.threadLocalHashCode &amp; (len - 1);</div><div class="line">            if (h != i) &#123;</div><div class="line">                tab[i] = null;</div><div class="line"></div><div class="line">                // Unlike Knuth 6.4 Algorithm R, we must scan until</div><div class="line">                // null because multiple entries could have been stale.</div><div class="line">                while (tab[h] != null)</div><div class="line">                    h = nextIndex(h, len);</div><div class="line">                tab[h] = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整理一下ThreadLocalMap的getEntry函数的流程：</p>
<ol>
<li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；</li>
<li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询</li>
</ol>
<p><strong>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。</strong> 仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。</p>
<p><strong>需要注意的是：</strong></p>
<p>虽然ThreadLocalMap内部有对这样的Key为null的Entry的处理机制，但是光这样还是不够的，<strong>上面的设计思路依赖一个前提条件：要调用ThreadLocalMap的genEntry函数或者set函数。</strong> 这当然是不可能任何情况都成立的，<strong>所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。</strong> 所以JDK建议将ThreadLocal变量定义成<code>private static</code>的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露(针对Value)。</p>
<p><strong>参考</strong>：<a href="https://www.zhihu.com/question/23089780/answer/62097840" target="_blank" rel="external">ThreadLocal和synchronized的区别?</a></p>
<hr>
<p>然后再继续看setInitialValue方法的具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private T setInitialValue() &#123;</div><div class="line">    T value = initialValue();</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value);</div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">    return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　很容易了解，就是如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void createMap(Thread t, T firstValue) &#123;</div><div class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　至此，可能大部分朋友已经明白了ThreadLocal是如何为每个线程创建变量的副本的：</p>
<p>　　首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p>
<p>　　初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p>
<p>　　然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
<p>　　下面通过一个例子来证明通过ThreadLocal能达到在每个线程中创建变量副本的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;();</div><div class="line">    ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;();</div><div class="line"> </div><div class="line">     </div><div class="line">    public void set() &#123;</div><div class="line">        longLocal.set(Thread.currentThread().getId());</div><div class="line">        stringLocal.set(Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public long getLong() &#123;</div><div class="line">        return longLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public String getString() &#123;</div><div class="line">        return stringLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        final Test test = new Test();</div><div class="line">         </div><div class="line">         </div><div class="line">        test.set();</div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">     </div><div class="line">         </div><div class="line">        Thread thread1 = new Thread()&#123;</div><div class="line">            public void run() &#123;</div><div class="line">                test.set();</div><div class="line">                System.out.println(test.getLong());</div><div class="line">                System.out.println(test.getString());</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">        thread1.start();</div><div class="line">        thread1.join();</div><div class="line">         </div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码的输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">main</div><div class="line">8</div><div class="line">Thread-0</div><div class="line">1</div><div class="line">main</div></pre></td></tr></table></figure></p>
<p>　　从这段代码的输出结果可以看出，在main线程中和thread1线程中，longLocal保存的副本值和stringLocal保存的副本值都不一样。最后一次在main线程再次打印副本值是为了证明在main线程中和thread1线程中的副本值确实是不同的。</p>
<h2 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h2><ol>
<li>实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；</li>
<li>为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；</li>
<li>在进行get之前，必须先set，否则通过ThreadLoca的get函数取出的值为null(默认<code>initValue()</code>函数的结果)。<ul>
<li>如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。因为在上面的代码分析过程中，我们发现如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public T get() &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">        if (e != null) &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            T result = (T)e.value;</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return setInitialValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private T setInitialValue() &#123;</div><div class="line">    T value = initialValue();</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value);</div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">    return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;();</div><div class="line">    ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;();</div><div class="line">    </div><div class="line">    public void set() &#123;</div><div class="line">        longLocal.set(Thread.currentThread().getId());</div><div class="line">        stringLocal.set(Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public long getLong() &#123;</div><div class="line">        return longLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public String getString() &#123;</div><div class="line">        return stringLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        final Test test = new Test();</div><div class="line">         </div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">    </div><div class="line">        Thread thread1 = new Thread()&#123;</div><div class="line">            public void run() &#123;</div><div class="line">                test.set();</div><div class="line">                System.out.println(test.getLong());</div><div class="line">                System.out.println(test.getString());</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">        thread1.start();</div><div class="line">        thread1.join();</div><div class="line">         </div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">    &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在main线程中，没有先set，直接get的话，运行时会报空指针异常。</p>
<p>　　但是如果改成下面这段代码，即重写了initialValue方法：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;()&#123;</div><div class="line">        protected Long initialValue() &#123;</div><div class="line">            return Thread.currentThread().getId();</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;()&#123;;</div><div class="line">        protected String initialValue() &#123;</div><div class="line">            return Thread.currentThread().getName();</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">     </div><div class="line">    public void set() &#123;</div><div class="line">        longLocal.set(Thread.currentThread().getId());</div><div class="line">        stringLocal.set(Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public long getLong() &#123;</div><div class="line">        return longLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public String getString() &#123;</div><div class="line">        return stringLocal.get();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        final Test test = new Test();</div><div class="line"> </div><div class="line">        test.set();</div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">     </div><div class="line">         </div><div class="line">        Thread thread1 = new Thread()&#123;</div><div class="line">            public void run() &#123;</div><div class="line">                test.set();</div><div class="line">                System.out.println(test.getLong());</div><div class="line">                System.out.println(test.getString());</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">        thread1.start();</div><div class="line">        thread1.join();</div><div class="line">         </div><div class="line">        System.out.println(test.getLong());</div><div class="line">        System.out.println(test.getString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　就可以直接不用先set而直接调用get了。<br>　<br>　# 三.ThreadLocal的应用场景</p>
<p>　　最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。<br>　　<br>　　如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() &#123;</div><div class="line">    public Connection initialValue() &#123;</div><div class="line">        return DriverManager.getConnection(DB_URL);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">public static Connection getConnection() &#123;</div><div class="line">    return connectionHolder.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　下面这段代码摘自：</p>
<p>　　<a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">正确理解ThreadLocal</a><br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private static final ThreadLocal threadSession = new ThreadLocal();</div><div class="line"> </div><div class="line">public static Session getSession() throws InfrastructureException &#123;</div><div class="line">    Session s = (Session) threadSession.get();</div><div class="line">    try &#123;</div><div class="line">        if (s == null) &#123;</div><div class="line">            s = getSessionFactory().openSession();</div><div class="line">            threadSession.set(s);</div><div class="line">        &#125;</div><div class="line">    &#125; catch (HibernateException ex) &#123;</div><div class="line">        throw new InfrastructureException(ex);</div><div class="line">    &#125;</div><div class="line">    return s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出每个线程操控属于自己的一个Session。</p>
<h1 id="关于ThreadLocal在exchange中的用法"><a href="#关于ThreadLocal在exchange中的用法" class="headerlink" title="关于ThreadLocal在exchange中的用法"></a>关于ThreadLocal在exchange中的用法</h1><p>当某个线程被程序分配到执行某个用户的请求时，由于对于每次来请求的用户的身份未知，所以为了该线程所处理的函数间用户身份信息的传递确认，会用ThreadLocal来存储用户信息。这里ThreadLocal的作用也就是相当于<strong>方便函数间参数传递的工具</strong> exchange项目的代码中做的处理就是每个请求过来先走PassportInterceptor来确认用户身份并且绑定到Hostholder中 这样无论程序分配的是哪个线程来处理用户的请求 函数间传递的都是该身份的用户不会出错。并且由于每个请求都走该拦截器，所以用户每次过来当前线程的ThreadLocal对应的对象都是当前用户会替换掉之前存储在其中的用户。</p>
<h1 id="ThreadLocal与Synchonized的对照"><a href="#ThreadLocal与Synchonized的对照" class="headerlink" title="ThreadLocal与Synchonized的对照"></a>ThreadLocal与Synchonized的对照</h1><p>ThreadLocal和Synchonized都用于解决多线程并发訪问。可是ThreadLocal与synchronized有本质的差别。synchronized是利用锁的机制，使变量或代码块在某一时该仅仅能被一个线程訪问。而ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时可以获得数据共享。</p>
<p>Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。</p>
<h1 id="学习时必看的另两篇文章"><a href="#学习时必看的另两篇文章" class="headerlink" title="学习时必看的另两篇文章"></a>学习时必看的另两篇文章</h1><ul>
<li><a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">正确理解ThreadLocal</a></li>
<li><a href="https://www.cnblogs.com/yxysuanfa/p/7125761.html" target="_blank" rel="external">java ThreadLocal(应用场景及使用方式及原理)</a></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>参考资料：</p>
<ul>
<li>《深入理解Java虚拟机》</li>
<li>《Java编程思想》</li>
<li><a href="http://ifeve.com/thread-management-10/" target="_blank" rel="external">http://ifeve.com/thread-management-10/</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-threads/index3.html" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-threads/index3.html</a></li>
<li><a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">http://www.iteye.com/topic/103804</a></li>
<li><a href="http://www.iteye.com/topic/777716" target="_blank" rel="external">http://www.iteye.com/topic/777716</a></li>
<li><a href="http://www.iteye.com/topic/757478" target="_blank" rel="external">http://www.iteye.com/topic/757478</a></li>
<li><a href="http://blog.csdn.net/ghsau/article/details/15732053" target="_blank" rel="external">http://blog.csdn.net/ghsau/article/details/15732053</a></li>
<li><a href="http://ispring.iteye.com/blog/162982" target="_blank" rel="external">http://ispring.iteye.com/blog/162982</a></li>
<li><a href="http://blog.csdn.net/imzoer/article/details/8262101" target="_blank" rel="external">http://blog.csdn.net/imzoer/article/details/8262101</a></li>
<li><a href="http://www.blogjava.net/wumi9527/archive/2010/09/10/331654.html" target="_blank" rel="external">http://www.blogjava.net/wumi9527/archive/2010/09/10/331654.html</a></li>
<li><a href="http://bbs.csdn.net/topics/380049261" target="_blank" rel="external">http://bbs.csdn.net/topics/380049261</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;/p&gt;
&lt;p&gt;海子：&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3920407.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java并发编程：深入剖析ThreadLocal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在原作者的内容上自己又从别处copy了一些揉成的一篇文章。&lt;/p&gt;
&lt;h1 id=&quot;对ThreadLocal的理解&quot;&gt;&lt;a href=&quot;#对ThreadLocal的理解&quot; class=&quot;headerlink&quot; title=&quot;对ThreadLocal的理解&quot;&gt;&lt;/a&gt;对ThreadLocal的理解&lt;/h1&gt;&lt;p&gt;　　ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。&lt;/p&gt;
&lt;p&gt;　　这句话从字面上看起来很容易理解，但是真正理解并不是那么容易。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="并发" scheme="http://www.jiyongguang.xin/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java集合考点总结</title>
    <link href="http://www.jiyongguang.xin/collection-summary.html"/>
    <id>http://www.jiyongguang.xin/collection-summary.html</id>
    <published>2018-06-02T13:46:10.000Z</published>
    <updated>2018-06-04T10:41:46.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、ArrayList和Vector的区别"><a href="#一、ArrayList和Vector的区别" class="headerlink" title="一、ArrayList和Vector的区别"></a>一、ArrayList和Vector的区别</h1><p>共同点：</p>
<ul>
<li>都实现了List接口继承了AbstractList接口</li>
<li>底层实现都是数组。所以说都是存储有序的集合</li>
<li>允许存储null</li>
</ul>
<p>不同点：</p>
<ul>
<li>ArrayList是线程不安全的，Vector则是线程安全的，即便我们需要线程安全的数组容器也是会选择ArrayList，只是在初始化的时候通过<code>Collections</code>集合类的工具类来进行包装一下。因为这种同步实现更科学</li>
<li>扩容时ArrayList扩容系数为1.5，Vector则是2</li>
</ul>
<a id="more"></a>
<h1 id="二、HashMap和Hashtable的区别"><a href="#二、HashMap和Hashtable的区别" class="headerlink" title="二、HashMap和Hashtable的区别"></a>二、HashMap和Hashtable的区别</h1><p>总的来说HashTable的存在和Vector是一个意思。都是早期的实现，并且盲目的保证了集合的线程安全。却在一些不必要的操作上影响了集合的性能，并且早期函数的命名并不科学简洁严谨。</p>
<p>共同点：</p>
<ul>
<li>实现了Map接口</li>
</ul>
<p>不同点：</p>
<ul>
<li>HashMap非同步，HashTable同步。当我们需要同步的映射容器的时候Java也提供了<code>ConcurrentHashMap</code>这个类。</li>
<li>HashMap允许null键和null值，HashTable不允许null键或者null值。</li>
<li>HashMap没有保留HashTable的contains函数，而且和HashTable一样添加了<code>containsValue</code>和<code>containsKey</code>函数。并选用containsKey函数来替代contains的功能。</li>
<li>两者继承不同。HashTable继承自Dictionary父类而HashMap继承自AbstractMap父类。</li>
</ul>
<h1 id="三、List和Map的区别"><a href="#三、List和Map的区别" class="headerlink" title="三、List和Map的区别"></a>三、List和Map的区别</h1><p>存储结构不同</p>
<ul>
<li>List是单列存储，Map是key-value键值存储</li>
<li>List允许存重复元素,Map则key值不能重复</li>
<li>List存储有序，Map映射存储无序。</li>
</ul>
<h1 id="四、Set集合定义存储在其中的元素是不能重复的，元素的重复与否是如何判断的？是用-还是equals"><a href="#四、Set集合定义存储在其中的元素是不能重复的，元素的重复与否是如何判断的？是用-还是equals" class="headerlink" title="四、Set集合定义存储在其中的元素是不能重复的，元素的重复与否是如何判断的？是用==还是equals()?"></a>四、Set集合定义存储在其中的元素是不能重复的，元素的重复与否是如何判断的？是用==还是equals()?</h1><p>首先需要清楚Set集合的常见实现类的底层实现用的都是Map映射的子类。</p>
<p>拿HashSet来举例，它的底层是现金就是HashMap。而我们知道HashSet的存储方式是把存入的元素对应的存到了HashMap的key中，而value则是固定的Object对象的常量。</p>
<p>所以问题就落到了HashMap是如何处理存入相同key的情况的呢？</p>
<p>HashMap源码的632-635行是这样判断的，如果key值散列到的桶的头元素与该key的hash值相等。并且key值相<code>==</code>或者key值equals的话，那么就认为该key值已经存在在了HashMap中。那么就跳出判断循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Node&lt;K,V&gt; e; K k;</div><div class="line">    if (p.hash == hash &amp;&amp;</div><div class="line">        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">        e = p;</div><div class="line">        </div><div class="line">=============</div><div class="line"></div><div class="line">if (e != null) &#123; // existing mapping for key</div><div class="line">    V oldValue = e.value;</div><div class="line">    if (!onlyIfAbsent || oldValue == null)</div><div class="line">        e.value = value;</div><div class="line">    afterNodeAccess(e);</div><div class="line">    return oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HashMap源码652行做了如上处理，即拿出旧值并返回，对应的节点的value替换上新值。</p>
<p><strong>解答：</strong></p>
<p>所以针对上述问题，对于Set来说，当插入重复元素的时候，就代表这HashMap要插入具有重复key值得节点。那么由于插入到Set集合的节点的value均是相同的无意义的Object常量对象。所以底层HashMap相当于只是在频繁的修改无疑的value。</p>
<p>从源码可以看出来<code>==</code>和<code>equals</code>两者都用了。</p>
<h1 id="五、Collection和Collections的区别"><a href="#五、Collection和Collections的区别" class="headerlink" title="五、Collection和Collections的区别"></a>五、Collection和Collections的区别</h1><ul>
<li>Collection是集合类的顶级接口，实现它的有Set接口和=，List接口，Queue接口。</li>
<li>Collections是集合的工具类。提供了一系列的静态函数来对集合进行搜索，查找，以及同步的一些操作等。</li>
</ul>
<h1 id="六、说出ArrayList-LinkedList的存储性能和特性"><a href="#六、说出ArrayList-LinkedList的存储性能和特性" class="headerlink" title="六、说出ArrayList,LinkedList的存储性能和特性"></a>六、说出ArrayList,LinkedList的存储性能和特性</h1><p>ArrayList底层是数组实现，存储有序。LinkedList底层是双向链表实现的，存储无序。</p>
<p>由于ArrayList底层实现是动态数组，所以对于ArrayList来说访问其元素可以根据角标的方式访问，非常快。而LinkedList要访问元素的时候只能通过遍历来找到要找的元素。所以ArrayList比LinkedList的访问速度要快，性能要好。</p>
<p>同样的由于是数组的原因也就导致它在进行增删操作的时候是不方便的比较缓慢的(移动数组元素，扩容复制数组)。LinkedList只需要修改对应节点next指针即可。消耗很小，所以LinkedList比ArrayList的增删速度要快，性能要好。</p>
<p> <strong>注意：</strong></p>
<p>但同时我们需要细想一个删除操作具体体现的不仅仅是删除这一个操作。对于不同的数据结构而言，找到要删除的元素也是一个性能差异很大的点。</p>
<p>比如对于LinkedList的删除操作而言，删除节点本身是很简易的，但是慢就慢在它需要对所有元素去迭代一遍来找这个元素。而对于ArrayList来说删除操作是不易的，因为它要面临着被删除位置后的数组元素前移的操作。而找元素这个操作对数组来说却是速度很快的一个操作。所以整体上来说两者增删操作的性能差异就不是那么的确定了。比较时考虑的点还是比较的多</p>
<h2 id="HashTable，SynchronizedMap，ConcurrentHashMap区别"><a href="#HashTable，SynchronizedMap，ConcurrentHashMap区别" class="headerlink" title="HashTable，SynchronizedMap，ConcurrentHashMap区别"></a>HashTable，SynchronizedMap，ConcurrentHashMap区别</h2><p><strong>HashTable</strong></p>
<p>相比于HashMap，HashTable与其最大的区别就是所有函数都实现了同步。并且HashTable由于是最早设计的容器框架，有许多设计上的不足，并且后续并没有改进。最典型的元素插入时的put函数，元素的散列位置是通过<code>%</code>来计算的，而非像HashMap中<code>(table.length-1)&amp;hash(key)</code></p>
<p><strong>synchronizedMap</strong></p>
<p>synchronizedMap可以作用于任何Map实现类上，但是相比于HashTable最大的区别则是它并不是盲目的对所有的函数都实现了同步。一定程度上性能要高于HashTable不少。但是两者都是对象锁。所以当并发情况下有一个线程在执行被锁函数那么并发情况下的其它线程必然都是等待状态。synchronizedMap相比于HashTable保证的只是非同步方法在多线程情况下的并行运行。</p>
<p>潜在问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Java代码</div><div class="line"></div><div class="line">// shm是SynchronizedMap的一个实例</div><div class="line">if(shm.containsKey(&apos;key&apos;))&#123;</div><div class="line">        shm.remove(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码用于从map中删除一个元素之前判断是否存在这个元素。这里的 containsKey和reomve方法都是同步的，但是整段代码却不是。考虑这么一个使用场景：线程A执行了containsKey方法返回 true，准备执行remove操作；这时另一个线程B开始执行，同样执行了containsKey方法返回true，并接着执行了remove操作；然 后线程A接着执行remove操作时发现此时已经没有这个元素了。要保证这段代码按我们的意愿工作，一个办法就是对这段代码进行同步控制，但是这么做付出 的代价太大。</p>
<p><strong>同样还有：</strong> 并发情况下的迭代及修改。可能我们在迭代的时候某个线程对该Map正在执行并发修改的操作。此时就会报出并发修改的异常</p>
<p>参考：<a href="https://www.cnblogs.com/grefr/p/6094888.html" target="_blank" rel="external">SynchronizedMap和ConcurrentHashMap 区别</a></p>
<p><strong>ConcurrentHashMap</strong></p>
<p>ConcurrentHashMap相比于前两者不但汲取了synchronizedMap的优点并没有对一些必要的函数实现同步。并且非同步的函数和HashMap的函数处理逻辑基本一致。而对于需要同步的函数，其内部采用的也是“桶锁”，它不会对整个Map映射上锁。这从一定程度上大大提升了性能，使其可以在多线程并发的情况下函数间并行执行，而不会影响执行结果和效率。</p>
<h2 id="ArrayList和LinkedList增删分析"><a href="#ArrayList和LinkedList增删分析" class="headerlink" title="ArrayList和LinkedList增删分析"></a>ArrayList和LinkedList增删分析</h2><p><strong>ArrayList插入分析：</strong></p>
<p>ArrayList的<code>add(E e)</code>函数默认是尾插。 我们如果采用该方法插入大量元素的话。不会存在元素移位的情况。这种插入方式和LinkedList的插入方式一样高效，复杂度都是O(1)。不存在元素移位的情况，而如果采用<code>add(int index, E element)</code>函数来对某个索引处的元素前插入大量元素的话，每插入一次元素都会 使数组索引后续元素都进行一次元素移动的操作，复杂度是O(n)。<strong>关键区别看你插入大量元素时想插到哪里</strong></p>
<p><strong>LinkedList插入分析：</strong></p>
<p>LinkedList的<code>add(E e)</code>函数默认插入方式是尾插法。由于它是双向链表并且纪录了头尾两个节点。所以用这个方式插入大量元素的时间复杂度是0(1)。addFirst和addLast同样的道理由于纪录了头尾两节点的原因。</p>
<p><strong>ArrayList删除分析：</strong><br>而ArrayList提供的remove函数在删除大量元素的时候，就必然会进行数组元素的移位操作。它的耗时操作也就在此处。</p>
<p><strong>LinkedList删除分析：</strong></p>
<p>LinkedList由于是双向链表，所以头删尾删都有性能上的优势，复杂度均是O(1)。只需要考虑查找元素的复杂度即可。而且LinkedList中进行了折半查找，先对元素的索引和总元素数size进行比较来确认从头迭代的找还是尾迭代的找。元素总规模先<code>&gt;&gt;</code>后才进行的迭代。</p>
<h2 id="扩展：ArrayList和LinkedList增删性能比较"><a href="#扩展：ArrayList和LinkedList增删性能比较" class="headerlink" title="扩展：ArrayList和LinkedList增删性能比较"></a>扩展：ArrayList和LinkedList增删性能比较</h2><p>ArrayList的增删未必就是比LinkedList要慢。</p>
<p>如果增删都是在末尾来操作【每次调用的都是remove()和add()】，此时ArrayList就不需要移动数组元素了(增加元素的时候还是有可能触发扩容操作可能会扩容并复制数组)。如果数据量有百万级的时，ArrayList的速度是会比LinkedList要快的。(我测试过)</p>
<p>如果删除操作的位置是在中间。由于LinkedList的消耗主要是在遍历上，ArrayList的消耗主要是在数组元素的移动上(底层调用的是arraycopy()方法，是native方法)。<br>LinkedList的遍历速度是要慢于ArrayList的数组元素移动的速度的<br>如果数据量有百万级的时，还是ArrayList要快。(我测试过)</p>
<p>删末尾元素 ArrayList 删掉最后一个元素， LinkedList删掉最后一个元素。指针的变化，相对复杂一些</p>
<p>删中间元素，ArrayList需要做的是移动数组后续元素。而arraycopy是native函数，在JVM运行时有性能优势<br>而且本身进行的也是赋值操作，简单速度快</p>
<p>LinkedList需要做的是遍历元素，内存中指针的移动相对速度慢于赋值操作一些。<br>所以LinkedList的遍历速度要慢于ArrayList的移动速度。</p>
<p>所以可以认为百万级别的增删，如果是在容器中间或中间以后的元素操作基本都是ArrayList快</p>
<h1 id="七、Set集合的各实现类"><a href="#七、Set集合的各实现类" class="headerlink" title="七、Set集合的各实现类"></a>七、Set集合的各实现类</h1><p>首先有3个，HashSet，TreeSet，LinkedHashSet</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>常用的应该是HashSet，底层实现是HashMap(<strong>由于LinkedHashSet继承自HashSet，所以底层实现也提供了一种LinkedHashMap的构造函数</strong>)，无论存储还是查询都具有很好性能。都可以根据元素的hash值快速的散列到所在桶的位置，然后进行相应的操作。同时由于HashMap在jdk1.8的时候把HashMap底层的实现换成了散列表+红黑树的方式。导致即便碰巧大量元素散列到一个桶上也不会出现链表特别长，遍历性能不好的情况。当链表数量超过8个时会自动将链表哦转化成红黑树(元素数大于64)，遍历时性能非常好。由于底层是HashMap实现，所以我们在迭代的时候调用iterator方法返回的其实是HashMap迭代时调用的keySet函数返回的Set集合的Iterator对象来进行迭代。HashMap底层会对所有的Key用一个Set集合来进行存储(不重)。对所有value用一个Collection来进行存储。</p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>TreeSet底层实现是TreeMap，即根据插入元素的自然排序或者自定义比较方式来比较插入元素的大小来决定其插入位置。进而形成一个有序的红黑树。TreeSet和TreeMap一样，插入的元素会有序的存储在一个红黑树上。根据我们制定的规则，或者元素的自然排序顺序。一般Tree系列的数据结构，我们用来保证一种有序性的数据结构才会用，存入到其中的元素必须实现Comparable或者Comparator接口来保证元素的可比较性。我们一般都是重写compareTo或者compare方法来制定自己的比较规则，让后续存到数据结构中的元素满足我们想要的顺序。</p>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>LinkedHashSet继承自HashSet，底层实现是LinkedHashMap即散列表和双向链表。HashSet也为LinkedHashSet提供了一个构造LinkedHashMap的构造函数，但需要注意的是，HashSet只为LinkedHashSet提供了一种只有<code>initialCapacity</code>和<code>loadFactor</code>的构造函数，也就意味着LinkedHashSet的元素无法像LinkedHashMap那样具有两种迭代顺序，又由于默认LinkedHashMap的迭代顺序是元素的插入顺序，所以它一般的作用就是用来保证元素的存储顺序和我们插入元素的顺序一致。这样我们在迭代获取元素的时候有一个预估值和期望值。</p>
<p>HashSet各方面性能好，不用排序一般用它，也是因为HashMap的优势。TreeSet一般用在比较根据元素进行排序的时候，LinkedHashSet则是用到我们要元素的插入顺序的时候。</p>
<h1 id="八、Map集合及实现类"><a href="#八、Map集合及实现类" class="headerlink" title="八、Map集合及实现类"></a>八、Map集合及实现类</h1><p>首先有3个，HashMap，TreeMap，LinkedHashMap。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>最常用的一般是HashMap，底层实现是散列表+单链表+红黑树。从性能上来讲，无论增删还是查都可以根据传入的key值快速定位到元素所在的桶。并且桶的数据结构也对大量hash碰撞的特殊情况做了优化，单链表元素数超过8采用红黑树存储。允许使用null做键值。迭代的时候有三种方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1.</div><div class="line">for (Entry&lt;String, String&gt; entry : map.entrySet())</div><div class="line"></div><div class="line">2.</div><div class="line">for (String keys : map.keySet())</div><div class="line"></div><div class="line">3.</div><div class="line">Iterator&lt;String&gt; keys = map.keySet().iterator();</div><div class="line">while (keys.hasNext())&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第一种调用的是<code>HashIterator</code>。根据散列表的数组下标来进行迭代。</li>
<li>第二种和第三种其实是一样的。<code>keySet()</code>返回的KeySet类继承自<code>AbstractSet</code>，在<code>foreach</code>迭代的时候会自动调用该类的<code>iterator()</code>方法，返回<code>KeyIterator</code>类，而这个类又继承自<code>HashIterator</code>类。只是实现了<code>next()</code>方法，但函数内也还是调用了<code>HashIterator</code>类的<code>nextNode()</code>方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final class KeyIterator extends HashIterator</div><div class="line">    implements Iterator&lt;K&gt; &#123;</div><div class="line">    public final K next() &#123; return nextNode().key; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap是TreeSet的底层实现。底层数据结构式红黑树，实现了SortedMap接口，该映射是根据其键的自然顺序进行排序的，或者根据在构建TreeMap时传入的Comparator来进行排序。<strong>需要注意</strong>，存入的元素必须实现了Comparable接口或者其类型被指定的Comparator所接受。而且比较的对象参数不能为null。在使用这种数据结构的时候我们要注的除了是元素需要具有可比性，同时我们还需要注意元素具体的比较规则，即元素的类重写的compare方法和compareTo方法的比较逻辑。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap是LinkedHashSet的底层实现，继承自HashMap，底层数据结构是散列表+单链表+红黑树+双向链表。所以和HashMap一样无论增删还是查找元素都具有极高的性能。不同的是迭代元素的方式。HashMap是通过迭代每一个“桶”来进行的迭代，迭代时获取的Entry都是未知的。而LinkedHashMap则默认是通过节点的插入顺序来进行迭代，或者通过节点的最近最少来进行迭代。之所以可以如此，是因为LinkedHashMap扩展了HashMap的<code>Node</code>节点。LinkedHashMap的Entry节点比其多维护两个指针变量。分别指向该节点的前驱和后继节点，所以比HashMap可以多维护一个双向链表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * HashMap.Node subclass for normal LinkedHashMap entries.</div><div class="line"> */</div><div class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</div><div class="line">    Entry&lt;K,V&gt; before, after;</div><div class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        super(hash, key, value, next);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LinkedHashMap默认是按key的插入顺序来排序，也可以通过在构造时通过指定accessOrder为true来使其按元素的LRU顺序来排序，在其迭代的时候可以看出它的元素排列顺序。</p>
<p>LinkedHashMap不允许存储的元素的key值为null。两种比较方式都不支持。元素在插入到红黑树的时候肯定会与其他树中的节点进行比较，此时会报错。</p>
<p>参考：<a href="https://www.cnblogs.com/acm-bingzi/p/javaMap.html" target="_blank" rel="external">HashMap,LinkedHashMap,TreeMap的区别</a></p>
<h1 id="九、Enumeration和Iterator接口的区别"><a href="#九、Enumeration和Iterator接口的区别" class="headerlink" title="九、Enumeration和Iterator接口的区别"></a>九、Enumeration和Iterator接口的区别</h1><p>Enumeration最早出来主要是针对当时所有的集合类的如Vector和HashTable的。但是由于原本Vector与Hashtable设计上的问题，以及Enumeration在设计上的一些缺陷到之后来出现了Iterator替代了它。</p>
<p>并且Iterator支持所有集合类。并对Enumeration进行了扩展，<strong>1. 添加了一个可选择的删除操作</strong>。并且在<strong>2. 函数命名上也更加科学，简洁了</strong>。同时Iterator也在并发操作的时候针对其实现类在并发情况下可能出现的<strong>3.并发修改问题利用<code>fail-fast</code>机制进行补足</strong>。Enumeration由于本身针对的就是并发情况下同步的类Vector和HashTable所以不存在并发上的问题。 </p>
<h1 id="十、ListIterator的特点"><a href="#十、ListIterator的特点" class="headerlink" title="十、ListIterator的特点"></a>十、ListIterator的特点</h1><p>我们前面说到Enumeration最早吹来是服务于Vector和HashTable来进行遍历的。后来Iterator的出现替代了它，但是对应不同的集合类迭代方式也不尽相同。所以ListIterator继承自Iterator，看类名就知道他是负责List集合的迭代的。</p>
<ul>
<li>继承自Iterator接口，用于遍历List集合的元素。</li>
<li>可以实现双向遍历。添加元素。设置元素</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-93032cdbb49e083c?imageMogr2/auto-orient/strip%7CimageView2/2/w/552" alt=""></p>
<h1 id="十一、Java中HashMap的key值要是为类对象则该类需要满足什么条件？"><a href="#十一、Java中HashMap的key值要是为类对象则该类需要满足什么条件？" class="headerlink" title="十一、Java中HashMap的key值要是为类对象则该类需要满足什么条件？"></a>十一、Java中HashMap的key值要是为类对象则该类需要满足什么条件？</h1><p><strong>需要同时重写该类的hashCode()方法和它的equals()方法。</strong></p>
<p>因为HashMap在插入元素的时候在<code>put</code>函数中就会向调用的<code>putVal</code>函数传递key的hash值。然后<code>putVal</code>函数再对key的哈希值进行散列，找到对应的桶。既然这样，那和重写对象到的hashcode有什么关系呢？</p>
<p>那是因为我们的对象做为key来存到hashMap中的话，我们最后肯定是根据key来获取到对应的value。而这个entry又存储在桶中，我们要想找到对应的桶，对于HashMap函数来说只能通过对象的hashcode值来进行散列，散列到对应的桶上。但是我们存储和取出的时候其实用的是两个对象(两次都会new新的对象)。但是两个对象具有相同的属性值。</p>
<p>如果我们不重写对象的hashcode的函数的话，去更改他hash值的生成策略的话是无法散列到对应的桶的(根据对象地址生成的hash值)。也就无法取出我们存进去的值。所以我们需要重写它的hashcode函数让它生成是只需要根据对象的属性进行生成即可，这样下次我们无论穿进去这个类的哪个对象，只要它保证我们指定的生成hashcode参考的属性相等即可。equals函数就更不用说了，Object类的equals默认比较的是两个对象的地址。而对我们开发来说这样的意义并不大。一般来说我们认为只要两个对象的成员变量的值是相等的，那么我们就认为这两个对象是相等的！</p>
<p>显然hashcode相比于equals函数具偶然性。在hashmap元素的比较中也是把hash值得比较前置了。因为hashcode可能在一些情况下出现hash碰撞相等的情况。所以我们重写equals函数前必须先重写hashcode函数，这样既保证了正确性，也在性能上得到了提升。</p>
<h1 id="十二、与Java集合框架相关的有哪些最好的实践"><a href="#十二、与Java集合框架相关的有哪些最好的实践" class="headerlink" title="十二、与Java集合框架相关的有哪些最好的实践"></a>十二、与Java集合框架相关的有哪些最好的实践</h1><ol>
<li>根据需要确定集合的类型。如果是单列的集合，我们考虑用Collection下的子接口ArrayList和Set。如果是映射，我们就考虑使用Map</li>
<li>确定完我们的集合类型，我们接下来确定使用该集合类型下的哪个子类~我认为可以简单分成几个步骤：</li>
</ol>
<ul>
<li><p>是否需要同步</p>
<ul>
<li>找线程安全的集合类使用</li>
</ul>
</li>
<li><p>迭代时是否需要有序(插入顺序有序)</p>
<ul>
<li>找Linked双向列表结构的</li>
</ul>
</li>
<li>是否需要排序(自然顺序或者手动排序)<ul>
<li>找Tree红黑树类型的(JDK1.8)</li>
</ul>
</li>
</ul>
<ol>
<li>估算存放集合的数据量有多大，无论是List还是Map，它们实现动态增长，都是有性能消耗的。在初始集合的时候给出一个合理的容量会减少动态增长时的消耗</li>
<li>使用泛型，避免在运行时出现ClassCastException</li>
<li>尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的工具函数。它提供了我们常用的针对List集合的功能函数，具有很高的重用性，以及更好的稳定性和可维护性。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、ArrayList和Vector的区别&quot;&gt;&lt;a href=&quot;#一、ArrayList和Vector的区别&quot; class=&quot;headerlink&quot; title=&quot;一、ArrayList和Vector的区别&quot;&gt;&lt;/a&gt;一、ArrayList和Vector的区别&lt;/h1&gt;&lt;p&gt;共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;都实现了List接口继承了AbstractList接口&lt;/li&gt;
&lt;li&gt;底层实现都是数组。所以说都是存储有序的集合&lt;/li&gt;
&lt;li&gt;允许存储null&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ArrayList是线程不安全的，Vector则是线程安全的，即便我们需要线程安全的数组容器也是会选择ArrayList，只是在初始化的时候通过&lt;code&gt;Collections&lt;/code&gt;集合类的工具类来进行包装一下。因为这种同步实现更科学&lt;/li&gt;
&lt;li&gt;扩容时ArrayList扩容系数为1.5，Vector则是2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Set集合了解一下</title>
    <link href="http://www.jiyongguang.xin/set.html"/>
    <id>http://www.jiyongguang.xin/set.html</id>
    <published>2018-05-24T09:52:00.000Z</published>
    <updated>2018-05-24T09:53:22.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文使用用的是jdk1.8</p>
</blockquote>
<h1 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h1><p>我们前面再Collection集合的文章中已经简单的说过Set集合的特点。</p>
<ul>
<li>不包含重复元素，即两个元素<code>e1.equals(e2)</code>不可相等。</li>
</ul>
<p>需要注意的是：</p>
<p>当可变对象存储到Set集合中的时候，如果通过一种可以影响对象的<code>equals</code>函数的比较结果的方式改变了该对象的话那么Set集合的行为则是不确定的。</p>
<a id="more"></a>
<h1 id="Set-集合的常见实现类"><a href="#Set-集合的常见实现类" class="headerlink" title="Set 集合的常见实现类"></a>Set 集合的常见实现类</h1><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-24/57257470.jpg" alt=""></p>
<ul>
<li>HashSet：底层是通过HashMap来实现的，所以底层数据结构式是 散列表+红黑树 的数据结构。</li>
<li>TreeSet：底层数据结构是通过NavigableMap来实现的，底层数据结构是 红黑树。可保证元素的排列方式</li>
<li>LinkedHashSet：继承自HashSet，和LinkedHashMap意义相似，底层数据结构是 散列表+双向链表</li>
</ul>
<h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p><img src="https://upload-images.jianshu.io/upload_images/5291509-a5da10a283e6d1fc" alt=""></p>
<p>总的来说：</p>
<ul>
<li>实现了Set接口，底层其实是一个HashMap实例，所以由于HashMap的特性，无法保证元素的迭代的顺序(HashMap扩容后的重散列会导致元素存储位置的变更)。同时和HashMap一样可以使用null元素做键值，但只能是一个。</li>
<li>对Set结合进行迭代所需的时间与HashSet实例的大小(元素的数量)和底层HashMap实例（桶的数量）的“容量”的和成比例。如果某个Set的迭代性能比较重要，不要将初始容量设置的太高，或者将加载因子设置的太小(会出现很多空桶)。</li>
<li>非同步，并发不安全。可以程序外部手动同步，也可以借助<code>Collections.synchronizedSet</code>函数来对该Set集合进行包装来实现同步。</li>
<li>迭代器是快速失败的</li>
</ul>
<h2 id="HashSet的属性及函数"><a href="#HashSet的属性及函数" class="headerlink" title="HashSet的属性及函数"></a>HashSet的属性及函数</h2><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-24/98627760.jpg" alt=""></p>
<p>一眼看上去还是很简单的。只有两个属性，一个是它具体实现类HsahMap，另一个则是一个Object实例。这个Object实例在这里是充当HashMap实例中所有元素的公共value的。因为我们HashSet底层是通过HashMap来实现的，所有元素实际都存储在key中，那么所对应的value如果不赋值则是null值得存在。所以HashSet的处理方式就是将所有元素的value都赋予该Object实例。</p>
<p>所以整个HashSet整体上来说几乎所有的操作都是在底层操作了一个HashMap实例。根据上图我们来看一下HashSet所实现的Set接口的函数都是怎么实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line">    return map.put(e, PRESENT)==null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void clear() &#123;</div><div class="line">    map.clear();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean contains(Object o) &#123;</div><div class="line">    return map.containsKey(o);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Iterator&lt;E&gt; iterator() &#123;</div><div class="line">    return map.keySet().iterator();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean remove(Object o) &#123;</div><div class="line">    return map.remove(o)==PRESENT;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public int size() &#123;</div><div class="line">    return map.size();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的构造函数所做的也是统一的初始化HashMap的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public HashSet() &#123;</div><div class="line">    map = new HashMap&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public HashSet(Collection&lt;? extends E&gt; c) &#123;</div><div class="line">    map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</div><div class="line">    addAll(c);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public HashSet(int initialCapacity, float loadFactor) &#123;</div><div class="line">    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public HashSet(int initialCapacity) &#123;</div><div class="line">    map = new HashMap&lt;&gt;(initialCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</div><div class="line">    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p><img src="https://upload-images.jianshu.io/upload_images/5291509-4f5201bf2d02610f" alt=""></p>
<p>总的来说：</p>
<ul>
<li><strong>底层实现</strong>：和HashSet实现方式一样，底层其实是由一个TreeMap实例来实现的。并实现了NavigableSet接口，是一个基于TreeMap的NavigableSet的实现</li>
<li><strong>有序</strong>：由于实现的NavigableSet接口继承自SortedSet接口，所以存入TreeSet的所有元素都必须是实现了Comparable接口的，即保证这些元素在存入TreeSet的时候在通过<code>compareTo</code>函数进行比较并自然排序的时候不会报ClassCastException。或者也可以在Set实例构造的时候通过传入的 Comparator来进行控制排序。</li>
<li><strong>非同步</strong>：并发线程不安全。还是老样子，倘若想同步需要函数外手动进行控制，或者在创建Set集合的时候借助<code>Collections</code>类。<code>Collections.synchronizedSortedSet</code>的方法来对某个Set集合进行包装。</li>
<li><strong>迭代器</strong>：迭代器是快速失败的</li>
<li><strong>复杂度</strong>：基本操作函数如<code>add</code>,<code>remove</code>,<code>contains</code>的复杂度都是<code>log(n)</code>级别的(TreeMap底层红黑树)。</li>
</ul>
<h2 id="TreeSet的属性和函数"><a href="#TreeSet的属性和函数" class="headerlink" title="TreeSet的属性和函数"></a>TreeSet的属性和函数</h2><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-24/82184932.jpg" alt=""></p>
<p>从图可以很明显的看出它的实现机制和HashSet是一模一样的。底层通过NavigableMap来实现，而NavigableMap则只有TreeMap这一个实现类。我们也可以称之为底层是由TreeMap来实现的，而Object实例则是充当所有元素的value的存在。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-24/65314809.jpg" alt=""></p>
<p>我们来看一下TreeSet的5个构造函数都是如何实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public TreeSet() &#123;</div><div class="line">    this(new TreeMap&lt;E,Object&gt;());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public TreeSet(Collection&lt;? extends E&gt; c) &#123;</div><div class="line">    this();</div><div class="line">    addAll(c);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public TreeSet(Comparator&lt;? super E&gt; comparator) &#123;</div><div class="line">    this(new TreeMap&lt;&gt;(comparator));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</div><div class="line">    this.m = m;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public TreeSet(SortedSet&lt;E&gt; s) &#123;</div><div class="line">    this(s.comparator());</div><div class="line">    addAll(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还是清晰的。都是通过构造一个TreeMap来实现整个TreeSet的所有操作的。</p>
<h1 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h1><p><img src="https://upload-images.jianshu.io/upload_images/5291509-ef97413d197b91c6?imageMogr2/auto-orient/" alt=""></p>
<p>总的来说：</p>
<ul>
<li><strong>实现</strong>：LinkedHashSet底层由散列表和双向链表来实现的。这一点和LinkedHashMap一样。LinkedHashSet由HashSet和LinkedList共同来实现的。底层是HashMap，只是各节点Entry另外的还添加了两个属性before和after，通过双向列表来链接。</li>
<li><strong>迭代</strong>：迭代有序，由于所有元素都通过LinkedeList双向链表来维护，所以将按照元素插入到set中的顺序（插入顺序）进行迭代。需要注意的是如果一个元素已经存在于LinkedHashSet中如果再插入该元素的话，该元素会被重新插入。并且迭代的时候和HashSet容量没有关系。因为它结构中维护的一个双向链表，迭代的时候是迭代这个双向链表。相比于此HashSet迭代时则要受到容器容量很大的限制。</li>
<li><strong>优点</strong><ul>
<li>使用LinkedHashSet可以不用像HashSet一样元素杂乱无序，而保证元素一定的有序性，可以做到TreeSet的功能却不用TreeSet的成本。</li>
<li>初始容量的大小对LinkedHasSet的影响要比对HashSet小很多，因为它在迭代的时候不受容器大小的影响。</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>性能比HashSet要差一点儿，因为还要维护一个双向链表。</li>
</ul>
</li>
<li>允许null。非同步的，迭代是快速失败的</li>
</ul>
<h2 id="LinkedHashSet的属性和函数"><a href="#LinkedHashSet的属性和函数" class="headerlink" title="LinkedHashSet的属性和函数"></a>LinkedHashSet的属性和函数</h2><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-24/95385351.jpg" alt=""></p>
<p>很纯粹的类，没有自己实现的东西。所有的函数都是继承自各个父类</p>
<p>我们来看一下它的构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public LinkedHashSet(int initialCapacity, float loadFactor) &#123;</div><div class="line">    super(initialCapacity, loadFactor, true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public LinkedHashSet(int initialCapacity) &#123;</div><div class="line">    super(initialCapacity, .75f, true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public LinkedHashSet() &#123;</div><div class="line">    super(16, .75f, true);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;</div><div class="line">    super(Math.max(2*c.size(), 11), .75f, true);</div><div class="line">    addAll(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，都是去构造其父类HashSet。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到整个Set集合的实现都是Map映射。</p>
<ul>
<li>HashSet：无序，允许为null，底层是HashMap(散列表+红黑树)，非线程同步</li>
<li>TreeSet：有序，不允许为null，底层是TreeMap(红黑树)，非线程同步</li>
<li>LinkedHashSet：迭代有序，允许为null，底层是HashMap+双向链表，非线程同步</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文使用用的是jdk1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Set-接口&quot;&gt;&lt;a href=&quot;#Set-接口&quot; class=&quot;headerlink&quot; title=&quot;Set 接口&quot;&gt;&lt;/a&gt;Set 接口&lt;/h1&gt;&lt;p&gt;我们前面再Collection集合的文章中已经简单的说过Set集合的特点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不包含重复元素，即两个元素&lt;code&gt;e1.equals(e2)&lt;/code&gt;不可相等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是：&lt;/p&gt;
&lt;p&gt;当可变对象存储到Set集合中的时候，如果通过一种可以影响对象的&lt;code&gt;equals&lt;/code&gt;函数的比较结果的方式改变了该对象的话那么Set集合的行为则是不确定的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>ConCurrentHashMap了解一下</title>
    <link href="http://www.jiyongguang.xin/conCurrentHashMap.html"/>
    <id>http://www.jiyongguang.xin/conCurrentHashMap.html</id>
    <published>2018-05-18T04:43:31.000Z</published>
    <updated>2018-05-18T04:45:39.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本人使用的是jdk1.8</p>
</blockquote>
<h1 id="ConcurrentHashMap-1-7"><a href="#ConcurrentHashMap-1-7" class="headerlink" title="ConcurrentHashMap 1.7"></a>ConcurrentHashMap 1.7</h1><p>首先我们来回顾一下在jdk1.7当中ConcurrentHashMap是如何实现的。</p>
<p>还在jdk1.7的时候ConcurrentHashMap的底层数据结构其实是由<code>Segment</code>数组和多个<code>HashEntry</code>组成。如图：</p>
<p><img src="http://pettyandydog.com/images/ConcurrentHashMap/1.png" alt=""></p>
<a id="more"></a>
<p>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的锁分段技术，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的散列表+链表的数据存储结构是一样的。这里的每个table就像我们之前所说的HashTable一样。</p>
<p>不同于HashTable为了并发情况下的安全性锁整个table那么暴力不同，ConcurrentHashMap的处理方式则是对其进行了优化，是把一个大table分割成小table来分别锁住。也就是我们常说的锁分段。</p>
<p>同时从源码中我们可以看出，Segment继承了ReentrantLock(独占锁)类。使大table中的每个小table都有了一个锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable</div></pre></td></tr></table></figure></p>
<h1 id="ConcurrentHashMap-1-8"><a href="#ConcurrentHashMap-1-8" class="headerlink" title="ConcurrentHashMap 1.8"></a>ConcurrentHashMap 1.8</h1><p>在jdk1.8中，ConCurrentHashMap的数据结构底层是：散列表+链表+红黑树，其变化与HashMap在1.8的变化是一样的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-c1aa9927caf5b23a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<h1 id="ConcurrentHashMap头注释信息"><a href="#ConcurrentHashMap头注释信息" class="headerlink" title="ConcurrentHashMap头注释信息"></a>ConcurrentHashMap头注释信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A hash table supporting full concurrency of retrievals and</div><div class="line"> * high expected concurrency for updates. This class obeys the</div><div class="line"> * same functional specification as &#123;@link java.util.Hashtable&#125;, and</div><div class="line"> * includes versions of methods corresponding to each method of</div><div class="line"> * &#123;@code Hashtable&#125;. However, even though all operations are</div><div class="line"> * thread-safe, retrieval operations do &lt;em&gt;not&lt;/em&gt; entail locking,</div><div class="line"> * and there is &lt;em&gt;not&lt;/em&gt; any support for locking the entire table</div><div class="line"> * in a way that prevents all access.  This class is fully</div><div class="line"> * interoperable with &#123;@code Hashtable&#125; in programs that rely on its</div><div class="line"> * thread safety but not on its synchronization details.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Retrieval operations (including &#123;@code get&#125;) generally do not</div><div class="line"> * block, so may overlap with update operations (including &#123;@code put&#125;</div><div class="line"> * and &#123;@code remove&#125;). Retrievals reflect the results of the most</div><div class="line"> * recently &lt;em&gt;completed&lt;/em&gt; update operations holding upon their</div><div class="line"> * onset. (More formally, an update operation for a given key bears a</div><div class="line"> * &lt;em&gt;happens-before&lt;/em&gt; relation with any (non-null) retrieval for</div><div class="line"> * that key reporting the updated value.)  For aggregate operations</div><div class="line"> * such as &#123;@code putAll&#125; and &#123;@code clear&#125;, concurrent retrievals may</div><div class="line"> * reflect insertion or removal of only some entries.  Similarly,</div><div class="line"> * Iterators, Spliterators and Enumerations return elements reflecting the</div><div class="line"> * state of the hash table at some point at or since the creation of the</div><div class="line"> * iterator/enumeration.  They do &lt;em&gt;not&lt;/em&gt; throw &#123;@link</div><div class="line"> * java.util.ConcurrentModificationException ConcurrentModificationException&#125;.</div><div class="line"> * However, iterators are designed to be used by only one thread at a time.</div><div class="line"> * Bear in mind that the results of aggregate status methods including</div><div class="line"> * &#123;@code size&#125;, &#123;@code isEmpty&#125;, and &#123;@code containsValue&#125; are typically</div><div class="line"> * useful only when a map is not undergoing concurrent updates in other threads.</div><div class="line"> * Otherwise the results of these methods reflect transient states</div><div class="line"> * that may be adequate for monitoring or estimation purposes, but not</div><div class="line"> * for program control.</div><div class="line"> *</div><div class="line"> * ······</div><div class="line"> * ······</div><div class="line"> */</div></pre></td></tr></table></figure>
<p>从头注释中我们可以知道：</p>
<ul>
<li>ConcurrentHashMap支持高并发情况下对哈希表的访问和更新。</li>
<li>ConcurrentHashMap与HashTable相似，与HashMap不同。</li>
<li>ConcurrentHashMap的所有操作都是线程安全的。</li>
<li>它不允许null用作键或值</li>
<li>get操作没有上锁。是非阻塞的。所以在并发情况下可以与阻塞的put或remove函数交迭。但在聚合操作下比如putAll和clean，并发情况下由于线程调度的原因get函数可能只能检索到插入和删除的一些Entries(函数还未执行完)。<ul>
<li>与get函数的处理相类似的还有<code>Iterators, Spliterators,Enumerations</code>，在其创建时或之后，倘若ConcurrentHashMap再发生改变就不会再抛<code>ConcurrentModificationException</code>了。取而代之的是在其改变时new新的数据从而不影响原有的数据，Iterator会在其完成后再将头指针替换为新的数据，这样Iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是<strong>性能提升</strong>的关键。</li>
<li>不过，迭代器被设计成每次仅由一个线程使用。</li>
</ul>
</li>
<li>同时需要注意：<code>size,isEmpty,containsValue</code>等函数的使用，在ConcurrentHashMap实例并发情况下是无意义的。它只能反映该实例的一个暂态，除非此时它并未发生并发修改。</li>
</ul>
<h1 id="ConcurrrentHashMap关键属性"><a href="#ConcurrrentHashMap关键属性" class="headerlink" title="ConcurrrentHashMap关键属性"></a>ConcurrrentHashMap关键属性</h1><p>由于ConcurrentHashMap的属性众多，我们挑几个典型关键的来进行分析。</p>
<ul>
<li><code>volatile Node&lt;K,V&gt;[] table</code>：装载Node的数组，作为ConcurrentHashMap的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为2的幂次方。</li>
<li><code>transient volatile Node&lt;K,V&gt;[] nextTable</code>：扩容时使用，平时为null，只有在扩容的时候才为非null</li>
<li><code>transient volatile long baseCount</code>：元素数量基础计数器，该值也是一个阶段性的值(产出的时候可能容器正在被修改)。通过<code>CAS</code>的方式进行更改。</li>
<li><code>transient volatile int sizeCtl</code>：散列表初始化和扩容的大小都是由该变量来控制。<ul>
<li>当为负数时，它正在被初始化或者扩容。<ul>
<li>-1表示正在初始化</li>
<li>-N表示N-1个线程正在扩容</li>
</ul>
</li>
<li>当为整数时，<ul>
<li>此时如果当前table数组为null的话表示table正在初始化过程中，sizeCtl表示为需要新建的数组的长度，默认为0</li>
<li>若已经初始化了,表示当前数据容器（table数组）可用容量也可以理解成临界值（插入节点数超过了该临界值就需要扩容）,具体指为数组的长度n 乘以 加载因子loadFactor。 当值为0时，即数组长度为默认初始值。</li>
</ul>
</li>
</ul>
</li>
<li><code>static final sun.misc.Unsafe U</code>：在ConcurrentHashMapde的实现中可以看到大量的U.compareAndSwapXXXX的方法去修改ConcurrentHashMap的一些属性。这些方法实际上是利用了CAS算法保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突(变量实际值!=期望值)，当且仅当冲突发生的时候再去尝试。<ul>
<li>在大量的同步组件和并发容器的实现中使用CAS是通过<code>sun.misc.Unsafe</code>类实现的。该类提供了一些可以直接操控内存和线程的底层操作，可以理解为java中的“指针”。该成员变量的获取是在静态代码块中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static &#123;</div><div class="line">    try &#123;</div><div class="line">        U = sun.misc.Unsafe.getUnsafe();</div><div class="line">        ······</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        throw new Error(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>CAS操作依赖于现代处理器指令集，通过底层<code>CMPXCHG</code>指令实现。CAS(V,O,N)核心思想为：若当前变量实际值V与期望的旧值O相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值N赋值给变量；若当前变量实际值V与期望的旧值O不相同，则表明该变量已经被其他线程做了处理，此时将新值N赋给变量操作就是不安全的，再进行重试。</p>
<h1 id="ConcurrentHashMap为何存在"><a href="#ConcurrentHashMap为何存在" class="headerlink" title="ConcurrentHashMap为何存在"></a>ConcurrentHashMap为何存在</h1><p>我们知道由于HashMap在多线程情况下是线程不安全的。而和其对应的HashTable虽然是线程安全的，但是却是十分极端的在所有涉及多线程的操作上都加上了synchronized关键字来锁住整个table。这就意味着在多线程情况下，所有的线程都在竞争同一把锁。虽然是线程安全的，但是却无疑是效率低下的。</p>
<p>其实HashTable有很多的优化空间，锁住整个table这么粗暴的方法可以变相的柔和点，比如在多线程的环境下，对不同的数据集进行操作时其实根本就不需要去竞争一个锁，因为他们不同hash值，不会因为rehash造成线程不安全，所以互不影响，这就是锁分离技术，将锁的粒度降低，利用多个锁来控制多个小的table，这就是ConcurrentHashMap的核心思想</p>
<p>总而言之：</p>
<ul>
<li>Hashtable是在每个方法上都加上了Synchronized完成同步，效率低下。</li>
<li>ConcurrentHashMap通过在部分加锁和利用CAS算法来实现同步。</li>
</ul>
<h1 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h1><p>上面我们提到ConcurrentHashMap是通过CAS算法来实现同步的。接下来我们就简单了解一下什么是CAS算法</p>
<h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h3><p>CAS: 全称Compare and swap，字面意思:”比较并交换“，一个 CAS 涉及到以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">我们假设内存中的原数据V，旧的预期值A，需要修改的新值B。</div><div class="line"></div><div class="line">比较 A 与 V 是否相等。（比较）</div><div class="line">如果比较相等，将 B 写入 V。否则什么都不做（交换）</div><div class="line">返回操作是否成功。</div></pre></td></tr></table></figure>
<ul>
<li>当多个线程尝试使用CAS同时更新同一个变量的时候，只有其中一个线程能够更新变量的值。当其他线程失败后，不会像获取锁一样被挂起，而是可以再次尝试，或者不进行任何操作，这种灵活性就大大减少了锁活跃性风险。</li>
</ul>
<p>我们知道采用锁对共享数据进行处理的话，当多个线程竞争的时候，都需要进行加锁，没有拿到锁的线程会被阻塞，以及唤醒，这些都需要用户态到核心态的转换，这个代价对阻塞线程来说代价还是蛮高的，那cas是采用无锁乐观方式进行竞争，性能上要比锁更高些才是，为何不对锁竞争方式进行替换？</p>
<p>在高度竞争的情况下，锁的性能将超过cas的性能，但在中低程度的竞争情况下，cas性能将超过锁的性能。多数情况下，资源竞争一般都不会那么激烈。</p>
<p>参考：<a href="https://mp.weixin.qq.com/s/l3wSUgWT60lkXwoTUNK4TQ" target="_blank" rel="external">java多线程——CAS</a></p>
<h1 id="ConcurrentHashMap构造函数"><a href="#ConcurrentHashMap构造函数" class="headerlink" title="ConcurrentHashMap构造函数"></a>ConcurrentHashMap构造函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">// 构造一个空map映射，初始容量16</div><div class="line">public ConcurrentHashMap() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 初始化时明确给定一个初始容量，减少resize次数</div><div class="line">public ConcurrentHashMap(int initialCapacity) &#123;</div><div class="line">    if (initialCapacity &lt; 0)</div><div class="line">        throw new IllegalArgumentException();</div><div class="line">    // tableSizeFor 函数返回一个最接近入参 initialCapacity 容量的2进制整数</div><div class="line">    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</div><div class="line">               MAXIMUM_CAPACITY :</div><div class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));</div><div class="line">    this.sizeCtl = cap;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 创建一个与给定的 Map 映射具有相同元素的 ConcurrentHashMap</div><div class="line">public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</div><div class="line">    // 我们前面所述 sizeCtl 两个含义，构造和扩容。</div><div class="line">    // 此处必然是构造容量为 DEFAULT_CAPACITY = 16 的 ConcurrentHashMap</div><div class="line">    this.sizeCtl = DEFAULT_CAPACITY;</div><div class="line">    putAll(m);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;</div><div class="line">    // 初始化数组容量，防止直接迭代insert导致频繁扩容</div><div class="line">    tryPresize(m.size());</div><div class="line">    for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</div><div class="line">        putVal(e.getKey(), e.getValue(), false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 构造一个空的 Map 映射，并给定其初始容量与加载因子</div><div class="line">public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</div><div class="line">    this(initialCapacity, loadFactor, 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 构造一个空的 Map 映射，并给定其初始容量，加载因子与预估的并发更新的线程数</div><div class="line">public ConcurrentHashMap(int initialCapacity,</div><div class="line">                         float loadFactor, int concurrencyLevel) &#123;</div><div class="line">    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</div><div class="line">        throw new IllegalArgumentException();</div><div class="line">    if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins</div><div class="line">        // 该情况下，一个更新线程负责一个HashEntry</div><div class="line">        initialCapacity = concurrencyLevel;   // as estimated threads</div><div class="line">    // 确定 table 的初始容量 = 初始容量 initialCapacity / 元素密度 loadFactor</div><div class="line">    // 比如你有30个元素，构造Map的时候传入30和0.75，那么table真实容量就应该是 30/0.75。保证你元素数量是table容器的0.75倍</div><div class="line">    long size = (long)(1.0 + (long)initialCapacity / loadFactor);</div><div class="line">    int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?</div><div class="line">        MAXIMUM_CAPACITY : tableSizeFor((int)size);</div><div class="line">    this.sizeCtl = cap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的就是最后一个构造函数中引用的<code>tableSizeFor</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Returns a power of two table size for the given desired capacity.</div><div class="line"> * See Hackers Delight, sec 3.2</div><div class="line"> */</div><div class="line">private static final int tableSizeFor(int c) &#123;</div><div class="line">    int n = c - 1;</div><div class="line">    n |= n &gt;&gt;&gt; 1;</div><div class="line">    n |= n &gt;&gt;&gt; 2;</div><div class="line">    n |= n &gt;&gt;&gt; 4;</div><div class="line">    n |= n &gt;&gt;&gt; 8;</div><div class="line">    n |= n &gt;&gt;&gt; 16;</div><div class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个2的幂次方数，也就是说ConcurrentHashMap的大小一定是2的幂次方，比如，当指定大小为18时，为了满足2的幂次方特性，实际上concurrentHashMapd的大小为2的5次方（32）。</p>
<p>另外，需要注意的是，调用构造器方法的时候并未构造出table数组（可以理解为ConcurrentHashMap的数据容器），只是算出table数组的长度，当第一次向ConcurrentHashMap插入数据的时候才真正的完成初始化创建table数组的工作。</p>
<h1 id="ConcurrentHashMap-常见Api解析"><a href="#ConcurrentHashMap-常见Api解析" class="headerlink" title="ConcurrentHashMap 常见Api解析"></a>ConcurrentHashMap 常见Api解析</h1><h2 id="initTable"><a href="#initTable" class="headerlink" title="initTable()"></a>initTable()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; int sc;</div><div class="line">    while ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">        if ((sc = sizeCtl) &lt; 0)</div><div class="line">			// 1. 保证只有一个线程正在进行初始化操作</div><div class="line">            Thread.yield(); // lost initialization race; just spin</div><div class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</div><div class="line">            try &#123;</div><div class="line">                if ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">					// 2. 得出数组的大小</div><div class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">					// 3. 这里才真正的初始化数组</div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">					// 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）</div><div class="line">                    sc = n - (n &gt;&gt;&gt; 2);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                sizeCtl = sc;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return tab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码的逻辑请见注释，有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化，在第1步中会先通过if进行判断，若当前已经有一个线程正在初始化即sizeCtl值变为-1，这个时候其他线程在If判断为true从而调用Thread.yield()让出CPU时间片。正在进行初始化的线程会调用U.compareAndSwapInt方法将sizeCtl改为-1即正在初始化的状态。</p>
<p>另外还需要注意的事情是，在第四步中会进一步计算数组中可用的大小即为数组实际大小n乘以加载因子0.75.可以看看这里乘以0.75是怎么算的，0.75为四分之三，这里n - (n &gt;&gt;&gt; 2)是不是刚好是n-(1/4)n=(3/4)n，挺有意思的吧:)。如果选择是无参的构造器的话，这里在new Node数组的时候会使用默认大小为DEFAULT_CAPACITY（16），然后乘以加载因子0.75为12，也就是说数组的可用大小为12。</p>
<h2 id="putVal-K-key-V-value-boolean-onlyIfAbsent"><a href="#putVal-K-key-V-value-boolean-onlyIfAbsent" class="headerlink" title="putVal(K key, V value, boolean onlyIfAbsent)"></a>putVal(K key, V value, boolean onlyIfAbsent)</h2><p>当且仅当table中不存在该key对应的Entry时才插入该Entry。否则不替换table中原有的Entry中的value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class="line">    if (key == null || value == null) throw new NullPointerException();</div><div class="line">    // 1. 计算key的hash值，与HashMap处理逻辑一样</div><div class="line">    int hash = spread(key.hashCode());</div><div class="line">    int binCount = 0;</div><div class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; int n, i, fh;</div><div class="line">        // 2. 如果当前table还没有初始化先调用initTable方法将tab进行初始化</div><div class="line">        if (tab == null || (n = tab.length) == 0)</div><div class="line">            tab = initTable();</div><div class="line">        // 3. tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可</div><div class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class="line">            if (casTabAt(tab, i, null,</div><div class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class="line">                break;                   // no lock when adding to empty bin</div><div class="line">        &#125;</div><div class="line">        /* 4. 如果要插入的位置是一个forwordingNode节点，表示正在扩容，那么当前线程帮助扩容</div><div class="line">        这里我有个问题：为什么该位置会是forwordingNode节点 */</div><div class="line">        else if ((fh = f.hash) == MOVED)</div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        else &#123;</div><div class="line">            V oldVal = null;</div><div class="line">            // 5. 进行到这一步，说明要插入的位置有值，需要对该桶加锁。</div><div class="line">            synchronized (f) &#123;</div><div class="line">                // 确定f是tab中的头节点</div><div class="line">                if (tabAt(tab, i) == f) &#123;</div><div class="line">                    // fh = 桶首元素的hast值。如果头结点的哈希值大于等于0，说明要插入的节点在(链表)中。否则有可能该桶的数据结构不是链表而是红黑树</div><div class="line">                    if (fh &gt;= 0) &#123;</div><div class="line">                        binCount = 1;</div><div class="line">                        // 开始迭代找key的节点，f = 桶首元素</div><div class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                            K ek;</div><div class="line">                            // 如果某一节点的key的哈希值及key与参数相等，替换该节点的value</div><div class="line">                            if (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                oldVal = e.val;</div><div class="line">                                if (!onlyIfAbsent)</div><div class="line">                                    e.val = value;</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            // 没有找到则继续向后迭代，当迭代到最后一个元素还没有找到时，将该Entry插入到链表尾。</div><div class="line">                            if ((e = e.next) == null) &#123;</div><div class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, null);</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    // 6. 如果要插入的节点在红黑树中，则按照树的方式插入或替换节点</div><div class="line">                    else if (f instanceof TreeBin) &#123;</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = 2;</div><div class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != null) &#123;</div><div class="line">                            oldVal = p.val;</div><div class="line">                            if (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // 7. 如果binCount不为0，说明插入或者替换操作完成了</div><div class="line">            if (binCount != 0) &#123;</div><div class="line">                // 判断节点数量是否大于等于8，如果是就需要把链表转化成红黑树</div><div class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                    // 链表转成红黑树 </div><div class="line">                    treeifyBin(tab, i);</div><div class="line">                if (oldVal != null)</div><div class="line">                    return oldVal;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 8. 对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容 </div><div class="line">    // 能执行到这一步，说明节点不是被替换的，是被插入的，否则在binCount判断 !=0 的时候就要被return了。</div><div class="line">    addCount(1L, binCount);</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; int sc;</div><div class="line">    while ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">        if ((sc = sizeCtl) &lt; 0)</div><div class="line">            Thread.yield(); // lost initialization race; just spin</div><div class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</div><div class="line">            try &#123;</div><div class="line">                if ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">                    sc = n - (n &gt;&gt;&gt; 2);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                sizeCtl = sc;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return tab;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整体流程下来就是：</p>
<ol>
<li>计算key哈希值</li>
<li>根据哈希值计算在table中的位置</li>
<li>根据哈希值执行插入或替换操作 <ol>
<li>如果这个位置没有值，直接将键值对放进去，不需要加锁。 </li>
<li>如果要插入的位置是一个forwordingNode节点，表示正在扩容，那么当前线程帮助扩容 </li>
<li>加锁。以下操作都需要加锁。 </li>
<li>如果要插入的节点在链表中，遍历链表中的所有节点，如果某一节点的key哈希值和key与参数相等，替换节点的value，记录被替换的值；如果遍历到了最后一个节点，还没找到key对应的节点，根据参数新建节点，插入链表尾部</li>
<li>如果要插入的节点在树中，则按照树的方式插入或替换节点。如果是替换操作，记录被替换的值</li>
</ol>
</li>
<li>判断节点数量是否大于8，如果大于就需要把链表转化成红黑树</li>
<li>如果操作3中执行的是替换操作，返回被替换的value。程序结束。</li>
<li>能执行到这一步，说明节点不是被替换的，是被插入的，所以要将map的元素数量加1。</li>
</ol>
<h2 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h2><p>据我们之前的类头注释所译。get函数没有必要加锁的。但是可以看到的是ConcurrentHashMap对其Node类的next属性加上了volatile关键字进行修饰。来保证并发情况下其他线程若正在与get函数同步的修改该节点的next属性，保证了它的可见性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</div><div class="line">    // 散列key</div><div class="line">    int h = spread(key.hashCode());</div><div class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</div><div class="line">        // 根据key的散列值h来找到桶头元素e</div><div class="line">        if ((eh = e.hash) == h) &#123;</div><div class="line">            // key相等值相等，则桶头元素刚好就是所找元素</div><div class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</div><div class="line">                return e.val;</div><div class="line">        &#125;</div><div class="line">        // 如果hash &lt; 0 那么在红黑树中</div><div class="line">        else if (eh &lt; 0)</div><div class="line">            return (p = e.find(h, key)) != null ? p.val : null;</div><div class="line">        // 在该桶的链表上，不是桶头元素上，迭代继续向下寻找</div><div class="line">        while ((e = e.next) != null) &#123;</div><div class="line">            if (e.hash == h &amp;&amp;</div><div class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</div><div class="line">                return e.val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整体流程：</p>
<p>首先先看当前的hash桶数组节点即table[i]是否为查找的节点，若是则直接返回；若不是，则继续再看当前是不是树节点？通过看节点的hash值是否为小于0，如果小于0则为树节点。如果是树节点在红黑树中查找节点；如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若查找到则返回节点的value即可，若没有找到就返回null。</p>
<h1 id="ConcurrrentHashMap关键类"><a href="#ConcurrrentHashMap关键类" class="headerlink" title="ConcurrrentHashMap关键类"></a>ConcurrrentHashMap关键类</h1><h2 id="Node内部类"><a href="#Node内部类" class="headerlink" title="Node内部类"></a>Node内部类</h2><p>Node类实现了Map.Entry接口，主要存放key-value对，并且具有next域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">     final int hash;</div><div class="line">     final K key;</div><div class="line">     volatile V val;</div><div class="line">     volatile Node&lt;K,V&gt; next;</div><div class="line"> 	......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外可以看出很多属性都是用volatile进行修饰的，也是为了保证并发情况下的该属性的可见性。同事对hash和key用final进行修饰也是提供了这两个常用变量的缓存，性能上有所提高。</p>
<h2 id="TreeNode-树节点"><a href="#TreeNode-树节点" class="headerlink" title="TreeNode 树节点"></a>TreeNode 树节点</h2><p>继承于承载数据节点Node类。而红黑树的操作是针对TreeBin类的，从该类的注释也可以看出，也就是TreeBin会将TreeNode进行再一次封装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</div><div class="line">    TreeNode&lt;K,V&gt; parent;  // red-black tree links</div><div class="line">    TreeNode&lt;K,V&gt; left;</div><div class="line">    TreeNode&lt;K,V&gt; right;</div><div class="line">    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</div><div class="line">    boolean red;</div><div class="line">    ······</div></pre></td></tr></table></figure></p>
<h2 id="TreeBin-树箱"><a href="#TreeBin-树箱" class="headerlink" title="TreeBin 树箱"></a>TreeBin 树箱</h2><p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</div><div class="line">    TreeNode&lt;K,V&gt; root;</div><div class="line">    volatile TreeNode&lt;K,V&gt; first;</div><div class="line">    volatile Thread waiter;</div><div class="line">    volatile int lockState;</div><div class="line">    // values for lockState</div><div class="line">    static final int WRITER = 1; // set while holding write lock</div><div class="line">    static final int WAITER = 2; // set when waiting for write lock</div><div class="line">    static final int READER = 4; // increment value for setting read lock</div><div class="line">    ····· 	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h2><p>在扩容时才会出现的特殊节点，其key,value,hash全部为null。并拥有nextTable指针引用新的table数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</div><div class="line">     final Node&lt;K,V&gt;[] nextTable;</div><div class="line">     ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</div><div class="line">         super(MOVED, null, null, null);</div><div class="line">         this.nextTable = tab;</div><div class="line">     &#125;</div><div class="line">    ······</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h1 id="CAS-关键操作"><a href="#CAS-关键操作" class="headerlink" title="CAS 关键操作"></a>CAS 关键操作</h1><p>我们之前说到，在ConcurrentHashMap中会有大量的CAS操作来修改它的一些属性和操作。所以先来看一些常用的CAS操作是如何保证线程安全的</p>
<h2 id="tabAt"><a href="#tabAt" class="headerlink" title="tabAt"></a>tabAt</h2><p>获取table数组中索引为i的Node元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</div><div class="line">    return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="casTabAt"><a href="#casTabAt" class="headerlink" title="casTabAt"></a>casTabAt</h2><p>利用CAS操作设置table数组中索引为i的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</div><div class="line">                                     Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</div><div class="line">     return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="compareAndSwapInt"><a href="#compareAndSwapInt" class="headerlink" title="compareAndSwapInt"></a>compareAndSwapInt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</div></pre></td></tr></table></figure>
<p>这是一个Native函数。函数的作用是修改当前类的var2属性。如果var2属性和var4属性一样的就修改，否则什么都不做。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>底层结构是散列表(数组+链表)+红黑树，这一点和HashMap是一样的。</li>
<li>Hashtable是将所有的方法进行同步，效率低下。而ConcurrentHashMap作为一个高并发的容器，它是通过synchronized+CAS算法来进行实现线程安全的。使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。<ul>
<li>采用synchronized而不是ReentrantLock。</li>
<li>CAS算法是乐观锁的一种</li>
</ul>
</li>
<li>ConcurrentHashMap的key和Value都不能为null</li>
<li>get方法是非阻塞，无锁的。重写Node类，通过volatile修饰next来实现每次获取都是最新设置的值。相比于在jdk1.7中的变化就是不采用segment而采用node，锁住node来实现减小锁粒度。</li>
<li>sizeCtl的不同值来代表不同含义，起到了控制的作用。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本人使用的是jdk1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;ConcurrentHashMap-1-7&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap-1-7&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap 1.7&quot;&gt;&lt;/a&gt;ConcurrentHashMap 1.7&lt;/h1&gt;&lt;p&gt;首先我们来回顾一下在jdk1.7当中ConcurrentHashMap是如何实现的。&lt;/p&gt;
&lt;p&gt;还在jdk1.7的时候ConcurrentHashMap的底层数据结构其实是由&lt;code&gt;Segment&lt;/code&gt;数组和多个&lt;code&gt;HashEntry&lt;/code&gt;组成。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pettyandydog.com/images/ConcurrentHashMap/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>TreeMap了解一下</title>
    <link href="http://www.jiyongguang.xin/treemap.html"/>
    <id>http://www.jiyongguang.xin/treemap.html</id>
    <published>2018-05-13T10:59:26.000Z</published>
    <updated>2018-05-13T11:02:19.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文使用用的是jdk1.8</p>
</blockquote>
<h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><p><img src="https://upload-images.jianshu.io/upload_images/5291509-23170e9abfcbc003.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<a id="more"></a>
<ul>
<li>基于红黑树的NavigableMap的实现。</li>
<li>TreeMap实现了NavigableMap接口，而NavigableMap接口继承着SortedMap接口，致使我们的TreeMap符合SotredMap接口的定义。TreeMap根据key自然顺序进行排序，或者在构造实例构造的时候传递 Comparator 进行自定义规则排序。</li>
<li>由于是实现自SortedMap，所以存入TreeMap的所有元素的key都必须是实现了Comparable接口的，即保证其key相互调用<code>k1.compareTo(k2)</code>的时候不会报<code>ClassCastException</code>。</li>
<li>containsKey、get、put 和 remove 函数的时间复杂度是<code>log(n)</code></li>
<li>有序映射使用它的compareTo（或compare）方法对所有键进行比较，只要这两个方法认为相等，那么在有序映射中的两个键就是相等的。</li>
<li>非同步的</li>
<li>此类方法返回的所有Entry是其真实的映射关系的快照。它们不支持Entry.setValue方法来更改值。不过put函数是可以的</li>
</ul>
<h1 id="TreeMap类继承图"><a href="#TreeMap类继承图" class="headerlink" title="TreeMap类继承图"></a>TreeMap类继承图</h1><p><img src="https://upload-images.jianshu.io/upload_images/5291509-977587904be97050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>实现了NavigableMap接口，而NavigableMap接口继承着SortedMap接口，致使我们的TreeMap符合SotredMap接口的定义。元素有序</p>
<p>不同的是SortdeMap要求：插入SortedMap的所有元素的键都必须实现 Comparable 接口。或者类型在Comparator类(对应TreeMap维护的comparator变量)中所接受。即对有序映射中的任意两个键 k1 和 k2 执行 <code>k1.compareTo(k2)</code>（或 <code>comparator.compare(k1, k2)</code>）必须是正确的。</p>
<h1 id="TreeMap的域"><a href="#TreeMap的域" class="headerlink" title="TreeMap的域"></a>TreeMap的域</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * The comparator used to maintain order in this tree map, or</div><div class="line"> * null if it uses the natural ordering of its keys.</div><div class="line"> *</div><div class="line"> * @serial</div><div class="line"> */</div><div class="line">private final Comparator&lt;? super K&gt; comparator;</div><div class="line"></div><div class="line">private transient Entry&lt;K,V&gt; root;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The number of entries in the tree</div><div class="line"> */</div><div class="line">private transient int size = 0;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The number of structural modifications to the tree.</div><div class="line"> */</div><div class="line">private transient int modCount = 0;</div></pre></td></tr></table></figure>
<ul>
<li><code>comparator</code>:TreeMap中维护了一个Comparator类型的变量。用来保证TreeMap的有序性。构造时传入该比较器</li>
<li><code>root</code>：红黑树根节点</li>
<li><code>size</code>: Entry数量</li>
<li><code>modCount</code>：结构性修改的次数</li>
</ul>
<h1 id="TreeMap的构造函数"><a href="#TreeMap的构造函数" class="headerlink" title="TreeMap的构造函数"></a>TreeMap的构造函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public TreeMap() &#123;</div><div class="line">    comparator = null;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</div><div class="line">    this.comparator = comparator;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</div><div class="line">    comparator = null;</div><div class="line">    putAll(m);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123;</div><div class="line">    comparator = m.comparator();</div><div class="line">    try &#123;</div><div class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), null, null);</div><div class="line">    &#125; catch (java.io.IOException cannotHappen) &#123;</div><div class="line">    &#125; catch (ClassNotFoundException cannotHappen) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>共四个，每个都对其实例维护的Comparator引用进行了赋值。</p>
<ul>
<li><code>TreeMap()</code>：无参构造函数规定，插入该有序Map的所有元素的键都必须实现Comparable接口，保证了其的可比较性。进而根据其键的自然排序来生成一个有序Map。</li>
<li><code>TreeMap(Comparator&lt;? super K&gt; comparator)</code>：参数是<code>Comparator</code>引用的构造函数规定，插入该有序Map的所有元素的键都需要根据该<code>Comparator</code>来进行比较。</li>
<li><code>TreeMap(Map&lt;? extends K, ? extends V&gt; m)</code>：参数是一个Map映射的构造函数会在其元素基础上构造一个TreeMap。同时该TreeMap规定元素需要满足TreeMap的默认规定，即和无惨构造函数所要求的一样。</li>
<li><code>TreeMap(SortedMap&lt;K, ? extends V&gt; m)</code>：参数是<code>SortedMap</code>的构造函数会拷贝一份和其相同元素和顺序的TreeMap。线性时间</li>
</ul>
<h1 id="TreeMap常见Api解析"><a href="#TreeMap常见Api解析" class="headerlink" title="TreeMap常见Api解析"></a>TreeMap常见Api解析</h1><h2 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">    Entry&lt;K,V&gt; t = root;</div><div class="line">    // 如果红黑树为空</div><div class="line">    if (t == null) &#123;</div><div class="line">        // key非空检查</div><div class="line">        compare(key, key); // type (and possibly null) check</div><div class="line"></div><div class="line">        root = new Entry&lt;&gt;(key, value, null);</div><div class="line">        size = 1;</div><div class="line">        modCount++;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    int cmp;</div><div class="line">    Entry&lt;K,V&gt; parent;</div><div class="line">    // split comparator and comparable paths</div><div class="line">    Comparator&lt;? super K&gt; cpr = comparator;</div><div class="line">    if (cpr != null) &#123;// 根据自定义比较器进行比较</div><div class="line">        // 根据key找到元素在树中应该落点的位置</div><div class="line">        do &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = cpr.compare(key, t.key);</div><div class="line">            if (cmp &lt; 0)</div><div class="line">                t = t.left;</div><div class="line">            else if (cmp &gt; 0)</div><div class="line">                t = t.right;</div><div class="line">            else</div><div class="line">                return t.setValue(value);</div><div class="line">        &#125; while (t != null);</div><div class="line">    &#125;</div><div class="line">    else &#123;// 根据元素的键实现的Comparable接口进行比较</div><div class="line">        if (key == null)// key不允许为null</div><div class="line">            throw new NullPointerException();</div><div class="line">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</div><div class="line">        do &#123;// 根据key找好元素在树的中落点</div><div class="line">            parent = t;</div><div class="line">            cmp = k.compareTo(t.key);</div><div class="line">            if (cmp &lt; 0)</div><div class="line">                t = t.left;</div><div class="line">            else if (cmp &gt; 0)</div><div class="line">                t = t.right;</div><div class="line">            else</div><div class="line">                return t.setValue(value);</div><div class="line">        &#125; while (t != null);</div><div class="line">    &#125;</div><div class="line">    // 循环跳出，parent即元素所在点的父节点。</div><div class="line">    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);</div><div class="line">    if (cmp &lt; 0)</div><div class="line">        parent.left = e;</div><div class="line">    else</div><div class="line">        parent.right = e;</div><div class="line">    // 调整红黑树</div><div class="line">    fixAfterInsertion(e);</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>put函数规定：如果Entry已经存在那么oldValue替换成newValue。如果Entry第一次插入，返回null。</li>
</ul>
<p>函数整体逻辑：判断当前红黑树是否为空，key是否为空检查，实例变量的维护。通过Comparable或者Comparator来找元素的落点，然后赋值。最后调整红黑树</p>
<h2 id="Comparable接口的排序了解一下"><a href="#Comparable接口的排序了解一下" class="headerlink" title="Comparable接口的排序了解一下"></a>Comparable接口的排序了解一下</h2><p>该接口强行对实现它的每个类的对象进行整体排序(隐式的)。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法。</p>
<p>实现了这个接口的对象的列表或数组可以通过其Collections.sort或Arrays.sort进行自动排序。</p>
<p>同时实现该接口的对象可以用作有序映射中的键或有序集合中的元素，无需再指定比较器。</p>
<p>一般的继承该接口的类型比较的时候，我们应该尽量保证其compareTo函数的比较结果与equals函数的比较结果一致。</p>
<h2 id="Comparator接口的排序了解一下"><a href="#Comparator接口的排序了解一下" class="headerlink" title="Comparator接口的排序了解一下"></a>Comparator接口的排序了解一下</h2><p>强行对某个对象 collection 进行整体排序 的接口。可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</p>
<h2 id="Comparable与Comparator接口比较总结"><a href="#Comparable与Comparator接口比较总结" class="headerlink" title="Comparable与Comparator接口比较总结"></a>Comparable与Comparator接口比较总结</h2><p>相比于Comparable接口的比较，Comparator的比较规则则是一种自定义规则的比较。也就意味着，对于实现了Comparable接口的类来说如果要想排序必须实现其compareTo函数，并且只有这一种方式。相比于我们自定义比较器可以有多个实现类的多个比较器的比较方式而言比较单一。并且没有比较器那么自由，可以随意安插。</p>
<p>Comparator体现了一种策略模式，就是不改变对象自身，而用一个策略对象来改变它的行为。</p>
<p><strong>总的来说</strong> </p>
<p>Comparable是自已完成比较，Comparator是外部程序实现比较。</p>
<p>两种方法各有优劣,用Comparable简单,只要实现Comparable 接口的对象直接就成为一个可以比较的对象,但是需要修改源代码,用Comparator的好处是不需要修改源代码, 而是另外实现一个比较器,当某个自定义的对象需要作比较的时候,把比较器和对象一起传递过去就可以比大小了, 并且在Comparator里面用户可以自己实现复杂的可以通用的逻辑,使其可以匹配一些比较简单的对象,那样就可以节省很多重复劳动了。</p>
<h2 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    Entry&lt;K,V&gt; p = getEntry(key);</div><div class="line">    return (p==null ? null : p.value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</div><div class="line">    // Offload comparator-based version for sake of performance</div><div class="line">    if (comparator != null)</div><div class="line">        // 自定义比较器存在，那么就调用getEntryUsingComparator函数来从红黑树中来找对应的Entry</div><div class="line">        return getEntryUsingComparator(key);</div><div class="line">    if (key == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    while (p != null) &#123;</div><div class="line">        // 否则通过Comparable接口的compareTo函数来找</div><div class="line">        int cmp = k.compareTo(p.key);</div><div class="line">        if (cmp &lt; 0)</div><div class="line">            p = p.left;</div><div class="line">        else if (cmp &gt; 0)</div><div class="line">            p = p.right;</div><div class="line">        else</div><div class="line">            return p;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 函数很简单，从红黑树中找到key对应的Entry并返回</div><div class="line">final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123;</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">        K k = (K) key;</div><div class="line">    Comparator&lt;? super K&gt; cpr = comparator;</div><div class="line">    if (cpr != null) &#123;</div><div class="line">        Entry&lt;K,V&gt; p = root;</div><div class="line">        while (p != null) &#123;</div><div class="line">            int cmp = cpr.compare(k, p.key);</div><div class="line">            if (cmp &lt; 0)</div><div class="line">                p = p.left;</div><div class="line">            else if (cmp &gt; 0)</div><div class="line">                p = p.right;</div><div class="line">            else</div><div class="line">                return p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h2><p>函数的作用：删除该Entry，并返回Entry.value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public V remove(Object key) &#123;</div><div class="line">    // 从红黑树中找到对应的Entry</div><div class="line">    Entry&lt;K,V&gt; p = getEntry(key);</div><div class="line">    if (p == null)</div><div class="line">        return null;</div><div class="line"></div><div class="line">    V oldValue = p.value;</div><div class="line">    deleteEntry(p);</div><div class="line">    return oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面我们分析过了getEntry的函数逻辑。而deleteEntry函数的主要作用则是删除红黑树中该节点并且调整红黑树。设计红黑树的比较复杂这里就不细说了</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Base class for TreeMap Iterators</div><div class="line"> */</div><div class="line">abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123;</div><div class="line">    // 下一个要迭代到的元素</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line">    // 迭代最后一次所返回的元素</div><div class="line">    Entry&lt;K,V&gt; lastReturned;</div><div class="line">    int expectedModCount;</div><div class="line"></div><div class="line">    PrivateEntryIterator(Entry&lt;K,V&gt; first) &#123;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        lastReturned = null;</div><div class="line">        next = first;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final boolean hasNext() &#123;</div><div class="line">        return next != null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    final Entry&lt;K,V&gt; nextEntry() &#123;</div><div class="line">        Entry&lt;K,V&gt; e = next;</div><div class="line">        if (e == null)</div><div class="line">            throw new NoSuchElementException();</div><div class="line">        if (modCount != expectedModCount)</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">        next = successor(e);</div><div class="line">        lastReturned = e;</div><div class="line">        return e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    final Entry&lt;K,V&gt; prevEntry() &#123;</div><div class="line">        Entry&lt;K,V&gt; e = next;</div><div class="line">        if (e == null)</div><div class="line">            throw new NoSuchElementException();</div><div class="line">        if (modCount != expectedModCount)</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">        next = predecessor(e);</div><div class="line">        lastReturned = e;</div><div class="line">        return e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void remove() &#123;</div><div class="line">        if (lastReturned == null)</div><div class="line">            throw new IllegalStateException();</div><div class="line">        if (modCount != expectedModCount)</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">        // deleted entries are replaced by their successors</div><div class="line">        if (lastReturned.left != null &amp;&amp; lastReturned.right != null)</div><div class="line">            next = lastReturned;</div><div class="line">        deleteEntry(lastReturned);</div><div class="line">        expectedModCount = modCount;</div><div class="line">        lastReturned = null;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 返回下一个要迭代的元素</div><div class="line">static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123;</div><div class="line">    if (t == null)</div><div class="line">        return null;</div><div class="line">    // 如果元素有右子树开始迭代右子树(因为既然遍历到了该元素，左子树肯定遍历完了)</div><div class="line">    else if (t.right != null) &#123;</div><div class="line">        Entry&lt;K,V&gt; p = t.right;</div><div class="line">        // 找右子树中最小的</div><div class="line">        while (p.left != null)</div><div class="line">            p = p.left;</div><div class="line">        return p;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 该返回其父节点了</div><div class="line">        Entry&lt;K,V&gt; p = t.parent;</div><div class="line">        Entry&lt;K,V&gt; ch = t;</div><div class="line">        // 下一个该返回的节点下左右子树全部清空，往上追溯，确认该节点的位置</div><div class="line">        while (p != null &amp;&amp; ch == p.right) &#123;</div><div class="line">            ch = p;</div><div class="line">            p = p.parent;</div><div class="line">        &#125;</div><div class="line">        return p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于successor函数我们需要时刻清晰，其迭代顺序是前序遍历的。先左后中后右</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>TreeMap底层是红黑树，能够实现该Map集合有序，很多函数的时间复杂度甚至可以到O(logn)</li>
<li>key不能为null</li>
<li>想要自定义比较，在构造方法中传入Comparator对象，否则使用key的自然排序来进行比较</li>
<li>非同步，除非外部手动同步或者Collections封装。</li>
</ul>
<p><strong>该数据结构的精髓</strong>：</p>
<p>如果在构造方法中传递了Comparator对象，那么就会以Comparator对象的方法进行比较，来排序。否则，则使用Comparable的compareTo(T o)方法来比较排序。</p>
<p><strong>需要注意的是</strong></p>
<ul>
<li>如果TreeMap使用Comparable接口来保证有序，那么使用其compareTo(T o)函数来比较时，key不能为null，并且该key必须实现了Comparable接口。</li>
<li>相对的如果是使用的是Comparator接口，使用compare函数来比较，key也不能为null，并且必须是Comparator接口支持的泛型类型。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文使用用的是jdk1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;TreeMap&quot;&gt;&lt;a href=&quot;#TreeMap&quot; class=&quot;headerlink&quot; title=&quot;TreeMap&quot;&gt;&lt;/a&gt;TreeMap&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5291509-23170e9abfcbc003.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap了解一下</title>
    <link href="http://www.jiyongguang.xin/linkedhashmap.html"/>
    <id>http://www.jiyongguang.xin/linkedhashmap.html</id>
    <published>2018-05-11T11:08:26.000Z</published>
    <updated>2018-05-11T16:16:04.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文使用用的是jdk1.8</p>
</blockquote>
<h1 id="LinkedHashMap类继承图"><a href="#LinkedHashMap类继承图" class="headerlink" title="LinkedHashMap类继承图"></a>LinkedHashMap类继承图</h1><p>我们先来了解一下LinkedHashMap的继承实现图吧。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-7525505d4c417d19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<a id="more"></a>
<h1 id="LinkedHashMap简述"><a href="#LinkedHashMap简述" class="headerlink" title="LinkedHashMap简述"></a>LinkedHashMap简述</h1><p><img src="https://upload-images.jianshu.io/upload_images/5291509-fa510d8a2278bd4f.png" alt=""></p>
<p>归纳整理一下：</p>
<ul>
<li>底层实现是散列表和双向链表。其实LinkedHashMap就是HashMap和LinkedList结合。底层还是HashMap，只是各节点Entry另外的还添加了两个属性before和after，通过双向列表来链接。</li>
<li>迭代有序。默认就是链表的元素插入顺序，可通过accessOrder变量修改迭代顺序，是插入顺序还是访问顺序。</li>
<li>当映射中已经存在key对应的一组Entry。再来一组key对应的Entry插入，会替换掉原来的Entry。元素顺序不受影响。</li>
<li>使用LinkedHashMap可以不用像HashMap一样元素杂乱无序，而保证元素一定的有序性，做到TreeMap的功能却不用TreeMap的成本。</li>
<li>提供了<code>LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder)</code>这个构造函数来构建LinkedHashMap，这样的LinkedHashMap的元素迭代顺序是从最近访问最少到最多(LRU算法)。</li>
<li>和HashMap一样允许键值为NULL的元素。</li>
<li>由于增加了双向链表的维护，大多数情况下其性能很可能比 HashMap 稍逊一筹。不过有一点例外的是LinkedHashMap 的 元素集迭代所需时间与映射Entry的数量 成比例，因为其迭代的时候是对其维护的双向列表进行迭代，有几个Entry迭代几次，而不是迭代其桶数。HashMap 迭代时间很可能开支较大，因为它所需要的时间与其容量成比例。</li>
<li>和HashMap一样有两个重要参数影响它的性能，初始容量和加载因子。为初始容量选择非常高的值对LinkedHashMap的影响比对 HashMap 要小，因为此类的迭代时间不受容量的影响，所以影响程度减少一些，但其他方面还是会有影响。</li>
<li>该类是非同步的。如果要使用该映射需要外部手动同步。或者在其初始化的时候外部封装<code>Map m = Collections.synchronizedMap(new LinkedHashMap(...))</code>。</li>
<li>在按<strong>插入顺序组成</strong>的LinkedHashMap中，修改Entry的key对应的value不是结构修改。<ul>
<li>在按<strong>访问顺序组成</strong>的LinkedHashMap中，仅通过get函数访问元素就已经算结构修改了。</li>
</ul>
</li>
</ul>
<h1 id="LinkedHashMap的属性"><a href="#LinkedHashMap的属性" class="headerlink" title="LinkedHashMap的属性"></a>LinkedHashMap的属性</h1><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-11/19083193.jpg" alt=""></p>
<p>注释给出的解释很清楚，和LinkedHashMap继承HashMap一样，我们知道HashMap维护的是一个单链表。而LinkedHasshMap对其的扩展就是保证了元素的有序性，其维护的是一个双向链表。即图中Entry，其多了两个属性before和after即双向链表中节点的前驱指针后后继指针。</p>
<p>更多的它还维护了两个节点变量即head和tail，即双向链表的头尾指针，保证了迭代的时候性能。这一点和LinkedList的实现一致。所以说根本上LinkedHashMap就是LinkedList和HashMap的一种结合实现。有HashMap存取增删时的性能，同时规避了HashMap迭代时性能的缺陷，有LinkedList迭代时的性能优势。</p>
<p>accessOrder属性则代表着LinkedHashMap的迭代顺序。该变量默认情况下是false，即代表插入顺序。为true的时候代表LinkedHashMap的迭代顺序是访问顺序(最近最久未使用优先)。在LinkedHashMap构造的时候统一赋值。</p>
<h1 id="LinkedHashMap的构造函数"><a href="#LinkedHashMap的构造函数" class="headerlink" title="LinkedHashMap的构造函数"></a>LinkedHashMap的构造函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public LinkedHashMap(int initialCapacity, float loadFactor) &#123;</div><div class="line">        super(initialCapacity, loadFactor);</div><div class="line">        accessOrder = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public LinkedHashMap(int initialCapacity) &#123;</div><div class="line">    super(initialCapacity);</div><div class="line">    accessOrder = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public LinkedHashMap() &#123;</div><div class="line">    super();</div><div class="line">    accessOrder = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</div><div class="line">    super();</div><div class="line">    accessOrder = false;</div><div class="line">    putMapEntries(m, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public LinkedHashMap(int initialCapacity,</div><div class="line">                     float loadFactor,</div><div class="line">                     boolean accessOrder) &#123;</div><div class="line">    super(initialCapacity, loadFactor);</div><div class="line">    this.accessOrder = accessOrder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LinkedHashMap有5个构造函数，根本上都是调用了其父类HashMap的构造函数，唯一不同的就是多了一个accessOrder变量的赋值。上面我们已经对accessOrder进行了解读</p>
<h1 id="LinkedHashMap常见Api解析"><a href="#LinkedHashMap常见Api解析" class="headerlink" title="LinkedHashMap常见Api解析"></a>LinkedHashMap常见Api解析</h1><h2 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h2><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-11/66466608.jpg" alt=""></p>
<p>可以从类结构图中看出。LinkdeHashMap的所有put函数都是继承自自己的父类HashMap，AbstractMap以及实现的Map接口。</p>
<p>我们知道HashMap的put函数的具体逻辑最后都封装到了putVal函数中。而putVal函数中节点的创建则落在了newNode函数中。由于LinkedHashMap重写了newNode函数，所以新创的节点链接在内部双向链表的尾部。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-3da23a2440badf4d?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<h2 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h2><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-11/22305226.jpg" alt=""></p>
<p>可以从LinkedHashMap类结构图看出其重写了HashMap的get函数和getOrDefault函数，继承了getNode函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    if ((e = getNode(hash(key), key)) == null)</div><div class="line">        return null;</div><div class="line">    if (accessOrder)</div><div class="line">        afterNodeAccess(e);</div><div class="line">    return e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public V getOrDefault(Object key, V defaultValue) &#123;</div><div class="line">   Node&lt;K,V&gt; e;</div><div class="line">   if ((e = getNode(hash(key), key)) == null)</div><div class="line">       return defaultValue;</div><div class="line">   if (accessOrder)</div><div class="line">       afterNodeAccess(e);</div><div class="line">   return e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LinkedHashMap重写了get()和getOrDefault()函数。调用继承自HashMap的getNode函数来找到哈希表中key对应的Entry。</p>
<p>对比HashMap中的实现,LinkedHashMap只是增加了在成员变量(构造函数时赋值)accessOrder为true的情况下，要去回调<code>afterNodeAccess(Node&lt;K,V&gt; e)</code>函数的判断。</p>
<p>HashMap的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>afterNodeAccess()</code>函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;//原尾节点</div><div class="line">    // 如果accessOrder 是true ，且原尾节点不等于e</div><div class="line">    if (accessOrder &amp;&amp; (last = tail) != e) &#123;</div><div class="line">        // 节点e强转成双向链表节点p</div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">        // p现在是尾节点， 后置节点一定是null</div><div class="line">        p.after = null;</div><div class="line">        // 如果p的前置节点是null，则p以前是头结点，所以更新现在的头结点是p的后置节点a</div><div class="line">        if (b == null)</div><div class="line">            head = a;</div><div class="line">        else // 否则更新p的前直接点b的后置节点为 a</div><div class="line">            b.after = a;</div><div class="line">        // 如果p的后置节点不是null，则更新后置节点a的前置节点为b</div><div class="line">        if (a != null)</div><div class="line">            a.before = b;</div><div class="line">        else // 如果原本p的后置节点是null，则p就是尾节点。 此时 更新last的引用为 p的前置节点b</div><div class="line">            last = b;</div><div class="line">        if (last == null) // 原本尾节点是null  则，链表中就一个节点</div><div class="line">            head = p;</div><div class="line">        else &#123; // 否则 更新 当前节点p的前置节点为 原尾节点last， last的后置节点是p</div><div class="line">            p.before = last;</div><div class="line">            last.after = p;</div><div class="line">        &#125;</div><div class="line">        // 尾节点的引用赋值成p</div><div class="line">        tail = p;</div><div class="line">        // 修改modCount。</div><div class="line">        ++modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<p>afterNodeAccess()函数中，会修改<code>modCount变量</code>,因此当你正在accessOrder=true的模式下,迭代LinkedHashMap时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</p>
<h2 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h2><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-11/51112402.jpg" alt=""></p>
<p>LinkedHashMap也没有重写remove()方法，因为它的删除逻辑和HashMap并无区别。</p>
<p>在remove函数中无论是节点的查找时的逻辑判断以及真正的节点删除时的逻辑处理在单链表以及双向链表中的逻辑都是一致的，</p>
<p>但它重写了<code>afterNodeRemoval()</code>这个回调方法。该方法会在真正封装了删除逻辑的<code>Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
boolean matchValue, boolean movable)</code>方法中回调，用来保证双向链表的结构性。并且该remove函数(5参)会在所有涉及到删除节点的方法中被调用因为其是删除节点操作的真正执行者。</p>
<h2 id="containsValue-Object-value"><a href="#containsValue-Object-value" class="headerlink" title="containsValue(Object value)"></a>containsValue(Object value)</h2><p>它重写了该方法，相比HashMap的实现，更为高效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public boolean containsValue(Object value) &#123;</div><div class="line">    for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after) &#123;</div><div class="line">        V v = e.value;</div><div class="line">        if (v == value || (value != null &amp;&amp; value.equals(v)))</div><div class="line">            return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>遍历一遍链表，去比较有没有value相等的节点，并返回</p>
<p>HashMap实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> public boolean containsValue(Object value) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; V v;</div><div class="line">    if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;</div><div class="line">        for (int i = 0; i &lt; tab.length; ++i) &#123;</div><div class="line">            for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</div><div class="line">                if ((v = e.value) == value ||</div><div class="line">                    (value != null &amp;&amp; value.equals(v)))</div><div class="line">                    return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>双重for循环。相对低效</p>
<p>LinkedHashMap只重写了HashMap的<code>containsValue</code>函数并没有重写其<code>containsKey</code>函数。是因为如果按containsValue的重写逻辑来做，需要遍历整个KeySet来找。</p>
<p>而HashMap的实现是通过hash算法来找的。效率要高很多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean containsKey(Object key) &#123;</div><div class="line">    return getNode(hash(key), key) != null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="afterNode"><a href="#afterNode" class="headerlink" title="afterNode *()"></a>afterNode *()</h2><p>我们在看HashMap源码的时候就曾看到这些函数的存在。注释也给的很清楚，专门为LinkedHashMap准备的回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Callbacks to allow LinkedHashMap post-actions</div><div class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</div><div class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</div><div class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</div></pre></td></tr></table></figure></p>
<p>从LinkedHashMap中也可以看出也确实重写了这三个函数。分别作用在函数的访问，插入和删除后的回调。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-11/34039053.jpg" alt=""></p>
<p><code>afterNodeAccess</code>函数在LinkedHashMap指定迭代顺序是访问顺序的时候获取元素时会回调。来保证双向链表的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</div><div class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;</div><div class="line">        K key = first.key;</div><div class="line">        removeNode(hash(key), key, null, false, true);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>afterNodeInsertion</code>：回调函数，新节点插入之后回调，根据evict来 判断是否需要删除最早插入的节点。如果实现LruCache会用到这个方法。</li>
<li><code>removeEldestEntry</code>：LinkedHashMap中默认返回false 则不删除最早节点。 返回true 代表要删除最早的节点。通常构建一个LruCache会在达到Cache的上限时返回true</li>
</ul>
<p><code>afterNodeInsertion(boolean evict)</code>以及<code>removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>是构建LruCache需要的回调，在LinkedHashMap里可以忽略它们。</p>
<h2 id="LinkedHashIterator"><a href="#LinkedHashIterator" class="headerlink" title="LinkedHashIterator()"></a>LinkedHashIterator()</h2><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-11/67747173.jpg" alt=""></p>
<p>从图中可以看出HashMap的迭代规则是遍历哈希表。从第一个桶存在元素的桶开始遍历。所以当初始容量大了之后，桶数也会上去。迭代的时候数据量就会上去</p>
<p>而LinkedHashMap迭代时是迭代的双向链表。从head节点开始一直到tail结束。并不是遍历每个桶，只是遍历双向链表的每个节点。所以受初始容量影响小。</p>
<p>LinkedHashMap 示意图；<br><img src="https://upload-images.jianshu.io/upload_images/5291509-1f9b4dc26dd7fbdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LinkedHashMap继承了HashMap，相比于HashMap仅重写了几个方法，以改变它迭代遍历时的顺序。这也是其与HashMap相比最大的不同。 </p>
<p>在每次插入数据，或者访问、修改数据时，会增加节点、或者调整链表的节点顺序。以决定迭代时输出的顺序。</p>
<ul>
<li>accessOrder ,默认是false，则迭代时输出的顺序是插入节点的顺序。若为true，则输出的顺序是按照访问节点的顺序。为true时，可以在这基础之上构建一个LruCache.</li>
<li>LinkedHashMap并没有重写任何put方法。但是其重写了构建新节点的newNode()方法.在每次构建新节点时，将新节点链接在内部双向链表的尾部</li>
<li>accessOrder=true的模式下,在afterNodeAccess()函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。值得注意的是，afterNodeAccess()函数中，会修改modCount,因此当你正在accessOrder=true的模式下,迭代LinkedHashMap时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</li>
<li>nextNode() 就是迭代器里的next()方法 。<br>该方法的实现可以看出，迭代LinkedHashMap，就是从内部维护的双链表的表头开始循环输出。<br>而双链表节点的顺序在LinkedHashMap的增、删、改、查时都会更新。以满足按照插入顺序输出，还是访问顺序输出。</li>
<li>它与HashMap比，还有一个小小的优化，重写了containsValue()方法，直接遍历内部链表去比对value值是否相等。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文使用用的是jdk1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;LinkedHashMap类继承图&quot;&gt;&lt;a href=&quot;#LinkedHashMap类继承图&quot; class=&quot;headerlink&quot; title=&quot;LinkedHashMap类继承图&quot;&gt;&lt;/a&gt;LinkedHashMap类继承图&lt;/h1&gt;&lt;p&gt;我们先来了解一下LinkedHashMap的继承实现图吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5291509-7525505d4c417d19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HashMap了解一下</title>
    <link href="http://www.jiyongguang.xin/hashmap.html"/>
    <id>http://www.jiyongguang.xin/hashmap.html</id>
    <published>2018-05-10T09:12:27.000Z</published>
    <updated>2018-05-10T09:16:00.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文基于jdk1.8</p>
</blockquote>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>先来看一下Java官方描述</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-1c64f473d364b951?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<a id="more"></a>
<ul>
<li>基于哈希表的 Map 接口的实现。</li>
<li>允许使用 null 值和 null 键。</li>
<li>除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。</li>
<li>不保证映射的顺序，特别是它不保证该顺序恒久不变（扩容后元素在底层会重散列）。</li>
<li>迭代所需的时间与 HashMap实例的“容量”（桶的数量）及键-值映射数成比例。即初始容量设置得太高（或将负载因子设置得太低）对遍历的性能影响都很大。<ul>
<li>负载因子 = 总键值对数 / 箱子个数(数组元素)</li>
</ul>
</li>
<li>HashMap 的实例有两个参数影响其性能：初始容量 和负载因子。当元素个数超过当前容量(桶数)与负载因子的乘机时，哈希表会对其元素rehash，底层的桶数*2。</li>
<li>默认负载因子(0.75)，加载因子过高虽然减少了空间开销，但同时也增加了查询成本。在设置初始容量时应该考虑到Map中所要容纳的元素数量及其加载因子，以便最大限度地减少rehash操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生rehash操作。</li>
<li>如果从一开始就知道有多少元素要存到Map中，最好一开始就指定好Map初始容量，尽量避免其rehash操作。性能会大大提高</li>
<li>此实现不是同步的。想要同步在一些列操作外手动同步，或者使用<code>Map m = Collections.synchronizedMap(new HashMap(...));</code>方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问</li>
</ul>
<h1 id="HashMap类继承图"><a href="#HashMap类继承图" class="headerlink" title="HashMap类继承图"></a>HashMap类继承图</h1><p><img src="https://upload-images.jianshu.io/upload_images/5291509-39d36773be4fdbce?imageMogr2/auto-orient/strip%7CimageView2/2/w/653" alt=""></p>
<ul>
<li>实现了Serializable，Cloneable接口</li>
<li>继承了父类AbstractMap</li>
</ul>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-9/51511736.jpg" alt=""></p>
<h1 id="HashMap属性"><a href="#HashMap属性" class="headerlink" title="HashMap属性"></a>HashMap属性</h1><p>静态属性：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-c9471705807fb759?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<ul>
<li><code>DEFAULT_INITIAL_CAPACITY</code>: 初始容量，也就是默认会创建 16 个箱子，箱子的个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。</li>
<li><code>MAXIMUM_CAPACITY</code>: 哈希表最大容量，一般情况下只要内存够用，哈希表不会出现问题。</li>
<li><code>DEFAULT_LOAD_FACTOR</code>: 默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。</li>
<li><code>TREEIFY_THRESHOLD</code>: 上文说过，如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。这个值表示当某个箱子中，链表长度大于等于 8 时，有可能会转化成树。</li>
<li><code>UNTREEIFY_THRESHOLD</code>: 在哈希表扩容时，如果发现链表长度小于 6，则会由树重新退化为链表。</li>
<li><code>MIN_TREEIFY_CAPACITY</code>: 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</li>
</ul>
<p>成员属性：</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-9/624891.jpg" alt=""></p>
<ul>
<li><code>table</code>：HashMap的链表数组。它在自扩容时总是2的次幂</li>
<li><code>entrySet</code>: HashMap实例中的Entry的Set集合。</li>
<li><code>size</code>: HashMap实例中映射的数量</li>
<li><code>modCount</code>: 这个HashMap被结构修改的次数</li>
<li><code>threshold</code>: 桶数</li>
<li><code>loadFactor</code>: 哈希表的负载因子</li>
</ul>
<p><strong>HashMap简单总结：</strong></p>
<ul>
<li>存取无序</li>
<li>键值允许为NULL</li>
<li>非同步类</li>
<li>底层是哈希表</li>
<li>初始容量和装载因子是决定整个类性能的关键点。</li>
</ul>
<h1 id="HashMap构造函数"><a href="#HashMap构造函数" class="headerlink" title="HashMap构造函数"></a>HashMap构造函数</h1><p>HashMap的构造函数共4个。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-9/96671008.jpg" alt=""></p>
<h2 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h2><p><img src="https://upload-images.jianshu.io/upload_images/5291509-4f153b37d6a712a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>我们可以看到loadFactor参数Java官方还对其进行了Float.NaN(0.0f/0.0f)的判断。可以说考虑的非常周到了</p>
<p>同时在构造函数的最后一行，在为threshold赋值的时候，调用了tableSizeFor()函数来对输入的初始容量进行判断，来保证该初始容量是2的整数次幂。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-9/28415970.jpg" alt=""></p>
<p>函数具体释义可参考：<a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="external">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a></p>
<ul>
<li>此时不经要想为什么是将2的整数幂的数赋给threshold？</li>
</ul>
<p>首先我们先来了解一下threshold这个属性：</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-9/34793006.jpg" alt=""></p>
<p>threshold这个成员变量是阈值，决定了是否要将散列表扩容充重散列。它的值应该是：(capacity * loadfactor）才对的。</p>
<ul>
<li>那我们就更奇怪了，那这里还给他赋值干什么？</li>
</ul>
<p>其实这里仅仅是一个初始化，当创建哈希表的时候，它会在resize函数中根据一些条件判断来重新定义赋值的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-52448d3f9cf423aa?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<h2 id="HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>HashMap(Map&lt;? extends K, ? extends V&gt; m)</h2><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-9/67028212.jpg" alt=""></p>
<p>这个构造函数其实本质上和刚才我们所看的给初始容量和负载因子的构造函数一致。函数最终做的除了参数上可以看出来的，把一个Map实例中的元素都插入到HashMap实例中外，由于负载因子没有显示指定所以赋予了loadFactory默认值。</p>
<p>并且把具体的Map迭代放在了调用的<code>putMapEntries</code>函数中。从该函数注释中看出，该函数是服务于<code>putAll</code>函数和<code>constructor</code>构造函数的。</p>
<p>从<code>putMapEntries</code>函数注释中也可以看出，如果这个函数在初始化Map时被调用evict参数传入的是false。而如果这个函数是在afterNodeInsertion函数后调用的，那么则需要传入的是true。</p>
<p>从putMapEntries函数的具体代码实现上可以看出，其在Map第一次初始化的时候和我们刚才所看的构造函数一致，都是在真正构造HashMap前先为阈值赋予一个可靠地初值。然后才迭代入参map集合，将其元素都插入到HashMap中。</p>
<p>其余的构造函数都是大同小异。就不一一赘述了</p>
<p><strong>总结：</strong></p>
<p>从构造函数中我们可以看出，HashMap的构造函数其实工作就只有一个。赋值</p>
<ul>
<li>赋值负载因子</li>
<li>赋值阈值</li>
</ul>
<h1 id="HashMap常见Api解析"><a href="#HashMap常见Api解析" class="headerlink" title="HashMap常见Api解析"></a>HashMap常见Api解析</h1><h2 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line"> * Associates the specified value with the specified key in this map.</div><div class="line"> * If the map previously contained a mapping for the key, the old</div><div class="line"> * value is replaced.</div><div class="line"> *</div><div class="line"> */</div><div class="line">public V put(K key, V value) &#123;</div><div class="line">    return putVal(hash(key), key, value, false, true);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出put函数具体实现其实是调用了putVal函数。并且从注释中可以得知如果该映射存在，新值会替换掉旧值。</p>
<p>还可以看到的是传入了5个参数，我们来了解简单一下这5个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line"> * Implements Map.put and related methods</div><div class="line"> *</div><div class="line"> * @param hash hash for key</div><div class="line"> * @param key the key</div><div class="line"> * @param value the value to put</div><div class="line"> * @param onlyIfAbsent if true, don&apos;t change existing value</div><div class="line"> * @param evict if false, the table is in creation mode.</div><div class="line"> * @return previous value, or null if none</div><div class="line"> */</div><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">               boolean evict) &#123;</div></pre></td></tr></table></figure>
<p>注释很直白解释的很清楚，按序号来</p>
<ol>
<li>key的哈希值</li>
<li>key</li>
<li>value</li>
<li>如果映射存在不替换原值？</li>
<li>如果是false，代表当前HashMap正处于创建阶段。</li>
</ol>
<p>我们大概知道了这5个参数是干嘛的了，就可以针对第一个参数具体的去了解一下key的哈希值是如何计算得了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static final int hash(Object key) &#123;</div><div class="line">    int h;</div><div class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就比较疑惑了，为什么不直接用key类型对应的hashcode函数直接得到对应的哈希码呢？从这段代码可以看出来Java官方拿key的哈希码和其哈希码向右移位16位的结果进行异或操作。我们知道右移高位补0，由于哈希码返回的是一个4字节32位int类型的值。所以总共可以看成是高16位，低16位组成的。</p>
<p>而这里对其哈希码进行右移16位之后高位空缺补0，原高位到了现低位。然后再拿原哈希码与现哈希码进行异或操作，而我们知道任何数跟0异或都是其本身。所以可以看出Java官方最终目的，是想让哈希码原低16位与其高16位进行异或操作。而原高16位却不变，原来如此~</p>
<p><img src="https://img-blog.csdn.net/20160408155045341" alt=""></p>
<p><strong>但为什么要这样呢？</strong></p>
<p>其实这个与HashMap中元素插入时对应位置table数组下标的计算有关。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-10/96013331.jpg" alt=""></p>
<p>核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = (tab = resize()).length;</div><div class="line">i =（n-1） &amp; hash</div></pre></td></tr></table></figure></p>
<p>我们暂且不看resize函数，putVal函数在初次进来的时候该resize函数做的其实就是哈希表初始化的工作。由于<code>DEFAULT_INITIAL_CAPACITY</code>变量的存在，我们暂且认为该哈希表的大小length为16。即n=16</p>
<p>那么在计算元素插入位置的时候，由于底层是数组。所以真正存储的位置就是[0-15]。所以n-1。</p>
<p>而因为，table的length属性都是2的幂，因此i仅与hash值的低n位有关（此n非table.length，而是2的幂指数）<br>假设table.length=2^4=16。 </p>
<p><img src="https://img-blog.csdn.net/20160408155102734" alt=""></p>
<p>由上图可以看到，32位的hash值只有低4位参与了运算。<br>仅有4位的异或很容易产生碰撞。但是由于table.length的大小只能由插入数据的多少来改变，而hash值得高16位又由于与操作置0了，所以设计人员相出一个好办法就是通过对key的hash值进行高16位与低16位异或来将高位与低位整合。这样不但可以保留原来key哈希值的差异性(高位地位同时作用)，同时来增加低16位2进制数值在计算时的差异性进而减少这种哈希冲突的情况。</p>
<p>参考：<a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="external">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a></p>
<h2 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)"></a>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</h2><p>接下来便可以继续分析真正的put函数了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-9c35a69f5a70edab?imageMogr2/auto-orient/" alt=""></p>
<p>总结下来就是：</p>
<ul>
<li>散列表初次put数组任为NULL时，调用resize函数(单独拉出来说)来初始化散列表</li>
<li>当根据元素的哈希值可以确认分配到散列表的下标时，<strong>如果此处没有元素</strong>，那么就直接插入<ul>
<li><strong>当该元素就是和我一样的元素</strong>。即此处元素的hash值和key值都与要插入的元素相等时。通过变量e指向该元素。</li>
<li><strong>当该元素已经不是一个链表结构而是一个红黑树结构的时候</strong>(元素肯定过6)，将该元素插入到红黑树中，并用e指向该元素</li>
<li>否则该处就是一个链表，链表头结点不是要插入的元素，但不能排除其他节点不是。所以然后遍历这个数组，当该链表中遍历到的节点的下一节点为空时将该元素插入到链表尾，循环跳出。如果不为空的话，对下一节点进行判断看是否是待插入节点。如果是跳出</li>
</ul>
</li>
<li>程序进行到绿框时，此时程序只有两种情况。元素最后找到空出插入了，但是e无法指向。或者说元素找到和自己一样的元素了，并且由变量e指向。<ul>
<li>新旧值替换，根据函数一开始传入的参数onlyIfAbsent或者oldValue的特殊情况来决定是否替换。<ul>
<li>key对应的旧值如果为NULL，那么无论onlyIfAbsent是否决定替换。都将被替换。</li>
<li>key对应的旧值如果不为NULL，那么如果onlyIfAbsent是false就替换。</li>
</ul>
</li>
<li>最后返回被替换掉的值。</li>
</ul>
</li>
<li>修改了实例结构所以modCount+1。 </li>
<li>加入元素后判断元素个数是否超过了阈值。如果是resize函数扩桶数</li>
</ul>
<p>这样我们的putVal函数其实思路就理清了，看上去很复杂，其实宗旨没变，也就是判断，扩容，找位置，去除特殊情况，元素插入，只不过数据结构的差异性导致其特殊情况较多，判断的复杂了些。接下来该分析resize函数了。我们可以明显的看到putVal函数多出调用了resize函数。所以要想彻底理清HashMap实例是如何构建的，resize函数必然需要了解一下。</p>
<p>目前对resize的了解：table==null时，调用resize初始化table。元素数量&gt;=threshold时，调用resize扩容。</p>
<h2 id="Node-resize"><a href="#Node-resize" class="headerlink" title="Node[] resize()"></a>Node<k,v>[] resize()</k,v></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Initializes or doubles table size.  If null, allocates in</div><div class="line"> * accord with initial capacity target held in field threshold.</div><div class="line"> * Otherwise, because we are using power-of-two expansion, the</div><div class="line"> * elements from each bin must either stay at same index, or move</div><div class="line"> * with a power of two offset in the new table</div><div class="line"> */</div><div class="line">final Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从该函数的开头我们也可以确认我们刚才的观点。用来初始化和给table扩容的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-4973a9573bbef4b7" alt=""></p>
<p>总结下来就是：</p>
<p><strong>哈细表扩容：</strong></p>
<ul>
<li>当旧表容量大于0时，即旧表被初始化过了<ul>
<li>并且如果其容量大于或等于int的最大值。那么阈值设置为int的最大值。并返回旧旧表，此时表已经不能再扩容了，能做的只有置阈值为其能到大的最大值，尽可能的减少扩容次数。</li>
<li>当旧表容量不及最大容量的一半时，并且旧表容量大于默认容量16时。由于函数resize被调用了。所以需要满足外界扩容需求，旧表阈值&lt;&lt;1。</li>
</ul>
</li>
<li>当旧表没被初始化，但HashMap实例被初始化了。<ul>
<li>否则当旧表还未被初始化时，只是在初始化HashMap实例的时候赋予了阈值和负载因子(结合构造函数思考)，当旧阈值&gt;0时，哈希表初始容量设置为阈值。</li>
<li>否则，当构造HashMap实例时如果连阈值也没有赋值(默认为0)只是初始化了负载因子的话(默认无参构造函数)。初始化哈希表容量为<code>DEFAULT_INITIAL_CAPACITY</code>即16，阈值为<code>DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY</code>即12。</li>
</ul>
</li>
<li>当阈值=0时，新阈值=新容量*负载因子。当HashMap实例被被初始化时阈值也被初始化时会走这一分支</li>
<li>最后确定容量和阈值后初始化哈细表。</li>
</ul>
<p><strong>数据迁移：</strong></p>
<ul>
<li>当旧哈细表存在时，迭代哈细表每个元素。因为每个元素中存的都是链表或者红黑树。根据每个元素的哈希值重新散列到新哈希表的对应位置上。底层数据结构和节点的存储位置很大程度上会更改。</li>
</ul>
<h2 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h2><p>从注释中可以看出，返回 null 值并不一定 表明该映射不包含该键的映射关系；也可能该映射将该键显示地映射为 null。可使用 containsKey 操作来区分这两种情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line"> * ·····</div><div class="line"> * &lt;p&gt;A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</div><div class="line"> * indicate that the map contains no mapping for the key; it&apos;s also</div><div class="line"> * possible that the map explicitly maps the key to &#123;@code null&#125;.</div><div class="line"> * The &#123;@link #containsKey containsKey&#125; operation may be used to</div><div class="line"> * distinguish these two cases.</div><div class="line"> * ·····</div><div class="line"> */</div><div class="line">public V get(Object key) &#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数具体查询逻辑封装到了getNode函数。<br><img src="https://upload-images.jianshu.io/upload_images/5291509-e238bca1afa95fde?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>简单来说：</p>
<ul>
<li>key对应的哈希值计算出来落到哈希表对应的地方上，如果有元素存在。</li>
<li>有元素存在就需要比较了，因为元素上可能存的是链表或者红黑树。<ul>
<li>第一个元素就是搜寻的key本身</li>
<li>第一个不是，但其是红黑树结构。参数传递并去红黑树中找</li>
<li>不是红黑树结构，那么就是链表结构，进行迭代寻找，获取key对应的value。</li>
</ul>
</li>
</ul>
<h2 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Removes the mapping for the specified key from this map if present.</div><div class="line"> *</div><div class="line"> * @param  key key whose mapping is to be removed from the map</div><div class="line"> * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</div><div class="line"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</div><div class="line"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</div><div class="line"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</div><div class="line"> */</div><div class="line">public V remove(Object key) &#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</div><div class="line">        null : e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从函数的注释中可以看出，该函数删除key对应的Entry并返回与 key 关联的旧值；如果 key 没有任何映射关系，则返回 null。<strong>但需要注意的是：</strong> 返回 null 还可能表示该映射之前将 null 与 key 关联。</p>
<p>函数再次把元素的通过hash函数包装传了进去，这很好理解，因为底层是哈希表嘛，不这样怎么能找到key到底在哈希表什么位置呢。我们可以看到删除逻辑的具体逻辑封装到了<code>removeNode</code>函数中。</p>
<h2 id="removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable"><a href="#removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable" class="headerlink" title="removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable)"></a>removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable)</h2><p>先来对removeNod函数的多个参数进行一番分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* @param hash hash for key </div><div class="line">* @param key the key</div><div class="line">* @param value the value to match if matchValue, else ignored</div><div class="line">* @param matchValue if true only remove if value is equal</div><div class="line">* @param movable if false do not move other nodes while removing</div></pre></td></tr></table></figure></p>
<ol>
<li>hash(key)</li>
<li>key</li>
<li>对应matchValue参数，如果matchValue为true。那么删除key时其value必须与value相等，否则跳过这次删除</li>
<li>如果true。只有当值相等时才删除。</li>
<li>如果为false，那么在删除节点时不移动其他节点。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-633aa4ef3fdf45b4?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>总的来说：</p>
<ul>
<li>先判断key是否可以映射到哈希表上。<ul>
<li>如果可以，判断一下映射的位置头元素是否为该查找的元素。</li>
<li>如果头元素不是要找元素，判断一下头元素后有无其他元素。如果有再判断一下这个元素的数据结构是否为红黑树，如果是，用node变量指向该key对应在红黑树中的节点。</li>
<li>如果不是那说明哈希表该索引处是一个链表结构，然后对链表元素迭代寻找该元素，并用node节点指向寻找到的该元素。需要注意的是，<code>p</code>变量的逻辑定位，由于<code>do while</code>循环体中break语句相对于<code>p=e</code>语句置前，p变量在循环退出时指向的是node节点的前驱节点。</li>
</ul>
</li>
<li><p>经历过橘黄色和红色两大块逻辑判断，成功找到了待删除节点的位置，并用node节点指向。如果该Node节点被成功找到了的话。</p>
<ul>
<li>红黑树：如果node节点所在哈希表的位置元素的存储结构式是红黑树的话。调用红黑树的删除方法</li>
<li>链表：如果头节点就是待删除节点的话，那么待删除节点的next节点做头结点</li>
<li>链表：如果待删除节点是链表中间部分的某个节点。借助p变量进行删除。</li>
</ul>
</li>
<li><p>modCount+1，size-1，并将删除的节点返回。</p>
</li>
</ul>
<h1 id="HashMap与HashTable对比"><a href="#HashMap与HashTable对比" class="headerlink" title="HashMap与HashTable对比"></a>HashMap与HashTable对比</h1><p>我们从一开始就曾说，两者从存储结构和实现来讲基本上都是相同的。两者最大的差别就是HashTable是线程安全的，而HashMap是线程不安全的。并且在数据存储时，HashMap允许key和value为null。而HashTable则不允许。并且HashTable规定用作键的对象必须实现 hashCode 方法和 equals 方法。</p>
<p>HashTable在Map映射中的地位有点儿像Vector在List集合中的定位。也是比较过时的类，设计上有一些缺陷，不需要线程安全的情况下可以使用HashMap替代它，而需要线程安全的情况下也可以用ConcurrentHashMap来替代它。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-fe3fa865a5159edf?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>HashMap的底层是：数组+链表+红黑树</li>
<li>HashMap的实例有两个重要参数影响其性能。负载因子和初始容量，(装载因子*初始容量)&lt; 散列表元素时，该散列表会扩容2倍，并重散列。<ul>
<li>负载因子：默认0.75，无论是初始大了还是初始小了对HashMap的性能都不好<ul>
<li>初始值大了，可以减少散列表再散列(扩容的次数)，但同时会导致散列冲突的可能性变大(散列冲突也是耗性能的一个操作，要得操作链表(红黑树)</li>
<li>初始值小了，可以减小散列冲突的可能性，但同时扩容的次数可能就会变多！</li>
</ul>
</li>
<li>初始容量：默认值是16，无论初始大了还是小了对HashMap都是有影响的<ul>
<li>初始容量过大，那么遍历时速度就会受影响~</li>
<li>初始容量过小，散列表再散列(扩容的次数)可能就变得多，扩容也是一件非常耗费性能的一件事</li>
</ul>
</li>
<li>参考公式：阈值 = 容量 * 负载因子</li>
</ul>
</li>
<li>HashMap在计算元素在哈希表中存储位置的时候，并不是直接拿key的哈希值来用的，会先对key的哈希值进行右移16位，然后再与其key的哈希值进行异或操作。根本上就是高位不变，低位变为高16位和低16位的异或结果，使得元素在存储时的随机性更大了。分布更加均匀了，减少了哈希冲突发生的概率</li>
<li>并不是箱子上元素大于等于8位元素的时候该哈希表的元素底层就能变成红黑树，它得同时满足哈希表总容量大于64才行，同时当红黑树元素数量低于8时，并不是会立马变回链表。而是在其元素小于6时才会。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文基于jdk1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h1&gt;&lt;p&gt;先来看一下Java官方描述&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5291509-1c64f473d364b951?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Map集合了解一下</title>
    <link href="http://www.jiyongguang.xin/map.html"/>
    <id>http://www.jiyongguang.xin/map.html</id>
    <published>2018-05-09T01:44:51.000Z</published>
    <updated>2018-05-09T01:47:28.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先声明本文使用的是jdk1.8</p>
<h1 id="Map映射"><a href="#Map映射" class="headerlink" title="Map映射"></a>Map映射</h1><p>Map即双列集合。但我们一般称它为映射，即键值对的形式。</p>
<h2 id="Map映射的特点"><a href="#Map映射的特点" class="headerlink" title="Map映射的特点"></a>Map映射的特点</h2><ul>
<li>键值对形式存储元素。</li>
<li>Collection集合子接口List元素可以重复，Set不可以重复，而Map是键唯一，值可以重复。</li>
<li>Map集合的数据结构针对于键，和值无关。Collection的数据结构针和元素有关。</li>
</ul>
<a id="more"></a>
<h2 id="Map接口结构"><a href="#Map接口结构" class="headerlink" title="Map接口结构"></a>Map接口结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/5291509-b3d36a4444af2b15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>图中叙述的很清楚。</p>
<ul>
<li>Entry作为Map映射的特有接口而存在于Map接口中属于内部接口。</li>
<li>重写了Object类的hashcode和equals函数。</li>
<li>自定义了一套接口函数</li>
<li>提供了系列可直接使用的函数</li>
</ul>
<h2 id="Map接口常见Api解析"><a href="#Map接口常见Api解析" class="headerlink" title="Map接口常见Api解析"></a>Map接口常见Api解析</h2><p>由于是顶级Map接口，官方只由注释定义了其实现规则，所以我们做的也只是解读注释而已。</p>
<h3 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h3><p>将指定的值与此映射中的指定键关联。如果此映射以前包含一个该键的映射关系，则用指定值替换旧值（当且仅当 m.containsKey(k) 返回 true 时，才能说映射 m 包含键 k 的映射关系）。</p>
<h3 id="putAll-Map-lt-extends-K-extends-V-gt-m"><a href="#putAll-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="putAll(Map&lt;? extends K,? extends V&gt; m)"></a>putAll(Map&lt;? extends K,? extends V&gt; m)</h3><p>从指定映射中将所有映射关系复制到此映射中（可选操作）。对于指定映射中的每个键 k 到值 v 的映射关系，此调用等效于对此映射调用一次 put(k, v)。</p>
<h3 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h3><p>如果存在一个键的映射关系，则将其从此映射中移除。<br>返回此映射中以前关联该键的值，如果此映射不包含该键的映射关系，则返回 null。</p>
<p><strong>需要注意的是：</strong></p>
<p>如果此映射允许 null 值，则返回 null 值并不一定 表示该映射不包含该键的映射关系；也可能该映射将该键显示地映射到 null。</p>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>从此映射中移除所有映射关系（可选操作）。此调用返回后，该映射将为空。</p>
<h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h3><p>如果此映射未包含键-值映射关系，则返回 true。</p>
<h3 id="containsKey-Object-key"><a href="#containsKey-Object-key" class="headerlink" title="containsKey(Object key)"></a>containsKey(Object key)</h3><p>如果此映射包含指定键的映射关系，则返回 true。</p>
<h3 id="containsValue-Object-value"><a href="#containsValue-Object-value" class="headerlink" title="containsValue(Object value)"></a>containsValue(Object value)</h3><p>如果此映射将一个或多个键映射到指定值，则返回 true。</p>
<h3 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h3><p>返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</p>
<p><strong>需要注意的是：</strong></p>
<p>如果此映射允许 null 值，则返回 null 值并不一定 表示该映射不包含该键的映射关系；也可能该映射将该键显示地映射到 null。使用 containsKey 操作可区分这两种情况。</p>
<h3 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet()"></a>entrySet()</h3><p>返回此映射中包含的映射关系的Set集合。即Entry集合</p>
<p><strong>需要注意的是：</strong></p>
<p>如果对该Set进行迭代的同时修改了映射。则迭代结果是不确定的。迭代结果可能由于并发操作的影响超出我们的预期。</p>
<p>但如果通过迭代器自己的remove操作，或者通过对迭代器返回的映射项Entry执行setValue操作除外。因为这样的修改结果在我们的预知范围之内。</p>
<h3 id="keySet"><a href="#keySet" class="headerlink" title="keySet()"></a>keySet()</h3><p>返回此映射中包含的键的Set集合。</p>
<p><strong>需要注意的是：</strong></p>
<p>如果对该set进行迭代的同时修改了映射，则迭代结果是不确定的。因为是线程不同步的，所以并发操作其他线程的修改结果我们不会预知，可能会发生异常，可能正常进行但是结果不是我们预期的结果</p>
<p>但通过迭代器自己的remove操作除外。还是那个原因，通过Iterator的迭代方式进行remove的时候是可以保证在remove的时候expectedModCount = modCount的。</p>
<p>所以如果在使用Iterator迭代的时候如果其他线程并发的修改了映射类的话。Iteratore会返回一个并发修改的异常。相比于其他迭代方式对Set集合遇到并发修改的行为的返回结果是确定的。</p>
<h3 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h3><p>返回此映射中包含的值的Collection集合。</p>
<h3 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h3><p>返回此映射中的键-值映射关系数。如果该映射包含的元素大于<code>Integer.MAX_VALUE</code>,则返回<code>Integer.MAX_VALUE</code>。</p>
<h2 id="Map接口常见实现类"><a href="#Map接口常见实现类" class="headerlink" title="Map接口常见实现类"></a>Map接口常见实现类</h2><p><img src="https://upload-images.jianshu.io/upload_images/5291509-fd087f8fbdf5c93a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>红框所标都是Map接口关键的实现类。</p>
<p>其中需要针对HashMap和TreeMap两种需要提前了解一下他们底层的数据结构实现。分别是哈希表(散列表)和红黑树</p>
<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>针对于Map接口的HashMap实现类以及Set接口的HashSet我们来学习一下散列表。</p>
<h2 id="什么是散列表"><a href="#什么是散列表" class="headerlink" title="什么是散列表"></a>什么是散列表</h2><p>散列表其实也很好理解，就是一个链表数组。数组的每一个元素都是一个链表。</p>
<p>散列表最重要的就是它当中的元素之如何存储的。在我们之前所了解的无论是链表还是数组，如果想查找某一元素都是量元素间相互比较，通过比较的方式来迭代遍历元素的，知道找到那个元素。这样的方式无疑当数据量上去之后对我们时间上的开销非常的巨大。所以散列表的存储方式就诞生了</p>
<h2 id="散列表的工作原理"><a href="#散列表的工作原理" class="headerlink" title="散列表的工作原理"></a>散列表的工作原理</h2><p><strong>哈希表的存储过程如下:</strong></p>
<ul>
<li>根据 key 计算出它的哈希值 h。</li>
<li>假设箱子的个数为 n，那么这个键值对应该放在第 (h % n) 个箱子中。</li>
<li>如果该箱子中已经有了键值对，就使用开放寻址法或者拉链法解决冲突。</li>
</ul>
<h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>我们刚才说了，底层容器是一个链表数组。为什么是链表呢，那肯定是数组的一个位置可以存不止一个元素。必然，我们还没有了解过散列表是如何为每个要存入的元素计算其散列值的呢，会不会出现两个元素散列值一样的情况。但既然我们知道散列表底层的数据结构了，肯定就会知道一定是会出现这种情况的。我们一般称这种情况为哈希冲突(hash碰撞)，但一般情况下的哈希函数设计都十分合理，这种现象很少出现。即便出现了，也有对应的措施。</p>
<p>此时的处理方式：</p>
<ul>
<li>判断该数组的链表元素中是否存储了该元素。如果没有就放入，如果有就跳过。</li>
</ul>
<p><strong>哈希冲突解决办法：</strong></p>
<ul>
<li>开放寻址法：即散列到冲突地址的下一空闲位置插入即可。<ul>
<li>缺点：散列表空间不足时，无法处理冲突也无法插入数据</li>
<li>解决办法：由于需要负载因子(空间/插入数据)&gt;=1。所以进行扩容(数组扩容)</li>
</ul>
</li>
<li>拉链法：即如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。<ul>
<li>缺点：这种解决办法的哈希表在极端情况下会变成线性表，性能极低。</li>
<li>解决办法：Java8中Java官方的处理方案是当链表太长时，转换成红黑树。</li>
</ul>
</li>
</ul>
<h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>负载因子(load factor)，它用来衡量哈希表的 空/满 程度，一定程度上也可以体现查询的效率</p>
<blockquote>
<p>负载因子 = 总键值对数 / 箱子个数(数组元素)</p>
</blockquote>
<p>负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，一般为 0.75 等)时，哈希表将自动扩容。</p>
<p>哈希表在自动扩容时，一般会创建两倍于原来个数的箱子，因此即使 key 的哈希值不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。</p>
<p>哈希表的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个箱子中的链表长度并不发生改变，因此也就不能提高哈希表的查询性能。</p>
<h2 id="哈希表的两个问题"><a href="#哈希表的两个问题" class="headerlink" title="哈希表的两个问题"></a>哈希表的两个问题</h2><p>我们可以从刚才的分析中得出哈希表的如下两个问题：</p>
<ul>
<li>如果哈希表中本来箱子就比较多，扩容时需要重新哈希并移动数据，性能影响较大。</li>
<li>如果哈希函数设计不合理，哈希表在极端情况下会变成线性表，性能极低。</li>
</ul>
<p>这两个问题在Java8中Java官方已经为我们解决了。</p>
<ul>
<li>对于箱子，给定了一个合理的初始容量，既没有太多也没有太少。既不会影响哈希表的遍历速度也很少触发扩容操作</li>
<li>当箱子成了长链表之后，在链表长度超过8之后会变成红黑树。</li>
</ul>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>同样我们针对于Map接口的TreeMap实现类和Set接口的TreeSet实现类来学习一下红黑树。</p>
<h2 id="什么是红黑树"><a href="#什么是红黑树" class="headerlink" title="什么是红黑树"></a>什么是红黑树</h2><p>红黑树也是平衡二叉树的一种。</p>
<p>他为什么会出生呢，究其原因肯定是在某些方面该数据结构具有更好地效率。</p>
<p>我们知道，由于二叉查找树在特殊情况下会变成链表大大影响查找性能的原因我们有了AVL树，而紧接着由于AVL树高度平衡的性质，频繁的插入和删除，会引起频繁的reblance，导致效率下降的原因我们就有了红黑树这个数据结构。</p>
<p>红黑树不是高度平衡的，算是一种折中，它是局部平衡的。插入最多两次旋转，删除最多三次旋转。</p>
<p><strong>二叉查找树偏向问题：</strong></p>
<p>在二叉查找树上，我们插入节点的过程是这样的：小于节点值往右继续与左子节点比，大于则继续与右子节点比，直到某节点左或右子节点为空，把值插入进去。这样无法避免偏向问题</p>
<p>所以我们就有了平衡树这么一个概念。这样的树结构能够使我们任何的元素在插入与删除的时候依旧能够保持任意节点左右子树高度不相差1。</p>
<h2 id="红黑树原型2-3树"><a href="#红黑树原型2-3树" class="headerlink" title="红黑树原型2-3树"></a>红黑树原型2-3树</h2><p>红黑树明显很好地解决了这个问题。但是它的原型其实是2-3树。</p>
<p><img src="https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/23-tree-example.png" alt=""></p>
<p>如图即是一个典型的2-3树。</p>
<p>在2-3树中，共有两种节点。第一种是“2-节点”：</p>
<p><img src="https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/23-2-node-example.png" alt=""></p>
<p>该节点性质和二叉查找树种节点性质一致。左孩子小于该节点，右孩子大于该节点</p>
<p>第二种是“3-节点”：</p>
<p><img src="https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/23-3-node-example.png" alt=""></p>
<p>该节点和2-节点不同的是多了一条分支。最左边的儿子表示比a小的子树，中间的儿子表示大于a但小于b的子树，右边的儿子表示比b大的子树。</p>
<p>虽然这是2-3树，我们能直观的看到数中是不存在“4-节点”的。但是为了保持树的平衡性，我们将会利用4-节点来在插入和删除过程中保持树的完美平衡。下面是一个4-节点：</p>
<p><img src="https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/23-4-node-example.png" alt=""></p>
<p>该节点的分支思路和3-节点一致。</p>
<p><strong>那么2-3树是如何避免二叉查找树中偏向的问题的呢？</strong></p>
<p>很简单，我们来参考一个节点插入步骤图。</p>
<p><img src="https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/23-tree-insert-example.png" alt=""></p>
<p>总的概括起来就是当有新节点插入时</p>
<ul>
<li>合并2-节点为3-节点，扩充将3-节点扩充为一个4-节点</li>
<li>分解4-节点为3-节点，再分解3-节点为2-节点，分解后多出的元素向上回溯。</li>
<li>重复不断调整，致使整个树平衡。</li>
</ul>
<p>当然我们一个树的平衡，不光是要插入时保持平衡同时在做删除操作操作的时候我们也要保持它的持续平衡。2-3树的删除操作平衡调整比较复杂。我也没有完全理解，有兴趣可以参考：</p>
<p><a href="https://riteme.github.io/blog/2016-3-12/2-3-tree-and-red-black-tree.html#fn:red-is-left" target="_blank" rel="external">2-3树与红黑树</a></p>
<h2 id="2-3到红黑树"><a href="#2-3到红黑树" class="headerlink" title="2-3到红黑树"></a>2-3到红黑树</h2><p>我们在了解了2-3树对于解决节点偏移的问题的处理思路之后可以很明显的感觉到，其中需要大量的节点变换。这些变换在实际代码中是很复杂的。所以现在几乎没有2-3树的具体实现。</p>
<p>红黑树也是一种平衡二叉树，但相比于2-3树，红黑树只有一种2-节点。但既然我们要想做和2-3树一样的工作却不给它3-节点，无疑我们把3节点都用合理的方式拆分了。</p>
<p>如何表示3-节点呢？我们尝试一种特殊的边：默认情况下节点的颜色均为黑色。我们将某个节点染为红色，表示它和父亲的的链接是红色的，就像下图：</p>
<p><img src="https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/rbtree-red-node-normal.png" alt=""></p>
<p>当我们将红链接画平时</p>
<p><img src="https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/rbtree-red-node-flat.png" alt=""></p>
<p>可以看到，这不就是我们刚才2-3树种的3-节点吗。而事实上，我们完全可以用这样的方式来表示2-3树中的3-节点。</p>
<p>如下即是一颗典型的红黑树：<br><img src="https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/rbtree-example-1.png" alt=""></p>
<p>将该树种所有红链接画平，将得到一棵完美平衡的“2-3树”。</p>
<h2 id="红黑树是如何保证平衡"><a href="#红黑树是如何保证平衡" class="headerlink" title="红黑树是如何保证平衡"></a>红黑树是如何保证平衡</h2><p>相比于2-3树不断变换节点的缺陷来说。由于红黑树的节点都是2-节点所以其处理方式更简洁。</p>
<ul>
<li>旋转：顺时针旋转和逆时针旋转</li>
<li>反色：交换红黑的颜色</li>
</ul>
<p>这两个操作相对于2-3树种的节点变换要简单许多。</p>
<p>具体可以参考：<a href="https://riteme.github.io/blog/2016-3-12/2-3-tree-and-red-black-tree.html#fn:red-is-left" target="_blank" rel="external">2-3树与红黑树</a></p>
<h2 id="红黑树如何定义"><a href="#红黑树如何定义" class="headerlink" title="红黑树如何定义"></a>红黑树如何定义</h2><ul>
<li>红黑树是二叉搜索树。</li>
<li>根节点必须为黑色。毕竟根节点没有父亲。</li>
<li>红链接必须在左侧。将红链接统一在一个方向是为了方便其它操作。</li>
<li>不允许两个连续的红链接。因为连续的连个红链接表示的是4-节点。</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点(每一条树链上的黑色节点数量（称之为“黑高”）必须相等)。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>简单介绍了Map接口的结构及其常用Api</li>
<li>介绍了Map接口的常用实现类并为后面研究其实现类做铺垫了解了其实现类HashMap和TreeMap的底层数据结构，散列表和红黑树</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;首先声明本文使用的是jdk1.8&lt;/p&gt;
&lt;h1 id=&quot;Map映射&quot;&gt;&lt;a href=&quot;#Map映射&quot; class=&quot;headerlink&quot; title=&quot;Map映射&quot;&gt;&lt;/a&gt;Map映射&lt;/h1&gt;&lt;p&gt;Map即双列集合。但我们一般称它为映射，即键值对的形式。&lt;/p&gt;
&lt;h2 id=&quot;Map映射的特点&quot;&gt;&lt;a href=&quot;#Map映射的特点&quot; class=&quot;headerlink&quot; title=&quot;Map映射的特点&quot;&gt;&lt;/a&gt;Map映射的特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;键值对形式存储元素。&lt;/li&gt;
&lt;li&gt;Collection集合子接口List元素可以重复，Set不可以重复，而Map是键唯一，值可以重复。&lt;/li&gt;
&lt;li&gt;Map集合的数据结构针对于键，和值无关。Collection的数据结构针和元素有关。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>List集合了解一下</title>
    <link href="http://www.jiyongguang.xin/list.html"/>
    <id>http://www.jiyongguang.xin/list.html</id>
    <published>2018-05-07T11:30:39.000Z</published>
    <updated>2018-08-14T00:29:42.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先声明本文使用的是jdk1.8</p>
<h1 id="List-常见实现类"><a href="#List-常见实现类" class="headerlink" title="List 常见实现类"></a>List 常见实现类</h1><p>根据上篇Collection的文章我们了解了List的几个常见实现类。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-6/62463586.jpg" alt=""></p>
<a id="more"></a>
<ul>
<li>ArrayList：<br>底层数据结构是数组。线程不安全</li>
<li>LinkedList：<br>底层数据结构是链表。线程不安全</li>
<li>Vector：<br>底层数据结构是数组。线程安全</li>
</ul>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList的实现和继承结构</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-6/36658352.jpg" alt=""></p>
<h2 id="ArrayList类特点"><a href="#ArrayList类特点" class="headerlink" title="ArrayList类特点"></a>ArrayList类特点</h2><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-6/9477343.jpg" alt=""></p>
<ul>
<li>可动态的改变数组的大小(数组的拷贝)。</li>
<li>和Vector类函数实现相似，区别只是线程不安全。</li>
</ul>
<p>另外Vector有许多设计上的不足，不建议使用。当多条线程访问ArrayList集合时，程序需要手动保证该集合的同步性，而Vector则是线程安全的。</p>
<h2 id="ArrayList解析"><a href="#ArrayList解析" class="headerlink" title="ArrayList解析"></a>ArrayList解析</h2><h3 id="ArrayList属性解析"><a href="#ArrayList属性解析" class="headerlink" title="ArrayList属性解析"></a>ArrayList属性解析</h3><p><img src="https://upload-images.jianshu.io/upload_images/5291509-831af19e86716f2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>其实注释写的都很清晰</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><img src="https://upload-images.jianshu.io/upload_images/5291509-542091048e8d4ba8?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>前两种方式十分的简单，需要注意的就是第三种：</p>
<p>在通过一个Collection来构造ArrayList的时候，其toArray函数可能不能成功返回一个Object[]类型的数组。需要我们再把elementData数组中的元素拷贝到Object[size]类型的数组中并重新赋值给elementData。</p>
<h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><p><img src="https://upload-images.jianshu.io/upload_images/5291509-dcfb6a236b5ec749?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>函数处理步骤：</p>
<ul>
<li>检查是否需要扩容</li>
<li>插入元素</li>
</ul>
<p>元素在插入到集合前需要先对ArrayList进行判断是否需要扩容。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-6/43895044.jpg" alt=""></p>
<p><strong>ensureCapacityInternal函数来确定真正的数组最小容量minCapacity</strong></p>
<p>拿（当前元素个数+1）来进行判断。如果当前容器没有进行初始化。那么取minCapacity和DEFAULT_CAPACITY两个元素中较大的值作为数组的最小容量(也就是需求容量在10以下我们也把数组初始化成了容量为10，防止频繁的扩容操作)。</p>
<p><strong>ensureExplicitCapacity函数记录容器的更改状态并判断容器是否真的需要扩容</strong></p>
<p>modCount记录容器被修改过的次数。当通过ensureCapacityInternal函数确定的容器最小容量minCapacity大于数组当前大小时。调用grow函数来对数组进行扩容</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-6/15299931.jpg" alt=""></p>
<ul>
<li>如果扩容1.5倍后还小于需要的最小容量，干脆让数组容量等于minCapacity。</li>
<li>如果数组要求的最小容量已经大于数组所被允许的最大容量限制。让其容量最大只能等于Integer.MAX_VALUE。</li>
</ul>
<hr>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-6/27359990.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * The maximum size of array to allocate.</div><div class="line"> * Some VMs reserve some header words in an array.</div><div class="line"> * Attempts to allocate larger arrays may result in</div><div class="line"> * OutOfMemoryError: Requested array size exceeds VM limit</div><div class="line"> */</div><div class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</div></pre></td></tr></table></figure>
<ul>
<li>根据释义我们可以知道一些虚拟机在数组头会保存一些头元素。</li>
<li>请求的数组过大的话会出现OOM异常。可能会超出部分VM的限制</li>
</ul>
<hr>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-6/52147364.jpg" alt=""></p>
<ul>
<li>源码叙述的很清晰。接着上面的看，对elementData进行拷贝。将该数组元素拷贝到一个也是该数组类型的且容量为newCapacity的数组中。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>首先去检查一下数组的容量是否足够<ul>
<li>足够：直接添加</li>
<li>不足够：扩容<ul>
<li>扩容到原来的1.5倍</li>
<li>第一次扩容后，如果容量还是小于minCapacity，就将容量扩充为minCapacity。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-6/86531355.jpg" alt=""></p>
<p>函数处理步骤：</p>
<ul>
<li>要插入元素的位置判断。是否小于0或超出当前数组元素</li>
<li>扩容判断</li>
<li>数组拷贝</li>
</ul>
<p>由于ensureCapacityInternal函数的保障，所以这里数组元素移位即可。<br><img src="http://otsgsfu16.bkt.clouddn.com/18-5-6/85934960.jpg" alt=""></p>
<p>可以发现在ArrayList中由于底层实现是由数组来作为容器。所以与扩容相关的add函数底层其实都是arraycopy()来实现的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5291509-7f9c668a5de8b6e8?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>而其又是native函数，底层是由C/C++来编写的。但该函数的相比于我们自定义的数组拷贝实现要性能高得多。更有可能得到细致的优化，应该尽可能去使用它。</p>
<p>参考R大回答：<a href="https://www.zhihu.com/question/53749473" target="_blank" rel="external">https://www.zhihu.com/question/53749473</a></p>
<h3 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h3><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-6/43844940.jpg" alt=""></p>
<p>字面意思</p>
<h3 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h3><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-6/86626913.jpg" alt=""></p>
<p>字面意思</p>
<h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><p><img src="https://upload-images.jianshu.io/upload_images/5291509-63f2ebc31d406191?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>正如注释中所述。</p>
<p>函数处理步骤：</p>
<ul>
<li>index索引边界判断</li>
<li>modCount变量的维护</li>
<li>取出数组index处元素用于结果返回</li>
<li>数组元素从index+1处开始依次往前移一位。</li>
</ul>
<p>其实看完remove函数之后，我比较疑惑为什么jdk开发人员在设计remove函数的时候不和add函数一样动态的维护数组的大小呢？因为我自己在学习数据结构的时候，设计<a href="https://github.com/JYG0723/play-with-data-structures/blob/master/Array/src/Array.java" target="_blank" rel="external">我的ArrayList集合类</a>的时候其add函数和remove函数都根据数组现有元素数量和数组总容量做了一个系数比，根据系数比动态的维护了其容量。</p>
<p>后来仔细一想，这么设计也确实很合理。ArrayList作为List接口常用的实现类之一，既然其容量确实到达过一个峰值。即便其后来被降下来了，也很难保证其后续不会再升回去。因为既然原来能到达，那么后续也肯定可以到达。所以既然这样就需要函数体中频繁的判断，频繁的扩容缩容性能上无疑会更大的放大了ArrayList在增删上的劣势。不可取</p>
<h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h3><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/78641386.jpg" alt=""></p>
<p>remove函数由于性能影响在删除元素后既然不能缩容，Java开发人员提供了该函数供开发人员根据自己的需要来对数组缩容。底层依旧调用的是System类的arraycopy函数。</p>
<h2 id="我设计的ArrayList"><a href="#我设计的ArrayList" class="headerlink" title="我设计的ArrayList"></a>我设计的ArrayList</h2><p>Github地址 - <a href="https://github.com/JYG0723/play-with-data-structures/blob/master/Array/src/Array.java" target="_blank" rel="external">我设计的ArrayList</a></p>
<p>实现了Arraylist的部分常见功能。</p>
<h1 id="Vector与ArrayList区别"><a href="#Vector与ArrayList区别" class="headerlink" title="Vector与ArrayList区别"></a>Vector与ArrayList区别</h1><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/31870233.jpg" alt=""></p>
<p>Java开发人员已经告诉我们了。</p>
<ul>
<li>出生于jdk1.0时代，并在jdk1.2的时候被改造为实现List接口。</li>
<li>底层也是动态数组实现</li>
<li>它是线程安全的</li>
<li>如果不需要线程安全的实现，建议使用ArrayList代替Vector(早期设计有些许缺陷)。</li>
</ul>
<p>可以从图中很明显的看出，Vector类在很多对其底层数组结构有修改作用的函数上都加上了synchronized关键字来保证其线程安全性。<br><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/13712503.jpg" alt=""></p>
<p>如果想要ArrayList实现同步，可以使用Collections的方法：<code>List list = Collections.synchronizedList(new ArrayList(...));</code>，就可以实现同步了。</p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/93260561.jpg" alt=""></p>
<p>还有另一个区别：</p>
<p>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，而Vector如果未指定其capacityIncrement参数时，其默认初始容量为10，且该参数<strong>容量自动增长值</strong>为0。那么Vector的容量扩展1倍。 </p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/25567210.jpg" alt=""></p>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>LinkedList的实现和继承结构<br><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/35517458.jpg" alt=""></p>
<h2 id="LinkedList类特点"><a href="#LinkedList类特点" class="headerlink" title="LinkedList类特点"></a>LinkedList类特点</h2><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/14468899.jpg" alt=""></p>
<ul>
<li>LinkedList底层是双向链表</li>
<li>允许存储NULL</li>
<li>线程不安全的，解决办法和Arraylist一样，通过Collections工具类来封装一下。并且在迭代的时候需要外部手动锁住该LinkedList的实例</li>
</ul>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/38073907.jpg" alt=""></p>
<p>LinkedList 类还为在列表的开头及结尾 get，remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p>
<h2 id="LinkedList解析"><a href="#LinkedList解析" class="headerlink" title="LinkedList解析"></a>LinkedList解析</h2><h3 id="LinkedList属性解析"><a href="#LinkedList属性解析" class="headerlink" title="LinkedList属性解析"></a>LinkedList属性解析</h3><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/94973405.jpg" alt=""></p>
<p>LinkedList的属性和<a href="https://github.com/JYG0723/play-with-data-structures/blob/master/LinkedList/src/LinkedList.java" target="_blank" rel="external">我们自己设计的LinkedList</a>一模一样。</p>
<p>很简单由于是双向链表就必然有头结点和尾节点两个属性，再加一个size变量指定LinkedList元素数量方便我们维护。</p>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p><img src="https://upload-images.jianshu.io/upload_images/5291509-2ce531d4d7337e55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/84925543.jpg" alt=""></p>
<p>其实构造思路很简单。第二种无非就是把一个集合迭代的跟到LinkedList实例之后。然后根据一些不同的case进行处理。和我们设计的LinkedList处理思路是一样的，只是可能它设计的更严谨一些。</p>
<h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/68771441.jpg" alt=""></p>
<p>我设计的LinkedList是单向链表，所以为了保证add函数的性能选择了头插法。而LinkedList的实现由于是双向链表，所以必然是尾插法才合理。</p>
<h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/9166703.jpg" alt=""></p>
<ul>
<li>如注释所述，删除链表中第一次出现和指定元素的item属性equals的元素。</li>
</ul>
<p>前提是需要对可能存在的NULL元素做过滤处理。避免空指针异常。</p>
<p><strong>unlike函数</strong>：</p>
<ul>
<li>其实就是具体的负责链表中元素的删除工作。</li>
<li>modCount变量的维护</li>
<li>具体逻辑的判断不同case的处理(其实和我们的实现思路一样)</li>
</ul>
<p>可以看出unlink函数的局部变量使用了final关键字来修饰。从一定程度上避免了一些由于LinkedList是线程不安全的类所带来的线程安全问题。同时也带来了一些性能上的提升</p>
<h3 id="get-int-index-1"><a href="#get-int-index-1" class="headerlink" title="get(int index)"></a>get(int index)</h3><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/59506119.jpg" alt=""></p>
<p>和我们正常获取元素的思路一致。对于LinkedList来说由于底层是双向链表，我们要向获取到指定位置的元素只能通过遍历的方式。但是Java开发人员想的非常周到，首先对index索引进行了大小判断，看时候大于size的一半，直接就是查询范围缩小了一半。更加高效</p>
<h3 id="set-int-index-E-element-1"><a href="#set-int-index-E-element-1" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h3><p><img src="http://otsgsfu16.bkt.clouddn.com/18-5-7/52544506.jpg" alt=""></p>
<p>如同注释描述的一致，没有多余操作，由于关系到index索引，所以按例检查一下。然后进行替换即可。</p>
<h2 id="我设计的LinkedList"><a href="#我设计的LinkedList" class="headerlink" title="我设计的LinkedList"></a>我设计的LinkedList</h2><p>Github地址 - <a href="https://github.com/JYG0723/play-with-data-structures/blob/master/LinkedList/src/LinkedList.java" target="_blank" rel="external">我设计的ArrayList</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul>
<li>ArrayList是基于动态数组实现的，在增删时候，需要调用System类的arraycopy函数进行拷贝复制((navite 函数底层由C/C++实现)。</li>
<li>ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的一半，也就是变为原来的1.5倍</li>
<li>删除元素时不会减少容量，若希望减少容量则调用trimToSize()</li>
<li>它大体上相似Vector，但不是线程安全的。多线程环境下，任何关于ArrayList集合类结构上的更改，为保障线程安全，我们都需要程序内手动的维护</li>
<li>能存放NULL值，元素可重复，且有序。</li>
</ul>
<h2 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul>
<li>LinkedList底层是双向链表(更方便获取指定元素)</li>
<li>允许存储NULL</li>
<li>线程不安全的，解决办法和Arraylist一样，通过Collections工具类来封装一下。并且在迭代的时候需要外部手动锁住该LinkedList的实例</li>
</ul>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul>
<li>出生于jdk1.0时代，并在jdk1.2的时候被改造为实现List接口。</li>
<li>底层也是动态数组实现</li>
<li>它是函数操作是线程安全的</li>
<li>现在已少用，被ArrayList替代，原因：<ul>
<li>Vector所有方法都是同步，函数执行上有性能的损失，并且程序在函数执行前后要加锁和释放锁开销都比较大。</li>
<li>Vector初始length是10 超过length时，如果未指定扩容大小。以成倍态势增长，相比于ArrayList开销更多内存。</li>
<li>出生早，设计可能不那么好</li>
</ul>
</li>
</ul>
<p>并且它唯一的优点，部分函数的线程安全对于我们来说，也不是必须的。</p>
<p>具体可参考：<a href="https://www.zhihu.com/question/31948523/answer/113357347" target="_blank" rel="external">java数据结构中，什么情况下用Vector,什么情况下用ArrayList呢？
</a></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li>查询多用ArrayList，增删多用LinkedList。</li>
<li>ArrayList增删慢也是在大数据量的前提下。在我实现的数据结构中进行了测试(10w~),少量数据差别不大</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;首先声明本文使用的是jdk1.8&lt;/p&gt;
&lt;h1 id=&quot;List-常见实现类&quot;&gt;&lt;a href=&quot;#List-常见实现类&quot; class=&quot;headerlink&quot; title=&quot;List 常见实现类&quot;&gt;&lt;/a&gt;List 常见实现类&lt;/h1&gt;&lt;p&gt;根据上篇Collection的文章我们了解了List的几个常见实现类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://otsgsfu16.bkt.clouddn.com/18-5-6/62463586.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jiyongguang.xin/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.jiyongguang.xin/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
